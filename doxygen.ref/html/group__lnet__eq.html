<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Events and event queues</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Events and event queues<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>Event queues (abbreviated as EQ) are used to log operations performed on local MDs.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__event__t.html">lnet_event_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about an event on a MD.  <a href="structlnet__event__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga1d29f84babe23bedcc4391c2c6fabb3a">LNET_SEQ_BASETYPE</a>&nbsp;&nbsp;&nbsp;long</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gab910a092c7399ac0079f306ee843dd43">LNET_SEQ_GT</a>(a, b)&nbsp;&nbsp;&nbsp;(((signed LNET_SEQ_BASETYPE)((a) - (b))) &gt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga19f17d1046e4b07f4a82b6b09fa89821">LNET_EQ_HANDLER_NONE</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned LNET_SEQ_BASETYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gaa852e678ebaca5da7e2de48b659e50a6">lnet_seq_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a> )(<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event queue handler function type.  <a href="#ga79dedea26148b7a6e911c83996f7ae2e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">lnet_event_kind_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495">LNET_EVENT_GET</a> =  1, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559">LNET_EVENT_PUT</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554">LNET_EVENT_REPLY</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba">LNET_EVENT_ACK</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5">LNET_EVENT_SEND</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d">LNET_EVENT_UNLINK</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Six types of events can be logged in an event queue. </p>
 <a href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga6af2966611a22331fc4905d17e5a2779">LNetEQAlloc</a> (unsigned int count_in, <a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a> handler, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an event queue that has room for <em>count</em> number of events.  <a href="#ga6af2966611a22331fc4905d17e5a2779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gad960a84b5325f9e518e0eef419a8c741">LNetEQFree</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the resources associated with an event queue if it's idle; otherwise do nothing and it's up to the user to try again.  <a href="#gad960a84b5325f9e518e0eef419a8c741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b">LNetEQGet</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A nonblocking function that can be used to get the next event in an EQ.  <a href="#gae6d5740f0da715e176d47af9f638521b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21">LNetEQWait</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the calling process until there is an event in the EQ.  <a href="#ga7cefc01394a06655eec46dcf3904ea21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30">LNetEQPoll</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *eventqs_in, int neq_in, int timeout_ms, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out, int *which_eq_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the calling process until there's an event from a set of EQs or timeout happens.  <a href="#gaa723e6bf5041559683351354208f8a30"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Event queues (abbreviated as EQ) are used to log operations performed on local MDs. </p>
<p>In particular, they signal the completion of a data transmission into or out of a MD. They can also be used to hold acknowledgments for completed PUT operations and indicate when a MD has been unlinked. Multiple MDs can share a single EQ. An EQ may have an optional event handler associated with it. If an event handler exists, it will be run for each event that is deposited into the EQ.</p>
<p>In addition to the lnet_handle_eq_t, the LNet API defines two types associated with events: The <a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a" title="Six types of events can be logged in an event queue.">lnet_event_kind_t</a> defines the kinds of events that can be stored in an EQ. The <a class="el" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> defines a structure that holds the information about with an event.</p>
<p>There are five functions for dealing with EQs: <a class="el" href="group__lnet__eq.html#ga6af2966611a22331fc4905d17e5a2779" title="Create an event queue that has room for count number of events.">LNetEQAlloc()</a> is used to create an EQ and allocate the resources needed, while <a class="el" href="group__lnet__eq.html#gad960a84b5325f9e518e0eef419a8c741" title="Release the resources associated with an event queue if it&#39;s idle; otherwise...">LNetEQFree()</a> releases these resources and free the EQ. <a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b" title="A nonblocking function that can be used to get the next event in an EQ.">LNetEQGet()</a> retrieves the next event from an EQ, and <a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21" title="Block the calling process until there is an event in the EQ.">LNetEQWait()</a> can be used to block a process until an EQ has at least one event. <a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a> can be used to test or wait on multiple EQs. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga19f17d1046e4b07f4a82b6b09fa89821"></a><!-- doxytag: member="types.h::LNET_EQ_HANDLER_NONE" ref="ga19f17d1046e4b07f4a82b6b09fa89821" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_EQ_HANDLER_NONE&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00629">629</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="lib-eq_8c_source.html#l00212">lnet_eq_enqueue_event()</a>, <a class="el" href="api-ni_8c_source.html#l02169">lnet_ping()</a>, and <a class="el" href="lib-eq_8c_source.html#l00070">LNetEQAlloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d29f84babe23bedcc4391c2c6fabb3a"></a><!-- doxytag: member="types.h::LNET_SEQ_BASETYPE" ref="ga1d29f84babe23bedcc4391c2c6fabb3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_SEQ_BASETYPE&nbsp;&nbsp;&nbsp;long</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00542">542</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab910a092c7399ac0079f306ee843dd43"></a><!-- doxytag: member="types.h::LNET_SEQ_GT" ref="gab910a092c7399ac0079f306ee843dd43" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_SEQ_GT</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((signed LNET_SEQ_BASETYPE)((a) - (b))) &gt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00544">544</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="lib-eq_8c_source.html#l00241">lnet_eq_dequeue_event()</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga79dedea26148b7a6e911c83996f7ae2e"></a><!-- doxytag: member="types.h::lnet_eq_handler_t" ref="ga79dedea26148b7a6e911c83996f7ae2e" args=")(lnet_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a>)(<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event queue handler function type. </p>
<p>The EQ handler runs for each event that is deposited into the EQ. The handler is supplied with a pointer to the event that triggered the handler invocation.</p>
<p>The handler must not block, must be reentrant, and must not call any LNet API functions. It should return as quickly as possible. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00628">628</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa852e678ebaca5da7e2de48b659e50a6"></a><!-- doxytag: member="types.h::lnet_seq_t" ref="gaa852e678ebaca5da7e2de48b659e50a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned LNET_SEQ_BASETYPE <a class="el" href="group__lnet__eq.html#gaa852e678ebaca5da7e2de48b659e50a6">lnet_seq_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00543">543</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga03bee040520d7fabad1b3b661bd7228a"></a><!-- doxytag: member="types.h::lnet_event_kind_t" ref="ga03bee040520d7fabad1b3b661bd7228a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">lnet_event_kind_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Six types of events can be logged in an event queue. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495"></a><!-- doxytag: member="LNET_EVENT_GET" ref="gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495" args="" -->LNET_EVENT_GET</em>&nbsp;</td><td>
<p>An incoming GET operation has completed on the MD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559"></a><!-- doxytag: member="LNET_EVENT_PUT" ref="gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559" args="" -->LNET_EVENT_PUT</em>&nbsp;</td><td>
<p>An incoming PUT operation has completed on the MD. </p>
<p>The underlying layers will not alter the memory (on behalf of this operation) once this event has been logged. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554"></a><!-- doxytag: member="LNET_EVENT_REPLY" ref="gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554" args="" -->LNET_EVENT_REPLY</em>&nbsp;</td><td>
<p>A REPLY operation has completed. </p>
<p>This event is logged after the data (if any) from the REPLY has been written into the MD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba"></a><!-- doxytag: member="LNET_EVENT_ACK" ref="gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba" args="" -->LNET_EVENT_ACK</em>&nbsp;</td><td>
<p>An acknowledgment has been received. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5"></a><!-- doxytag: member="LNET_EVENT_SEND" ref="gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5" args="" -->LNET_EVENT_SEND</em>&nbsp;</td><td>
<p>An outgoing send (PUT or GET) operation has completed. </p>
<p>This event is logged after the entire buffer has been sent and it is safe for the caller to reuse the buffer.</p>
<p>Note:</p>
<ul>
<li>The LNET_EVENT_SEND doesn't guarantee message delivery. It can happen even when the message has not yet been put out on wire.</li>
<li>It's unsafe to assume that in an outgoing GET operation the LNET_EVENT_SEND event would happen before the LNET_EVENT_REPLY event. The same holds for LNET_EVENT_SEND and LNET_EVENT_ACK events in an outgoing PUT operation. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d"></a><!-- doxytag: member="LNET_EVENT_UNLINK" ref="gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d" args="" -->LNET_EVENT_UNLINK</em>&nbsp;</td><td>
<p>A MD has been unlinked. </p>
<p>Note that <a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a> does not necessarily trigger an LNET_EVENT_UNLINK event. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00504">504</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6af2966611a22331fc4905d17e5a2779"></a><!-- doxytag: member="api.h::LNetEQAlloc" ref="ga6af2966611a22331fc4905d17e5a2779" args="(unsigned int count_in, lnet_eq_handler_t handler, lnet_handle_eq_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQAlloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an event queue that has room for <em>count</em> number of events. </p>
<p>The event queue is circular and older events will be overwritten by new ones if they are not removed in time by the user using the functions <a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b" title="A nonblocking function that can be used to get the next event in an EQ.">LNetEQGet()</a>, <a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21" title="Block the calling process until there is an event in the EQ.">LNetEQWait()</a>, or <a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a>. It is up to the user to determine the appropriate size of the event queue to prevent this loss of events. Note that when EQ handler is specified in <em>callback</em>, no event loss can happen, since the handler is run for each event deposited into the EQ.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of events to be stored in the event queue. It will be rounded up to the next power of two. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A handler function that runs when an event is deposited into the EQ. The constant value LNET_EQ_HANDLER_NONE can be used to indicate that no event handler is desired. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>On successful return, this location will hold a handle for the newly created EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>If an parameter is not valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If memory for the EQ can't be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e" title="Event queue handler function type.">lnet_eq_handler_t</a> for the discussion on EQ <a class="el" href="rename__many_8c.html#a3c2348f39cf58c5c0f48742b32b15d83">handler</a> semantics. </dd></dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00070">70</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="libcfs__mem_8c_source.html#l00078">cfs_percpt_alloc()</a>, <a class="el" href="libcfs__mem_8c_source.html#l00049">cfs_percpt_free()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00277">CWARN</a>, <a class="el" href="lib-types_8h_source.html#l00139">eq_callback</a>, <a class="el" href="lib-types_8h_source.html#l00137">eq_deq_seq</a>, <a class="el" href="lib-types_8h_source.html#l00136">eq_enq_seq</a>, <a class="el" href="lib-types_8h_source.html#l00140">eq_events</a>, <a class="el" href="lib-types_8h_source.html#l00135">eq_lh</a>, <a class="el" href="lib-types_8h_source.html#l00134">eq_list</a>, <a class="el" href="lib-types_8h_source.html#l00141">eq_refs</a>, <a class="el" href="lib-types_8h_source.html#l00138">eq_size</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="libcfs__private_8h_source.html#l00291">LIBCFS_ALLOC</a>, <a class="el" href="libcfs__private_8h_source.html#l00290">LIBCFS_FREE</a>, <a class="el" href="list_8h_source.html#l00076">list_add()</a>, <a class="el" href="lib-types_8h_source.html#l00587">lnet_t::ln_eq_container</a>, <a class="el" href="lib-types_8h_source.html#l00642">lnet_t::ln_refcount</a>, <a class="el" href="lib-lnet_8h_source.html#l00118">lnet_cpt_table</a>, <a class="el" href="lib-lnet_8h_source.html#l00287">lnet_eq2handle()</a>, <a class="el" href="lib-lnet_8h_source.html#l00186">lnet_eq_alloc()</a>, <a class="el" href="lib-lnet_8h_source.html#l00195">lnet_eq_free()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00629">LNET_EQ_HANDLER_NONE</a>, <a class="el" href="lib-lnet_8h_source.html#l00178">lnet_eq_wait_lock</a>, <a class="el" href="lib-lnet_8h_source.html#l00179">lnet_eq_wait_unlock</a>, <a class="el" href="lib-lnet_8h_source.html#l00075">LNET_LOCK_EX</a>, <a class="el" href="api-ni_8c_source.html#l00529">lnet_res_lh_initialize()</a>, <a class="el" href="lib-lnet_8h_source.html#l00132">lnet_res_lock()</a>, <a class="el" href="lib-lnet_8h_source.html#l00138">lnet_res_unlock()</a>, <a class="el" href="lib-types_8h_source.html#l00546">lnet_res_container::rec_active</a>, and <a class="el" href="api-ni_8c_source.html#l00043">the_lnet</a>.</p>

<p>Referenced by <a class="el" href="api-ni_8c_source.html#l02169">lnet_ping()</a>, <a class="el" href="api-ni_8c_source.html#l00915">lnet_ping_info_setup()</a>, <a class="el" href="router_8c_source.html#l01054">lnet_router_checker_start()</a>, <a class="el" href="events_8c_source.html#l00583">ptlrpc_ni_init()</a>, and <a class="el" href="rpc_8c_source.html#l01582">srpc_startup()</a>.</p>

</div>
</div>
<a class="anchor" id="gad960a84b5325f9e518e0eef419a8c741"></a><!-- doxytag: member="api.h::LNetEQFree" ref="gad960a84b5325f9e518e0eef419a8c741" args="(lnet_handle_eq_t eventq_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eqh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the resources associated with an event queue if it's idle; otherwise do nothing and it's up to the user to try again. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eqh</em>&nbsp;</td><td>A handle for the event queue to be released.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>If the EQ is not in use and freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eqh</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>If the EQ is still in use by some MDs. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00156">156</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__cpu_8h_source.html#l00213">cfs_percpt_for_each</a>, <a class="el" href="libcfs__mem_8c_source.html#l00049">cfs_percpt_free()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00138">D_NET</a>, <a class="el" href="lib-types_8h_source.html#l00140">eq_events</a>, <a class="el" href="lib-types_8h_source.html#l00135">eq_lh</a>, <a class="el" href="lib-types_8h_source.html#l00134">eq_list</a>, <a class="el" href="lib-types_8h_source.html#l00141">eq_refs</a>, <a class="el" href="lib-types_8h_source.html#l00138">eq_size</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="libcfs__private_8h_source.html#l00290">LIBCFS_FREE</a>, <a class="el" href="list_8h_source.html#l00116">list_del()</a>, <a class="el" href="lib-types_8h_source.html#l00642">lnet_t::ln_refcount</a>, <a class="el" href="lib-lnet_8h_source.html#l00195">lnet_eq_free()</a>, <a class="el" href="lib-lnet_8h_source.html#l00178">lnet_eq_wait_lock</a>, <a class="el" href="lib-lnet_8h_source.html#l00179">lnet_eq_wait_unlock</a>, <a class="el" href="lib-lnet_8h_source.html#l00298">lnet_handle2eq()</a>, <a class="el" href="lib-lnet_8h_source.html#l00075">LNET_LOCK_EX</a>, <a class="el" href="lib-lnet_8h_source.html#l00279">lnet_res_lh_invalidate()</a>, <a class="el" href="lib-lnet_8h_source.html#l00132">lnet_res_lock()</a>, <a class="el" href="lib-lnet_8h_source.html#l00138">lnet_res_unlock()</a>, <a class="el" href="cascading__rw_8c_source.html#l00061">size</a>, and <a class="el" href="api-ni_8c_source.html#l00043">the_lnet</a>.</p>

<p>Referenced by <a class="el" href="api-ni_8c_source.html#l02169">lnet_ping()</a>, <a class="el" href="api-ni_8c_source.html#l00915">lnet_ping_info_setup()</a>, <a class="el" href="api-ni_8c_source.html#l01052">lnet_ping_target_fini()</a>, <a class="el" href="router_8c_source.html#l01054">lnet_router_checker_start()</a>, <a class="el" href="router_8c_source.html#l01102">lnet_router_checker_stop()</a>, <a class="el" href="events_8c_source.html#l00542">ptlrpc_ni_fini()</a>, and <a class="el" href="rpc_8c_source.html#l01630">srpc_shutdown()</a>.</p>

</div>
</div>
<a class="anchor" id="gae6d5740f0da715e176d47af9f638521b"></a><!-- doxytag: member="api.h::LNetEQGet" ref="gae6d5740f0da715e176d47af9f638521b" args="(lnet_handle_eq_t eventq_in, lnet_event_t *event_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eventq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A nonblocking function that can be used to get the next event in an EQ. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully. The event is removed from the queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventq</em>&nbsp;</td><td>A handle for the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), this location will hold the next event in the EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No pending event in the EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eventq</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ has been dropped due to limited space in the EQ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00290">290</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="lib-eq_8c_source.html#l00392">LNetEQPoll()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa723e6bf5041559683351354208f8a30"></a><!-- doxytag: member="api.h::LNetEQPoll" ref="gaa723e6bf5041559683351354208f8a30" args="(lnet_handle_eq_t *eventqs_in, int neq_in, int timeout_ms, lnet_event_t *event_out, int *which_eq_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQPoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *&nbsp;</td>
          <td class="paramname"> <em>eventqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>neq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>which</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the calling process until there's an event from a set of EQs or timeout happens. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully, in which case the corresponding event is consumed.</p>
<p><a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a> provides a timeout to allow applications to poll, block for a fixed period, or block indefinitely.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventqs,neq</em>&nbsp;</td><td>An array of EQ handles, and size of the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>Time in milliseconds to wait for an event to occur on one of the EQs. The constant LNET_TIME_FOREVER can be used to indicate an infinite timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event,which</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), <em>event</em> will hold the next event in the EQs, and <em>which</em> will contain the index of the EQ from which the event was taken.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No pending event in the EQs after timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ indicated by <em>which</em> has been dropped due to limited space in the EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If there's an invalid handle in <em>eventqs</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00392">392</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lib-types_8h_source.html#l00642">lnet_t::ln_refcount</a>, <a class="el" href="lib-eq_8c_source.html#l00241">lnet_eq_dequeue_event()</a>, <a class="el" href="lib-lnet_8h_source.html#l00178">lnet_eq_wait_lock</a>, <a class="el" href="lib-eq_8c_source.html#l00326">lnet_eq_wait_locked()</a>, <a class="el" href="lib-lnet_8h_source.html#l00179">lnet_eq_wait_unlock</a>, <a class="el" href="lib-lnet_8h_source.html#l00298">lnet_handle2eq()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="api-ni_8c_source.html#l00043">the_lnet</a>.</p>

<p>Referenced by <a class="el" href="api-ni_8c_source.html#l02169">lnet_ping()</a>, <a class="el" href="lib-eq_8c_source.html#l00290">LNetEQGet()</a>, and <a class="el" href="lib-eq_8c_source.html#l00316">LNetEQWait()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cefc01394a06655eec46dcf3904ea21"></a><!-- doxytag: member="api.h::LNetEQWait" ref="ga7cefc01394a06655eec46dcf3904ea21" args="(lnet_handle_eq_t eventq_in, lnet_event_t *event_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eventq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the calling process until there is an event in the EQ. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully. This function returns the next event in the EQ and removes it from the EQ.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventq</em>&nbsp;</td><td>A handle for the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), this location will hold the next event in the EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eventq</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ has been dropped due to limited space in the EQ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00316">316</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00080">LNET_TIME_FOREVER</a>, and <a class="el" href="lib-eq_8c_source.html#l00392">LNetEQPoll()</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:52 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
