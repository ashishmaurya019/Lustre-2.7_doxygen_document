<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_page<br/>
<small>
[<a class="el" href="group__clio.html">clio</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html">cl_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fields are protected by the lock on struct page, except for atomics and immutables.  <a href="structcl__page.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__slice.html">cl_page_slice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer part of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.  <a href="structcl__page__slice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html">cl_page_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer page operations.  <a href="structcl__page__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__client__cache.html">cl_client_cache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data structure managing a client's cached pages.  <a href="structcl__client__cache.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga912e7c9c7d73f184c724593eb42f857a">CL_PAGE_DEBUG</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping detailed information about <em>page</em> into a log.  <a href="#ga912e7c9c7d73f184c724593eb42f857a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4">CL_PAGE_HEADER</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping shorter information about <em>page</em> into a log.  <a href="#gaeeca225390e016ad5bb7ab7ab31e3ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga3f36ee0c41000fd2b189406ddfc160f1">cl_page_in_use</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller itself holds a refcount of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.  <a href="#ga3f36ee0c41000fd2b189406ddfc160f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad3d3c2d56b9ba8a228c82c097258b596">cl_page_in_use_noref</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller doesn't hold a refcount.  <a href="#gad3d3c2d56b9ba8a228c82c097258b596"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba">CPS_CACHED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9">CPS_OWNED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4">CPS_PAGEOUT</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998">CPS_PAGEIN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8">CPS_FREEING</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ae97a053a1e380f19d44c5c2f94e44f3c">CPS_NR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>States of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
 <a href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> { <a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936">CPT_CACHEABLE</a> =  1, 
<a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d">CPT_TRANSIENT</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> { <a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a58002573909284f81e9a573147c902f9">CRT_READ</a>, 
<a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e">CRT_WRITE</a>, 
<a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a521eb2b78ce2d57a85e84b1452597426">CRT_NR</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Requested transfer type. </p>
 <a href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5">CLP_GANG_OKAY</a> =  0, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1279507e1987988d99116da1f362faaa">CLP_GANG_RESCHED</a>, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca7a07cd260bc2685503d74371b7af3fa5">CLP_GANG_AGAIN</a>, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7">CLP_GANG_ABORT</a>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct page *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga643f9383053507790b9c5a43cdfdb5bf">cl_page_vmpage</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaec4e53fca3e674f91259ef8dfec297a1">__page_in_use</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page, int refc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is in use.  <a href="#gaec4e53fca3e674f91259ef8dfec297a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga448fbdaea940886c756e4a2d659982ba">cl_page_find</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> with index <em>idx</em> at the object <em>o</em>, and associated with the VM page <em>vmpage</em>.  <a href="#ga448fbdaea940886c756e4a2d659982ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga630af4228e1e42063ce55e844dfc8c30">cl_page_alloc</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *o, pgoff_t ind, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13">cl_page_get</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquires an additional reference to a page.  <a href="#gafc2fc785c3daf1db46bb250244dfde13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1">cl_page_put</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a reference to a page.  <a href="#ga1dc4205fd892e559c96ce97aad4eebf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2">cl_page_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>.  <a href="#ga8c8a48c83e51dbc9dd7a79933c1133d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab">cl_page_header_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>.  <a href="#ga410da950184d24fa1232acf2470c9bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed">cl_vmpage_page</a> (struct page *vmpage, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> associated with a VM page, and given <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>.  <a href="#gac3255abeeef8f9d9f3a4c80f553a75ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga5751d9274f61529ae1ec5a2b03b20db2">cl_page_top</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gab700fa091971e5f4dd53b2e7ec47334d">cl_page_at</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page, const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *dtype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa9cb2d06a33d48e9c15d7e311fb3c2be">cl_cache_init</a> (unsigned long lru_page_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cl_cache functions  <a href="#gaa9cb2d06a33d48e9c15d7e311fb3c2be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga81d50c8e80031f53132c1e66c54ee2c6">cl_cache_incref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase cl_cache refcount.  <a href="#ga81d50c8e80031f53132c1e66c54ee2c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaaabf78f7ae327b269ded9a824d9ccebf">cl_cache_decref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease cl_cache refcount and free the cache if refcount=0.  <a href="#gaaabf78f7ae327b269ded9a824d9ccebf"></a><br/></td></tr>
<tr><td colspan="2"><h2>ownership</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb46b517b77d347176f23adef739a8f39"></a>Functions dealing with the ownership of page by io. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a">cl_page_own</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Own a page, might be blocked.  <a href="#ga2f91322039a4254d13f6e0a668e5746a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7">cl_page_own_try</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nonblock version of <a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>.  <a href="#ga105c7ed0e326d75ffc75980986186bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4">cl_page_assume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume page ownership.  <a href="#ga77a2e8592e58cc9c514cb4ac38a9d2f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61">cl_page_unassume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership without unlocking the page.  <a href="#ga4e7db1845b76bea8277b4e3d2a482f61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb">cl_page_disown</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership.  <a href="#gae41a4c98faae723b2566a721b6e4b7fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf">cl_page_is_owned</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *pg, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true, iff page is owned by the given io.  <a href="#gabf5979233c47e0913f8d438d01051ebf"></a><br/></td></tr>
<tr><td colspan="2"><h2>transfer</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp84a0f3455dcca894ace136be62efa292"></a>Functions dealing with the preparation of a page for a transfer, and tracking transfer state. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8216a843e48aa6d45d049b6aacb13744">cl_page_prep</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares page for immediate transfer.  <a href="#ga8216a843e48aa6d45d049b6aacb13744"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga778ad6a1a849ef9701db714913c879ec">cl_page_completion</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers about transfer completion.  <a href="#ga778ad6a1a849ef9701db714913c879ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga864bcec4bff9dd1f988f928348c08796">cl_page_make_ready</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers that transfer formation engine decided to yank this page from the cache and to make it a part of a transfer.  <a href="#ga864bcec4bff9dd1f988f928348c08796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga9022b1fa30e82cf1e69bd534022ffb8f">cl_page_cache_add</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f">cl_page_clip</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int from, int to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells transfer engine that only part of a page is to be transmitted.  <a href="#ga2218cff8efc343a14d1c312f64e15e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2b98b954f28349bd90316fec9ebaec83">cl_page_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a page which is still in a transfer.  <a href="#ga2b98b954f28349bd90316fec9ebaec83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga0616bcd8605ed9a75e799f64bcdd5a2d">cl_page_flush</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called if a pge is being written back by kernel's intention.  <a href="#ga0616bcd8605ed9a75e799f64bcdd5a2d"></a><br/></td></tr>
<tr><td colspan="2"><h2>helper routines</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbc5b051d66841a94152b2b685d83a4c9"></a>Functions to discard, delete and export a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03">cl_page_discard</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when page is to be removed from the object, e.g., as a result of truncate.  <a href="#ga775efaa18bd22d404f7588fd35f6cd03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432">cl_page_delete</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a decision is made to throw page out of memory.  <a href="#ga55a51f6efaa6effc3b5b3d045d4ee432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3">cl_page_is_vmlocked</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, iff <em>pg</em> is VM locked in a suitable sense by the calling thread.  <a href="#gaff21e5139bb0af2f15e2cfb9cfb587f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafacf1187afd6e200c6f8d59539baf50c">cl_page_export</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int uptodate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks page up-to-date.  <a href="#gafacf1187afd6e200c6f8d59539baf50c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">loff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515">cl_offset</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a byte offset within object <em>obj</em> into a page index.  <a href="#gace31c47f7197adaedc4124bcddbca515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pgoff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4">cl_index</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, loff_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a page index into a byte offset within object <em>obj</em>.  <a href="#gaa04da32f8652bb1f20f7017d8ed387e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga43006a6bc8ca6f3de9ce4af48d944cc7">cl_page_size</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae62cdffcc2ad419c1efe15d3f7e2b7be">cl_lock_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>lock</em> to the <em>f</em>.  <a href="#gae62cdffcc2ad419c1efe15d3f7e2b7be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad2a636ba7685701e15adf1818874fd50">cl_lock_descr_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> *descr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of a lock description.  <a href="#gad2a636ba7685701e15adf1818874fd50"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga912e7c9c7d73f184c724593eb42f857a"></a><!-- doxytag: member="cl_object.h::CL_PAGE_DEBUG" ref="ga912e7c9c7d73f184c724593eb42f857a" args="(mask, env, page, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CL_PAGE_DEBUG</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">page, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                    \
        <span class="keywordflow">if</span> (<a class="code" href="libcfs__debug_8h.html#a7cb6b1ff959b11c833671412fd2df88c">cfs_cdebug_show</a>(mask, <a class="code" href="fid__handler_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>)) {                   \
                <a class="code" href="libcfs__debug_8h.html#ae8795a3168f0f1dfa49dfdad10e62e39">LIBCFS_DEBUG_MSG_DATA_DECL</a>(msgdata, mask, NULL);        \
                <a class="code" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2" title="Prints human readable representation of pg to the f.">cl_page_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>, page);  \
                <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(mask, format , ## __VA_ARGS__);                  \
        }                                                               \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Helper macro, dumping detailed information about <em>page</em> into a log. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01005">1005</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l03169">discard_cb()</a>, <a class="el" href="rw26_8c_source.html#l00730">ll_write_end()</a>, <a class="el" href="osc__page_8c_source.html#l00292">osc_page_delete()</a>, <a class="el" href="osc__object_8c_source.html#l00353">osc_req_attr_set()</a>, <a class="el" href="osc__io_8c_source.html#l00443">trunc_check_cb()</a>, and <a class="el" href="vvp__page_8c_source.html#l00322">vvp_page_make_ready()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeeca225390e016ad5bb7ab7ab31e3ab4"></a><!-- doxytag: member="cl_object.h::CL_PAGE_HEADER" ref="gaeeca225390e016ad5bb7ab7ab31e3ab4" args="(mask, env, page, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CL_PAGE_HEADER</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">page, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                          \
        <span class="keywordflow">if</span> (<a class="code" href="libcfs__debug_8h.html#a7cb6b1ff959b11c833671412fd2df88c">cfs_cdebug_show</a>(mask, <a class="code" href="fid__handler_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>)) {                         \
                <a class="code" href="libcfs__debug_8h.html#ae8795a3168f0f1dfa49dfdad10e62e39">LIBCFS_DEBUG_MSG_DATA_DECL</a>(msgdata, mask, NULL);              \
                <a class="code" href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab" title="Prints human readable representation of pg to the f.">cl_page_header_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>, page); \
                <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(mask, format , ## __VA_ARGS__);                        \
        }                                                                     \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Helper macro, dumping shorter information about <em>page</em> into a log. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01017">1017</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00995">cl_page_clip()</a>, <a class="el" href="cl__page_8c_source.html#l00909">cl_page_completion()</a>, <a class="el" href="cl__page_8c_source.html#l00973">cl_page_flush()</a>, <a class="el" href="cl__page_8c_source.html#l00943">cl_page_make_ready()</a>, <a class="el" href="cl__page_8c_source.html#l00866">cl_page_prep()</a>, <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>, <a class="el" href="cl__page_8c_source.html#l00281">cl_page_state_set0()</a>, <a class="el" href="rw26_8c_source.html#l00627">ll_write_begin()</a>, <a class="el" href="vvp__page_8c_source.html#l00254">vvp_page_completion_read()</a>, <a class="el" href="vvp__page_8c_source.html#l00283">vvp_page_completion_write()</a>, and <a class="el" href="vvp__page_8c_source.html#l00322">vvp_page_make_ready()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f36ee0c41000fd2b189406ddfc160f1"></a><!-- doxytag: member="cl_object.h::cl_page_in_use" ref="ga3f36ee0c41000fd2b189406ddfc160f1" args="(pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cl_page_in_use</td>
          <td>(</td>
          <td class="paramtype">pg&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__page_in_use(pg, 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Caller itself holds a refcount of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01046">1046</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="rw26_8c_source.html#l00128">ll_releasepage()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3d3c2d56b9ba8a228c82c097258b596"></a><!-- doxytag: member="cl_object.h::cl_page_in_use_noref" ref="gad3d3c2d56b9ba8a228c82c097258b596" args="(pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cl_page_in_use_noref</td>
          <td>(</td>
          <td class="paramtype">pg&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__page_in_use(pg, 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Caller doesn't hold a refcount. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01050">1050</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, and <a class="el" href="osc__page_8c_source.html#l00649">lru_page_busy()</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gadc29c2ff13d900c2f185ee95427fb06c"></a><!-- doxytag: member="cl_object.h::@4" ref="gadc29c2ff13d900c2f185ee95427fb06c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5"></a><!-- doxytag: member="CLP_GANG_OKAY" ref="ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5" args="" -->CLP_GANG_OKAY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadc29c2ff13d900c2f185ee95427fb06ca1279507e1987988d99116da1f362faaa"></a><!-- doxytag: member="CLP_GANG_RESCHED" ref="ggadc29c2ff13d900c2f185ee95427fb06ca1279507e1987988d99116da1f362faaa" args="" -->CLP_GANG_RESCHED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadc29c2ff13d900c2f185ee95427fb06ca7a07cd260bc2685503d74371b7af3fa5"></a><!-- doxytag: member="CLP_GANG_AGAIN" ref="ggadc29c2ff13d900c2f185ee95427fb06ca7a07cd260bc2685503d74371b7af3fa5" args="" -->CLP_GANG_AGAIN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7"></a><!-- doxytag: member="CLP_GANG_ABORT" ref="ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7" args="" -->CLP_GANG_ABORT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l02073">2073</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga762f808d1d3ac30a12a132d0344f1f39"></a><!-- doxytag: member="cl_object.h::cl_page_state" ref="ga762f808d1d3ac30a12a132d0344f1f39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>States of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<p><a class="el" href="cl__page_8c.html">cl_page.c</a> assumes particular order here.</p>
<p>The page state machine is rather crude, as it doesn't recognize finer page states like "dirty" or "up to date". This is because such states are not always well defined for the whole stack (see, for example, the implementation of the read-ahead, that hides page up-to-dateness to track cache hits accurately). Such sub-states are maintained by the layers that are interested in them. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba"></a><!-- doxytag: member="CPS_CACHED" ref="gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" args="" -->CPS_CACHED</em>&nbsp;</td><td>
<p>Page is in the cache, un-owned. </p>
<p>Page leaves cached state in the following cases:</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] io comes across the page and owns it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a>] page is dirty, the req-formation engine decides that it wants to include this page into an RPC being constructed, and yanks it from the cache;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>] VM callback is executed to evict the page form the memory;</li>
</ul>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd><a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9"></a><!-- doxytag: member="CPS_OWNED" ref="gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" args="" -->CPS_OWNED</em>&nbsp;</td><td>
<p>Page is exclusively owned by some <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>. </p>
<p>Page may end up in this state as a result of</p>
<ul>
<li>io creating new page and immediately owning it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] io finding existing cached page and owning it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] io finding existing owned page and waiting for owner to release the page;</li>
</ul>
<p>Page leaves owned state in the following cases:</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] io decides to leave the page in the cache, doing nothing;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998" title="Page is being read in, as a part of a transfer.">cl_page_state::CPS_PAGEIN</a>] io starts read transfer for this page;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a>] io starts immediate write transfer for this page;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>] io decides to destroy this page (e.g., as part of truncate or extent lock cancellation).</li>
</ul>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd><a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> != NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4"></a><!-- doxytag: member="CPS_PAGEOUT" ref="gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" args="" -->CPS_PAGEOUT</em>&nbsp;</td><td>
<p>Page is being written out, as a part of a transfer. </p>
<p>This state is entered when req-formation logic decided that it wants this page to be sent through the wire _now_. Specifically, it means that once this state is achieved, transfer completion handler (with either success or failure indication) is guaranteed to be executed against this page independently of any locks and any scheduling decisions made by the hosting environment (that effectively means that the page is never put into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state "in
 advance". This property is mentioned, because it is important when reasoning about possible dead-locks in the system). The page can enter this state as a result of</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] an io requesting an immediate write-out of this page, or</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] req-forming engine deciding that it has enough dirty pages cached to issue a "good" transfer.</li>
</ul>
<p>The page leaves <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state when the transfer is completed---it is moved into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a> state.</p>
<p>Underlying VM page is locked for the duration of transfer.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req != NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998"></a><!-- doxytag: member="CPS_PAGEIN" ref="gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998" args="" -->CPS_PAGEIN</em>&nbsp;</td><td>
<p>Page is being read in, as a part of a transfer. </p>
<p>This is quite similar to the <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state, except that read-in is always "immediate"---there is no such thing a sudden construction of read request from cached, presumably not up to date, pages.</p>
<p>Underlying VM page is locked for the duration of transfer.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req != NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8"></a><!-- doxytag: member="CPS_FREEING" ref="gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" args="" -->CPS_FREEING</em>&nbsp;</td><td>
<p>Page is being destroyed. </p>
<p>This state is entered when client decides that page has to be deleted from its host object, as, e.g., a part of truncate.</p>
<p>Once this state is reached, there is no way to escape it.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39ae97a053a1e380f19d44c5c2f94e44f3c"></a><!-- doxytag: member="CPS_NR" ref="gga762f808d1d3ac30a12a132d0344f1f39ae97a053a1e380f19d44c5c2f94e44f3c" args="" -->CPS_NR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00594">594</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga04ed60b0572c2fcfa6c2590aac97f92d"></a><!-- doxytag: member="cl_object.h::cl_page_type" ref="ga04ed60b0572c2fcfa6c2590aac97f92d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936"></a><!-- doxytag: member="CPT_CACHEABLE" ref="gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" args="" -->CPT_CACHEABLE</em>&nbsp;</td><td>
<p>Host page, the page is from the host inode which the <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> belongs to. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d"></a><!-- doxytag: member="CPT_TRANSIENT" ref="gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" args="" -->CPT_TRANSIENT</em>&nbsp;</td><td>
<p>Transient page, the transient <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is used to bind a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> to vmpage which is not belonging to the same object of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<p>it is used in DirectIO, lockless IO and liblustre. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00694">694</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga419215a2ca4eeab85983de8ca5a16a02"></a><!-- doxytag: member="cl_object.h::cl_req_type" ref="ga419215a2ca4eeab85983de8ca5a16a02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requested transfer type. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga419215a2ca4eeab85983de8ca5a16a02a58002573909284f81e9a573147c902f9"></a><!-- doxytag: member="CRT_READ" ref="gga419215a2ca4eeab85983de8ca5a16a02a58002573909284f81e9a573147c902f9" args="" -->CRT_READ</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e"></a><!-- doxytag: member="CRT_WRITE" ref="gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e" args="" -->CRT_WRITE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga419215a2ca4eeab85983de8ca5a16a02a521eb2b78ce2d57a85e84b1452597426"></a><!-- doxytag: member="CRT_NR" ref="gga419215a2ca4eeab85983de8ca5a16a02a521eb2b78ce2d57a85e84b1452597426" args="" -->CRT_NR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00786">786</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaec4e53fca3e674f91259ef8dfec297a1"></a><!-- doxytag: member="cl_object.h::__page_in_use" ref="gaec4e53fca3e674f91259ef8dfec297a1" args="(const struct cl_page *page, int refc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool __page_in_use </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is in use. </p>
<p>Client cache holds a refcount, this refcount will be dropped when the page is taken out of cache, see <a class="el" href="vvp__page_8c.html#afb02305a2c215477ae5520c9cf991531">vvp_page_delete()</a>. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01038">1038</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l00716">cp_ref</a>.</p>

</div>
</div>
<a class="anchor" id="gaaabf78f7ae327b269ded9a824d9ccebf"></a><!-- doxytag: member="cl_object.h::cl_cache_decref" ref="gaaabf78f7ae327b269ded9a824d9ccebf" args="(struct cl_client_cache *cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_cache_decref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease cl_cache refcount and free the cache if refcount=0. </p>
<p>Since llite, lov and osc all hold cl_cache refcount, the free will not cause race. (LU-6173) </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01136">1136</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02183">cl_client_cache::ccc_users</a>, and <a class="el" href="obd__support_8h_source.html#l00776">OBD_FREE</a>.</p>

<p>Referenced by <a class="el" href="llite__lib_8c_source.html#l00147">ll_free_sbi()</a>, <a class="el" href="lov__obd_8c_source.html#l00886">lov_cleanup()</a>, and <a class="el" href="osc__request_8c_source.html#l02874">osc_cleanup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga81d50c8e80031f53132c1e66c54ee2c6"></a><!-- doxytag: member="cl_object.h::cl_cache_incref" ref="ga81d50c8e80031f53132c1e66c54ee2c6" args="(struct cl_client_cache *cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_cache_incref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase cl_cache refcount. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01125">1125</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02183">cl_client_cache::ccc_users</a>.</p>

<p>Referenced by <a class="el" href="lov__obd_8c_source.html#l01304">lov_set_info_async()</a>, and <a class="el" href="osc__request_8c_source.html#l02422">osc_set_info_async()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9cb2d06a33d48e9c15d7e311fb3c2be"></a><!-- doxytag: member="cl_object.h::cl_cache_init" ref="gaa9cb2d06a33d48e9c15d7e311fb3c2be" args="(unsigned long lru_page_max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a>* cl_cache_init </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lru_page_max</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cl_cache functions </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01097">1097</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02195">cl_client_cache::ccc_lru</a>, <a class="el" href="cl__object_8h_source.html#l02191">cl_client_cache::ccc_lru_left</a>, <a class="el" href="cl__object_8h_source.html#l02203">cl_client_cache::ccc_lru_lock</a>, <a class="el" href="cl__object_8h_source.html#l02199">cl_client_cache::ccc_lru_max</a>, <a class="el" href="cl__object_8h_source.html#l02207">cl_client_cache::ccc_unstable_check</a>, <a class="el" href="cl__object_8h_source.html#l02211">cl_client_cache::ccc_unstable_nr</a>, <a class="el" href="cl__object_8h_source.html#l02216">cl_client_cache::ccc_unstable_waitq</a>, <a class="el" href="cl__object_8h_source.html#l02183">cl_client_cache::ccc_users</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="obd__support_8h_source.html#l00708">OBD_ALLOC</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="llite__lib_8c_source.html#l00071">ll_init_sbi()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa04da32f8652bb1f20f7017d8ed387e4"></a><!-- doxytag: member="cl_object.h::cl_index" ref="gaa04da32f8652bb1f20f7017d8ed387e4" args="(const struct cl_object *obj, loff_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pgoff_t cl_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a page index into a byte offset within object <em>obj</em>. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01059">1059</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l03131">check_and_discard_cb()</a>, <a class="el" href="echo__client_8c_source.html#l01197">cl_echo_enqueue0()</a>, <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="lov__io_8c_source.html#l00631">lov_io_read_ahead()</a>, <a class="el" href="lov__io_8c_source.html#l00085">lov_io_sub_inherit()</a>, <a class="el" href="lov__lock_8c_source.html#l00126">lov_lock_sub_init()</a>, <a class="el" href="lov__page_8c_source.html#l00069">lov_page_init_raid0()</a>, <a class="el" href="osc__lock_8c_source.html#l00429">osc_dlm_blocking_ast0()</a>, <a class="el" href="osc__io_8c_source.html#l00821">osc_io_fsync_end()</a>, <a class="el" href="osc__io_8c_source.html#l00781">osc_io_fsync_start()</a>, <a class="el" href="osc__io_8c_source.html#l00087">osc_io_read_ahead()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01128">osc_lock_set_writer()</a>, <a class="el" href="osc__lock_8c_source.html#l00658">osc_lock_weight()</a>, <a class="el" href="osc__io_8c_source.html#l00463">osc_trunc_check()</a>, <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>, <a class="el" href="vvp__io_8c_source.html#l00256">vvp_io_one_lock()</a>, <a class="el" href="vvp__io_8c_source.html#l00782">vvp_io_read_start()</a>, and <a class="el" href="vvp__io_8c_source.html#l00389">vvp_mmap_locks()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2a636ba7685701e15adf1818874fd50"></a><!-- doxytag: member="cl_object.h::cl_lock_descr_print" ref="gad2a636ba7685701e15adf1818874fd50" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_lock_descr *descr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lock_descr_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a>&nbsp;</td>
          <td class="paramname"> <em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> *&nbsp;</td>
          <td class="paramname"> <em>descr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints human readable representation of a lock description. </p>

<p>Definition at line <a class="el" href="cl__lock_8c_source.html#l00259">259</a> of file <a class="el" href="cl__lock_8c_source.html">cl_lock.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01163">cl_lock_descr::cld_obj</a>, <a class="el" href="cl__object_8h_source.html#l00227">cl_object::co_lu</a>, <a class="el" href="cl__object_8h_source.html#l01179">DDESCR</a>, <a class="el" href="lustre__user_8h_source.html#l00548">DFID</a>, <a class="el" href="lu__object_8h_source.html#l00770">lu_object_fid()</a>, <a class="el" href="cl__object_8h_source.html#l01180">PDESCR</a>, and <a class="el" href="lustre__user_8h_source.html#l00549">PFID</a>.</p>

<p>Referenced by <a class="el" href="cl__lock_8c_source.html#l00273">cl_lock_print()</a>.</p>

</div>
</div>
<a class="anchor" id="gae62cdffcc2ad419c1efe15d3f7e2b7be"></a><!-- doxytag: member="cl_object.h::cl_lock_print" ref="gae62cdffcc2ad419c1efe15d3f7e2b7be" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_lock_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a>&nbsp;</td>
          <td class="paramname"> <em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__lock.html">cl_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints human readable representation of <em>lock</em> to the <em>f</em>. </p>

<p>Definition at line <a class="el" href="cl__lock_8c_source.html#l00273">273</a> of file <a class="el" href="cl__lock_8c_source.html">cl_lock.c</a>.</p>

<p>References <a class="el" href="cl__lock_8c_source.html#l00259">cl_lock_descr_print()</a>, <a class="el" href="cl__object_8h_source.html#l01193">cl_lock::cll_descr</a>, <a class="el" href="cl__object_8h_source.html#l01191">cl_lock::cll_layers</a>, <a class="el" href="structcl__lock__operations.html#a0fddd0bb9b01d44087eec935c0a355ec">cl_lock_operations::clo_print</a>, <a class="el" href="cl__object_8h_source.html#l01208">cl_lock_slice::cls_linkage</a>, <a class="el" href="cl__object_8h_source.html#l01205">cl_lock_slice::cls_obj</a>, <a class="el" href="cl__object_8h_source.html#l01206">cl_lock_slice::cls_ops</a>, <a class="el" href="cl__object_8h_source.html#l00227">cl_object::co_lu</a>, <a class="el" href="lu__object_8h_source.html#l00275">lu_device::ld_type</a>, <a class="el" href="lu__object_8h_source.html#l00324">lu_device_type::ldt_name</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, and <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>.</p>

<p>Referenced by <a class="el" href="lov__lock_8c_source.html#l00297">lov_lock_print()</a>.</p>

</div>
</div>
<a class="anchor" id="gace31c47f7197adaedc4124bcddbca515"></a><!-- doxytag: member="cl_object.h::cl_offset" ref="gace31c47f7197adaedc4124bcddbca515" args="(const struct cl_object *obj, pgoff_t idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">loff_t cl_offset </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a byte offset within object <em>obj</em> into a page index. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01050">1050</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="rw26_8c_source.html#l00596">ll_prepare_partial_page()</a>, <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>, <a class="el" href="lov__io_8c_source.html#l00631">lov_io_read_ahead()</a>, <a class="el" href="lov__io_8c_source.html#l00326">lov_io_slice_init()</a>, <a class="el" href="lov__io_8c_source.html#l00085">lov_io_sub_inherit()</a>, <a class="el" href="lov__lock_8c_source.html#l00126">lov_lock_sub_init()</a>, <a class="el" href="lov__page_8c_source.html#l00069">lov_page_init_raid0()</a>, <a class="el" href="osc__cache_8c_source.html#l00182">osc_extent_sanity_check0()</a>, <a class="el" href="osc__page_8c_source.html#l00222">osc_index2policy()</a>, <a class="el" href="osc__page_8c_source.html#l00380">osc_page_init()</a>, <a class="el" href="osc__io_8c_source.html#l00228">osc_page_touch_at()</a>, <a class="el" href="osc__cache_8c_source.html#l01277">osc_refresh_count()</a>, <a class="el" href="osc__io_8c_source.html#l00463">osc_trunc_check()</a>, and <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga630af4228e1e42063ce55e844dfc8c30"></a><!-- doxytag: member="cl_object.h::cl_page_alloc" ref="ga630af4228e1e42063ce55e844dfc8c30" args="(const struct lu_env *env, struct cl_object *o, pgoff_t ind, struct page *vmpage, enum cl_page_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page.html">cl_page</a>* cl_page_alloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct page *&nbsp;</td>
          <td class="paramname"> <em>vmpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00172">172</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8c_source.html#l00134">cl_object_get()</a>, <a class="el" href="cl__object_8h_source.html#l01982">cl_object_header()</a>, <a class="el" href="cl__page_8c_source.html#l00747">cl_page_delete0()</a>, <a class="el" href="cl__page_8c_source.html#l00133">cl_page_free()</a>, <a class="el" href="cl__page_8c_source.html#l00165">cl_page_state_set_trust()</a>, <a class="el" href="cl__object_8h_source.html#l00227">cl_object::co_lu</a>, <a class="el" href="cl__object_8h_source.html#l00229">cl_object::co_ops</a>, <a class="el" href="structcl__object__operations.html#a86e603bbbf4c6b1625b8dece6cbb5f32">cl_object_operations::coo_page_init</a>, <a class="el" href="cl__object_8h_source.html#l00724">cp_batch</a>, <a class="el" href="cl__object_8h_source.html#l00726">cp_layers</a>, <a class="el" href="cl__object_8h_source.html#l00720">cp_obj</a>, <a class="el" href="cl__object_8h_source.html#l00746">cp_obj_ref</a>, <a class="el" href="cl__object_8h_source.html#l00716">cp_ref</a>, <a class="el" href="cl__object_8h_source.html#l00744">cp_reference</a>, <a class="el" href="cl__object_8h_source.html#l00736">cp_type</a>, <a class="el" href="cl__object_8h_source.html#l00722">cp_vmpage</a>, <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>, <a class="el" href="cl__page_8c_source.html#l00091">CS_PAGE_INC</a>, <a class="el" href="cl__page_8c_source.html#l00094">CS_PAGESTATE_DEC</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="writemany_8c_source.html#l00074">head</a>, <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="lu__object_8h_source.html#l00468">lu_object::lo_header</a>, <a class="el" href="lu__object_8h_source.html#l00552">lu_object_header::loh_layers</a>, <a class="el" href="lu__object_8h_source.html#l00873">lu_object_ref_add_at()</a>, <a class="el" href="lu__ref_8h_source.html#l00196">lu_ref_init()</a>, <a class="el" href="obd__support_8h_source.html#l00705">OBD_ALLOC_GFP</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00231">cl_page_find()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77a2e8592e58cc9c514cb4ac38a9d2f4"></a><!-- doxytag: member="cl_object.h::cl_page_assume" ref="ga77a2e8592e58cc9c514cb4ac38a9d2f4" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_assume </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assume page ownership. </p>
<p>Called when page is already locked by the hosting VM.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85" title="Called for a page that is already &quot;owned&quot; by io from VM point of view.">cl_page_operations::cpo_assume()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00652">652</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01752">cl_io::ci_obj</a>, <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__object_8h_source.html#l02042">cl_object_same()</a>, <a class="el" href="cl__page_8c_source.html#l00496">cl_page_invoid()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="cl__page_8c_source.html#l00519">cl_page_owner_set()</a>, <a class="el" href="cl__page_8c_source.html#l00341">cl_page_state_set()</a>, <a class="el" href="cl__object_8h_source.html#l00720">cp_obj</a>, <a class="el" href="cl__object_8h_source.html#l00742">cp_owner</a>, <a class="el" href="cl__object_8h_source.html#l00640">CPS_OWNED</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="cl__page_8c_source.html#l00063">PASSERT</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01038">cl_page_list_assume()</a>, <a class="el" href="rw_8c_source.html#l00178">ll_read_ahead_page()</a>, <a class="el" href="rw_8c_source.html#l01136">ll_readpage()</a>, <a class="el" href="rw26_8c_source.html#l00627">ll_write_begin()</a>, <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>, and <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>.</p>

</div>
</div>
<a class="anchor" id="gab700fa091971e5f4dd53b2e7ec47334d"></a><!-- doxytag: member="cl_object.h::cl_page_at" ref="gab700fa091971e5f4dd53b2e7ec47334d" args="(const struct cl_page *page, const struct lu_device_type *dtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a>* cl_page_at </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *&nbsp;</td>
          <td class="paramname"> <em>dtype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00420">420</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00120">cl_page_at_trusted()</a>.</p>

<p>Referenced by <a class="el" href="lov__io_8c_source.html#l00269">lov_page_stripe()</a>, and <a class="el" href="vvp__dev_8c_source.html#l00508">vvp_pgcache_page_show()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9022b1fa30e82cf1e69bd534022ffb8f"></a><!-- doxytag: member="cl_object.h::cl_page_cache_add" ref="ga9022b1fa30e82cf1e69bd534022ffb8f" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg, enum cl_req_type crt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_cache_add </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2b98b954f28349bd90316fec9ebaec83"></a><!-- doxytag: member="cl_object.h::cl_page_cancel" ref="ga2b98b954f28349bd90316fec9ebaec83" args="(const struct lu_env *env, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_cancel </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel a page which is still in a transfer. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01040">1040</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00429">CL_PAGE_INVOKE</a>, and <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00744">cl_io_cancel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2218cff8efc343a14d1c312f64e15e1f"></a><!-- doxytag: member="cl_object.h::cl_page_clip" ref="ga2218cff8efc343a14d1c312f64e15e1f" args="(const struct lu_env *env, struct cl_page *pg, int from, int to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_clip </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells transfer engine that only part of a page is to be transmitted. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#aece03986dfa3b574ef3cc06ce36a830b" title="Tell transfer engine that only [to, from] part of a page should be transmitted.">cl_page_operations::cpo_clip()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00995">995</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00452">CL_PAGE_INVOID</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="osc__io_8c_source.html#l00265">osc_io_commit_async()</a>, and <a class="el" href="vvp__io_8c_source.html#l00870">vvp_io_commit_sync()</a>.</p>

</div>
</div>
<a class="anchor" id="ga778ad6a1a849ef9701db714913c879ec"></a><!-- doxytag: member="cl_object.h::cl_page_completion" ref="ga778ad6a1a849ef9701db714913c879ec" args="(const struct lu_env *env, struct cl_page *pg, enum cl_req_type crt, int ioret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_completion </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ioret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify layers about transfer completion. </p>
<p>Invoked by transfer sub-system (which is a part of osc) to notify layers that a transfer, of which this page is a part of has completed.</p>
<p>Completion call-backs are executed in the bottom-up order, so that uppermost layer (llite), responsible for the VFS/VM interaction runs last and can release locks safely.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>pg-&gt;cp_state == CPS_PAGEIN || pg-&gt;cp_state == CPS_PAGEOUT </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_CACHED</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a10efe3c32edb23a4fb1f6b1af177bf95" title="Completion handler.">cl_page_operations::cpo_completion()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00909">909</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00467">CL_PAGE_INVOID_REVERSE</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="cl__page_8c_source.html#l00341">cl_page_state_set()</a>, <a class="el" href="cl__page_8c_source.html#l00841">cl_req_type_state()</a>, <a class="el" href="cl__io_8c_source.html#l01258">cl_sync_io_note()</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00750">cp_sync_io</a>, <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>, <a class="el" href="cl__object_8h_source.html#l00789">CRT_NR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, and <a class="el" href="cl__page_8c_source.html#l00063">PASSERT</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l01309">osc_completion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55a51f6efaa6effc3b5b3d045d4ee432"></a><!-- doxytag: member="cl_object.h::cl_page_delete" ref="ga55a51f6efaa6effc3b5b3d045d4ee432" args="(const struct lu_env *env, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_delete </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when a decision is made to throw page out of memory. </p>
<p>Notifies all layers about page destruction by calling <a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013" title="Called when page is removed from the cache, and is about to being destroyed.">cl_page_operations::cpo_delete()</a> method top-to-bottom.</p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state (this is the only place where transition to this state happens).</p>
<p>Eliminates all venues through which new references to the page can be obtained:</p>
<ul>
<li>removes page from the radix trees,</li>
</ul>
<ul>
<li>breaks linkage from VM page to <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.</li>
</ul>
<p>Once page reaches <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>, all remaining references will drain after some time, at which point page will be recycled.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>VM page is locked </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_FREEING</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013" title="Called when page is removed from the cache, and is about to being destroyed.">cl_page_operations::cpo_delete()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00790">790</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00747">cl_page_delete0()</a>, <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="osc__page_8c_source.html#l00624">discard_pagevec()</a>, <a class="el" href="echo__client_8c_source.html#l00307">echo_page_discard()</a>, <a class="el" href="rw26_8c_source.html#l00078">ll_invalidatepage()</a>, <a class="el" href="rw26_8c_source.html#l00128">ll_releasepage()</a>, and <a class="el" href="vvp__page_8c_source.html#l00451">vvp_transient_page_discard()</a>.</p>

</div>
</div>
<a class="anchor" id="ga775efaa18bd22d404f7588fd35f6cd03"></a><!-- doxytag: member="cl_object.h::cl_page_discard" ref="ga775efaa18bd22d404f7588fd35f6cd03" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_discard </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when page is to be removed from the object, e.g., as a result of truncate. </p>
<p>Calls <a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845" title="Page destruction.">cl_page_operations::cpo_discard()</a> top-to-bottom.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845" title="Page destruction.">cl_page_operations::cpo_discard()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00732">732</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00496">cl_page_invoid()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l03131">check_and_discard_cb()</a>, <a class="el" href="cl__io_8c_source.html#l01052">cl_page_list_discard()</a>, <a class="el" href="osc__cache_8c_source.html#l03169">discard_cb()</a>, <a class="el" href="osc__page_8c_source.html#l00624">discard_pagevec()</a>, <a class="el" href="osc__cache_8c_source.html#l00961">osc_extent_truncate()</a>, <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>, and <a class="el" href="vvp__io_8c_source.html#l00968">vvp_io_write_commit()</a>.</p>

</div>
</div>
<a class="anchor" id="gae41a4c98faae723b2566a721b6e4b7fb"></a><!-- doxytag: member="cl_object.h::cl_page_disown" ref="gae41a4c98faae723b2566a721b6e4b7fb" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_disown </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases page ownership. </p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>!cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a> </dd>
<dd>
<a class="el" href="structcl__page__operations.html#a4d11c1fa2d9422c18786f613c9221138" title="Called when ownership it yielded.">cl_page_operations::cpo_disown()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00709">709</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__page_8c_source.html#l00527">cl_page_disown0()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00690">CPS_FREEING</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l03131">check_and_discard_cb()</a>, <a class="el" href="osc__cache_8c_source.html#l03169">discard_cb()</a>, <a class="el" href="osc__page_8c_source.html#l00624">discard_pagevec()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="rw_8c_source.html#l01077">ll_io_read_page()</a>, <a class="el" href="rw26_8c_source.html#l00730">ll_write_end()</a>, <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>, <a class="el" href="osc__cache_8c_source.html#l00961">osc_extent_truncate()</a>, <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>, <a class="el" href="vvp__io_8c_source.html#l00870">vvp_io_commit_sync()</a>, <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>, <a class="el" href="vvp__io_8c_source.html#l00968">vvp_io_write_commit()</a>, and <a class="el" href="vvp__io_8c_source.html#l00928">write_commit_callback()</a>.</p>

</div>
</div>
<a class="anchor" id="gafacf1187afd6e200c6f8d59539baf50c"></a><!-- doxytag: member="cl_object.h::cl_page_export" ref="gafacf1187afd6e200c6f8d59539baf50c" args="(const struct lu_env *env, struct cl_page *pg, int uptodate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_export </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uptodate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks page up-to-date. </p>
<p>Call <a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197" title="Announces whether the page contains valid data or not by uptodate.">cl_page_operations::cpo_export()</a> through all layers top-to-bottom. The layer responsible for VM interaction has to mark/clear page as up-to-date by the <em>uptodate</em> argument.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197" title="Announces whether the page contains valid data or not by uptodate.">cl_page_operations::cpo_export()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00808">808</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00452">CL_PAGE_INVOID</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="rw_8c_source.html#l01077">ll_io_read_page()</a>, <a class="el" href="lov__page_8c_source.html#l00126">lov_page_init_empty()</a>, and <a class="el" href="vvp__page_8c_source.html#l00254">vvp_page_completion_read()</a>.</p>

</div>
</div>
<a class="anchor" id="ga448fbdaea940886c756e4a2d659982ba"></a><!-- doxytag: member="cl_object.h::cl_page_find" ref="ga448fbdaea940886c756e4a2d659982ba" args="(const struct lu_env *env, struct cl_object *obj, pgoff_t idx, struct page *vmpage, enum cl_page_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page.html">cl_page</a>* cl_page_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct page *&nbsp;</td>
          <td class="paramname"> <em>vmpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> with index <em>idx</em> at the object <em>o</em>, and associated with the VM page <em>vmpage</em>. </p>
<p>This is the main entry point into the <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> caching interface. First, a cache (implemented as a per-object radix tree) is consulted. If page is found there, it is returned immediately. Otherwise new page is allocated and returned. In any case, additional reference to page is acquired.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid.">cl_object_find()</a>, cl_lock_find() </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00231">231</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="cl__object_8h_source.html#l01982">cl_object_header()</a>, <a class="el" href="cl__page_8c_source.html#l00172">cl_page_alloc()</a>, <a class="el" href="cl__page_8c_source.html#l00398">cl_vmpage_page()</a>, <a class="el" href="cl__object_8h_source.html#l00421">cl_object_header::coh_lu</a>, <a class="el" href="cl__object_8h_source.html#l00697">CPT_CACHEABLE</a>, <a class="el" href="cl__object_8h_source.html#l00702">CPT_TRANSIENT</a>, <a class="el" href="cl__page_8c_source.html#l00091">CS_PAGE_INC</a>, <a class="el" href="libcfs__debug_8h_source.html#l00144">D_PAGE</a>, <a class="el" href="lustre__user_8h_source.html#l00548">DFID</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="libcfs__private_8h_source.html#l00284">KLASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lu__object_8h_source.html#l00525">lu_object_header::loh_fid</a>, <a class="el" href="iam__ut_8c_source.html#l00142">lookup()</a>, <a class="el" href="lustre__user_8h_source.html#l00549">PFID</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="rw_8c_source.html#l00178">ll_read_ahead_page()</a>, <a class="el" href="rw_8c_source.html#l01136">ll_readpage()</a>, <a class="el" href="rw26_8c_source.html#l00627">ll_write_begin()</a>, <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>, and <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0616bcd8605ed9a75e799f64bcdd5a2d"></a><!-- doxytag: member="cl_object.h::cl_page_flush" ref="ga0616bcd8605ed9a75e799f64bcdd5a2d" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_flush </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called if a pge is being written back by kernel's intention. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ergo(result == 0, pg-&gt;cp_state == CPS_PAGEOUT)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a0056ad7a02f61f50cfa8dc6362b1be44" title="Write out a page by kernel.">cl_page_operations::cpo_flush()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00973">973</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00484">cl_page_invoke()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc2fc785c3daf1db46bb250244dfde13"></a><!-- doxytag: member="cl_object.h::cl_page_get" ref="gafc2fc785c3daf1db46bb250244dfde13" args="(struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquires an additional reference to a page. </p>
<p>This can be called only by caller already possessing a reference to <em>page</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get()</a>, cl_lock_get(). </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00355">355</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00107">cl_page_get_trust()</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, and <a class="el" href="flock_8c_source.html#l00090">EXIT</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, <a class="el" href="osc__cache_8c_source.html#l00961">osc_extent_truncate()</a>, <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>, and <a class="el" href="osc__page_8c_source.html#l00166">osc_page_transfer_get()</a>.</p>

</div>
</div>
<a class="anchor" id="ga410da950184d24fa1232acf2470c9bab"></a><!-- doxytag: member="cl_object.h::cl_page_header_print" ref="ga410da950184d24fa1232acf2470c9bab" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_header_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a>&nbsp;</td>
          <td class="paramname"> <em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints human readable representation of <em>pg</em> to the <em>f</em>. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01011">1011</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l00720">cp_obj</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l01025">cl_page_print()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf5979233c47e0913f8d438d01051ebf"></a><!-- doxytag: member="cl_object.h::cl_page_is_owned" ref="gabf5979233c47e0913f8d438d01051ebf" args="(const struct cl_page *pg, const struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_is_owned </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns true, iff page is owned by the given io. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00555">555</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01752">cl_io::ci_obj</a>, <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__object_8h_source.html#l02042">cl_object_same()</a>, <a class="el" href="cl__object_8h_source.html#l00720">cp_obj</a>, <a class="el" href="cl__object_8h_source.html#l00742">cp_owner</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00640">CPS_OWNED</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="libcfs__private_8h_source.html#l00282">LINVRNT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00732">cl_page_discard()</a>, <a class="el" href="cl__page_8c_source.html#l00709">cl_page_disown()</a>, <a class="el" href="cl__page_8c_source.html#l00973">cl_page_flush()</a>, <a class="el" href="cl__page_8c_source.html#l00584">cl_page_own0()</a>, <a class="el" href="cl__page_8c_source.html#l00866">cl_page_prep()</a>, <a class="el" href="cl__page_8c_source.html#l00680">cl_page_unassume()</a>, <a class="el" href="osc__page_8c_source.html#l00624">discard_pagevec()</a>, <a class="el" href="rw_8c_source.html#l01176">ll_page_sync_io()</a>, <a class="el" href="rw26_8c_source.html#l00730">ll_write_end()</a>, and <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>.</p>

</div>
</div>
<a class="anchor" id="gaff21e5139bb0af2f15e2cfb9cfb587f3"></a><!-- doxytag: member="cl_object.h::cl_page_is_vmlocked" ref="gaff21e5139bb0af2f15e2cfb9cfb587f3" args="(const struct lu_env *env, const struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_is_vmlocked </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true, iff <em>pg</em> is VM locked in a suitable sense by the calling thread. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00821">821</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l00726">cp_layers</a>, <a class="el" href="cl__object_8h_source.html#l00768">cl_page_slice::cpl_linkage</a>, <a class="el" href="cl__object_8h_source.html#l00766">cl_page_slice::cpl_ops</a>, <a class="el" href="structcl__page__operations.html#a25940fbc8d8db64c799404461f38dbaa">cl_page_operations::cpo_is_vmlocked</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00043">list_head::next</a>, <a class="el" href="cl__page_8c_source.html#l00063">PASSERT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, and <a class="el" href="osc__lock_8c_source.html#l00644">weigh_cb()</a>.</p>

</div>
</div>
<a class="anchor" id="ga864bcec4bff9dd1f988f928348c08796"></a><!-- doxytag: member="cl_object.h::cl_page_make_ready" ref="ga864bcec4bff9dd1f988f928348c08796" args="(const struct lu_env *env, struct cl_page *pg, enum cl_req_type crt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_make_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify layers that transfer formation engine decided to yank this page from the cache and to make it a part of a transfer. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>pg-&gt;cp_state == CPS_CACHED </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_PAGEIN || pg-&gt;cp_state == CPS_PAGEOUT</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea" title="Called when cached page is about to be added to the ptlrpc request as a part of req...">cl_page_operations::cpo_make_ready()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00943">943</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00429">CL_PAGE_INVOKE</a>, <a class="el" href="cl__page_8c_source.html#l00847">cl_page_io_start()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>, <a class="el" href="cl__object_8h_source.html#l00789">CRT_NR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="cl__page_8c_source.html#l00063">PASSERT</a>, <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l01261">osc_make_ready()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f91322039a4254d13f6e0a668e5746a"></a><!-- doxytag: member="cl_object.h::cl_page_own" ref="ga2f91322039a4254d13f6e0a668e5746a" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_own </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Own a page, might be blocked. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl__page_8c.html#afbd407e4b4f21711065f684d303743bd" title="Try to own a page by IO.">cl_page_own0()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00623">623</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00584">cl_page_own0()</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l03131">check_and_discard_cb()</a>, <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="cl__io_8c_source.html#l01015">cl_page_list_own()</a>, <a class="el" href="osc__cache_8c_source.html#l03169">discard_cb()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, and <a class="el" href="osc__cache_8c_source.html#l00961">osc_extent_truncate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga105c7ed0e326d75ffc75980986186bb7"></a><!-- doxytag: member="cl_object.h::cl_page_own_try" ref="ga105c7ed0e326d75ffc75980986186bb7" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_own_try </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nonblock version of <a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl__page_8c.html#afbd407e4b4f21711065f684d303743bd" title="Try to own a page by IO.">cl_page_own0()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00634">634</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00584">cl_page_own0()</a>.</p>

<p>Referenced by <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8216a843e48aa6d45d049b6aacb13744"></a><!-- doxytag: member="cl_object.h::cl_page_prep" ref="ga8216a843e48aa6d45d049b6aacb13744" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg, enum cl_req_type crt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_prep </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares page for immediate transfer. </p>
<p><a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492" title="Called when a page is submitted for a transfer as a part of cl_page_list.">cl_page_operations::cpo_prep()</a> is called top-to-bottom. Every layer either agrees to submit this page (by returning 0), or requests to omit this page (by returning -EALREADY). Layer handling interactions with the VM also has to inform VM that page is under transfer now. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00866">866</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00484">cl_page_invoke()</a>, <a class="el" href="cl__page_8c_source.html#l00847">cl_page_io_start()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="cl__object_8h_source.html#l01026">cl_page_vmpage()</a>, <a class="el" href="cl__object_8h_source.html#l00736">cp_type</a>, <a class="el" href="cl__object_8h_source.html#l00697">CPT_CACHEABLE</a>, <a class="el" href="cl__object_8h_source.html#l00789">CRT_NR</a>, <a class="el" href="cl__object_8h_source.html#l00788">CRT_WRITE</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, <a class="el" href="osd__iam_8h_source.html#l00059">equi</a>, <a class="el" href="osd__iam_8h_source.html#l00057">ergo</a>, <a class="el" href="libcfs__private_8h_source.html#l00284">KLASSERT</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="osc__io_8c_source.html#l00124">osc_io_submit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c8a48c83e51dbc9dd7a79933c1133d2"></a><!-- doxytag: member="cl_object.h::cl_page_print" ref="ga8c8a48c83e51dbc9dd7a79933c1133d2" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a>&nbsp;</td>
          <td class="paramname"> <em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints human readable representation of <em>pg</em> to the <em>f</em>. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01025">1025</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l01011">cl_page_header_print()</a>, <a class="el" href="cl__page_8c_source.html#l00429">CL_PAGE_INVOKE</a>, and <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>.</p>

</div>
</div>
<a class="anchor" id="ga1dc4205fd892e559c96ce97aad4eebf1"></a><!-- doxytag: member="cl_object.h::cl_page_put" ref="ga1dc4205fd892e559c96ce97aad4eebf1" args="(const struct lu_env *env, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_put </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a reference to a page. </p>
<p>When last reference is released, page is returned to the cache, unless it is in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state, in which case it is immediately destroyed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put()</a>, cl_lock_put(). </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00372">372</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00133">cl_page_free()</a>, <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__object_8h_source.html#l00724">cp_batch</a>, <a class="el" href="cl__object_8h_source.html#l00742">cp_owner</a>, <a class="el" href="cl__object_8h_source.html#l00716">cp_ref</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00690">CPS_FREEING</a>, <a class="el" href="libcfs__debug_8h_source.html#l00129">D_TRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, and <a class="el" href="cl__page_8c_source.html#l00063">PASSERT</a>.</p>

<p>Referenced by <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, <a class="el" href="cl__io_8c_source.html#l00963">cl_page_list_disown()</a>, <a class="el" href="osc__page_8c_source.html#l00624">discard_pagevec()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="rw26_8c_source.html#l00078">ll_invalidatepage()</a>, <a class="el" href="rw_8c_source.html#l00178">ll_read_ahead_page()</a>, <a class="el" href="rw_8c_source.html#l01136">ll_readpage()</a>, <a class="el" href="rw26_8c_source.html#l00128">ll_releasepage()</a>, <a class="el" href="rw26_8c_source.html#l00730">ll_write_end()</a>, <a class="el" href="rw_8c_source.html#l00887">ll_writepage()</a>, <a class="el" href="osc__cache_8c_source.html#l01309">osc_completion()</a>, <a class="el" href="osc__cache_8c_source.html#l00961">osc_extent_truncate()</a>, <a class="el" href="osc__page_8c_source.html#l00176">osc_page_transfer_put()</a>, <a class="el" href="vvp__io_8c_source.html#l00870">vvp_io_commit_sync()</a>, <a class="el" href="vvp__io_8c_source.html#l00361">vvp_io_fault_fini()</a>, <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>, <a class="el" href="vvp__io_8c_source.html#l00968">vvp_io_write_commit()</a>, <a class="el" href="vvp__dev_8c_source.html#l00537">vvp_pgcache_show()</a>, and <a class="el" href="vvp__io_8c_source.html#l00928">write_commit_callback()</a>.</p>

</div>
</div>
<a class="anchor" id="ga43006a6bc8ca6f3de9ce4af48d944cc7"></a><!-- doxytag: member="cl_object.h::cl_page_size" ref="ga43006a6bc8ca6f3de9ce4af48d944cc7" args="(const struct cl_object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cl_page_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01065">1065</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="echo__client_8c_source.html#l01286">cl_echo_object_brw()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="rw26_8c_source.html#l00596">ll_prepare_partial_page()</a>, <a class="el" href="lov__page_8c_source.html#l00126">lov_page_init_empty()</a>, and <a class="el" href="vvp__io_8c_source.html#l01202">vvp_io_fault_start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5751d9274f61529ae1ec5a2b03b20db2"></a><!-- doxytag: member="cl_object.h::cl_page_top" ref="ga5751d9274f61529ae1ec5a2b03b20db2" args="(struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page.html">cl_page</a>* cl_page_top </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4e7db1845b76bea8277b4e3d2a482f61"></a><!-- doxytag: member="cl_object.h::cl_page_unassume" ref="ga4e7db1845b76bea8277b4e3d2a482f61" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_unassume </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases page ownership without unlocking the page. </p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a> without releasing a lock on the underlying VM page (as VM is supposed to do this itself).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>!cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4" title="Assume page ownership.">cl_page_assume()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00680">680</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__page_8c_source.html#l00276">cl_page_invariant()</a>, <a class="el" href="cl__page_8c_source.html#l00467">CL_PAGE_INVOID_REVERSE</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__page_8c_source.html#l00427">CL_PAGE_OP</a>, <a class="el" href="cl__page_8c_source.html#l00508">cl_page_owner_clear()</a>, <a class="el" href="cl__page_8c_source.html#l00341">cl_page_state_set()</a>, <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, and <a class="el" href="cl__page_8c_source.html#l00076">PINVRNT</a>.</p>

<p>Referenced by <a class="el" href="rw_8c_source.html#l00178">ll_read_ahead_page()</a>, and <a class="el" href="rw26_8c_source.html#l00627">ll_write_begin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga643f9383053507790b9c5a43cdfdb5bf"></a><!-- doxytag: member="cl_object.h::cl_page_vmpage" ref="ga643f9383053507790b9c5a43cdfdb5bf" args="(const struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct page* cl_page_vmpage </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01026">1026</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l00722">cp_vmpage</a>, and <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00866">cl_page_prep()</a>, <a class="el" href="osc__cache_8c_source.html#l03169">discard_cb()</a>, <a class="el" href="rw26_8c_source.html#l00189">ll_direct_rw_pages()</a>, <a class="el" href="osc__page_8c_source.html#l00649">lru_page_busy()</a>, <a class="el" href="vvp__io_8c_source.html#l00870">vvp_io_commit_sync()</a>, and <a class="el" href="vvp__io_8c_source.html#l00968">vvp_io_write_commit()</a>.</p>

</div>
</div>
<a class="anchor" id="gac3255abeeef8f9d9f3a4c80f553a75ed"></a><!-- doxytag: member="cl_object.h::cl_vmpage_page" ref="gac3255abeeef8f9d9f3a4c80f553a75ed" args="(struct page *vmpage, struct cl_object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page.html">cl_page</a>* cl_vmpage_page </td>
          <td>(</td>
          <td class="paramtype">struct page *&nbsp;</td>
          <td class="paramname"> <em>vmpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> associated with a VM page, and given <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00398">398</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00107">cl_page_get_trust()</a>, <a class="el" href="cl__object_8h_source.html#l00736">cp_type</a>, <a class="el" href="cl__object_8h_source.html#l00697">CPT_CACHEABLE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="libcfs__private_8h_source.html#l00284">KLASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00231">cl_page_find()</a>, <a class="el" href="rw26_8c_source.html#l00078">ll_invalidatepage()</a>, <a class="el" href="rw26_8c_source.html#l00128">ll_releasepage()</a>, and <a class="el" href="vvp__dev_8c_source.html#l00537">vvp_pgcache_show()</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:51 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
