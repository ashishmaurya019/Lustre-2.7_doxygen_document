<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/client.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/ptlrpc/client.c File Reference</h1><code>#include &lt;<a class="el" href="obd__support_8h_source.html">obd_support.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="obd__class_8h_source.html">obd_class.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__ha_8h_source.html">lustre_ha.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__import_8h_source.html">lustre_import.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__req__layout_8h_source.html">lustre_req_layout.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="ptlrpc__internal_8h_source.html">ptlrpc_internal.h</a>&quot;</code><br/>

<p><a href="client_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__work__async__args.html">ptlrpc_work_async_args</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for operating ptlrpc workers.  <a href="structptlrpc__work__async__args.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>&nbsp;&nbsp;&nbsp;S_RPC</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of client-side PortalRPC interfaces.  <a href="#abda60744d497fcfe370cfd6b2d65c7ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a90fa0703e95d68f79e54a4db5f6ed8f7">YEAR_2004</a>&nbsp;&nbsp;&nbsp;(1ULL &lt;&lt; 30)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the XID for the node.  <a href="#a90fa0703e95d68f79e54a4db5f6ed8f7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#af8657be69f4248389a7d148f254ee45d">ptlrpc_send_new_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to send request <em>req</em> over the <a class="el" href="structnetwork.html">network</a> for the first time Also adjusts request phase.  <a href="#af8657be69f4248389a7d148f254ee45d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a4f65c1f73ee8212ca6a16e1eac64ac08">ptlrpcd_check_work</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a9e6cdd967c36c6d238e9943e6d205c79">ptlrpc_unregister_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, int async)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disengage the client's reply buffer from the <a class="el" href="structnetwork.html">network</a> NB does _NOT_ unregister any client-side bulk.  <a href="#a9e6cdd967c36c6d238e9943e6d205c79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778">ptlrpc_init_client</a> (int req_portal, int rep_portal, char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, struct <a class="el" href="structptlrpc__client.html">ptlrpc_client</a> *cl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize passed in client structure <em>cl</em>.  <a href="group__net.html#ga8274d1c6229aa8679c30551cc4768778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac16251a340153c3059c8727b8b39d400">ptlrpc_uuid_to_connection</a> (struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *<a class="el" href="llog__test_8c.html#aaa83f069991aa91e0383af81ef30f13f">uuid</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return PortalRPC connection for remore uud <em>uuid</em>.  <a href="group__net.html#gac16251a340153c3059c8727b8b39d400"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a31aa6ca99e0b2ba7be0ddf0e653800f0">ptlrpc_new_bulk</a> (unsigned nfrags, unsigned max_brw, enum <a class="el" href="group__net.html#gaa3f75b2ff04d1cf65bcbbe7ab0ea1bef">ptlrpc_bulk_op_type</a> type, unsigned portal, const struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new bulk descriptor on the sender.  <a href="#a31aa6ca99e0b2ba7be0ddf0e653800f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb">ptlrpc_prep_bulk_imp</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, unsigned nfrags, unsigned max_brw, unsigned int type, unsigned portal, const struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare bulk descriptor for specified outgoing request <em>req</em> that can fit <em>nfrags</em> * pages.  <a href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaaf3d6df55675560574b76a41836bdb2e">__ptlrpc_prep_bulk_page</a> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, struct page *page, int pageoffset, int len, int pin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2ce5ef3b8b47e511c659611f9535f1f7">ptlrpc_prep_bulk_frag</a> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, void *frag, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga157357acf9f2b447ca5e49b108986e6c">ptlrpc_free_bulk</a> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7">ptlrpc_at_set_req_timeout</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set server timelimit for this req, i.e.  <a href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ab79ac5fad8084d595c3a3cc10c237961">ptlrpc_at_adj_service</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, unsigned int serv_est)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa4ddbc1d6aa868710ab5c137a2e029e2">ptlrpc_at_get_net_latency</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a5ba563478c05c9e93c9a322e6b2803c4">ptlrpc_at_adj_net_latency</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, unsigned int service_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a23aafe587f2688c690d08b2a0e534790">unpack_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a576041a28a9b577e7ee6f7c598cd1bbe">ptlrpc_at_recv_early_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req) __must_hold(&amp;req-&gt;rq_lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle an early reply message, called with the rq_lock held.  <a href="#a576041a28a9b577e7ee6f7c598cd1bbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#adf2f9b7a11e7944536c9232a455bb43a">ptlrpc_request_cache_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a522ac1657e956ed4312113516aec1e6f">ptlrpc_request_cache_fini</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#af6ed95facf669fc40ac53a9ffa67cf1b">ptlrpc_request_cache_alloc</a> (gfp_t flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a62d5a40d5504554ad53443f0ccae0cb2">ptlrpc_request_cache_free</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4">ptlrpc_free_rq_pool</a> (struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wind down request pool <em>pool</em>.  <a href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08">ptlrpc_add_rqs_to_pool</a> (struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool, int num_rq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates, initializes and adds <em>num_rq</em> requests to the pool <em>pool</em>.  <a href="group__net.html#ga07d19311543ebd57e6514926b08ddd08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818">ptlrpc_init_rq_pool</a> (int num_rq, int msgsize, int(*populate_pool)(struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *, int))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize new request pool with given attributes: <em>num_rq</em> - initial number of requests to create for the pool <em>msgsize</em> - maximum message size possible for requests in thid pool <em>populate_pool</em> - function to be called when more requests need to be added to the pool Returns pointer to newly created pool or NULL on error.  <a href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a84c042e583e04fef04174397ef6ec867">ptlrpc_prep_req_from_pool</a> (struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetches one request from pool <em>pool</em>.  <a href="#a84c042e583e04fef04174397ef6ec867"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#af1c9b131ae9d549d58bde259e41ea159">__ptlrpc_free_req_to_pool</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns freed <em>request</em> to pool.  <a href="#af1c9b131ae9d549d58bde259e41ea159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ae067008055fbc59b0c9f72abe8531fac">ptlrpc_add_unreplied</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ac179b6ddfe8bdcc1dddfa84f0f5178b3">ptlrpc_assign_next_xid_nolock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ad0df30933980097e8c390f870e4cc1a5">ptlrpc_assign_next_xid</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gae057f78231e03c194800fb70734b7ad2">ptlrpc_request_bufs_pack</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, __u32 <a class="el" href="mount__lustre_8c.html#aad880fc4455c253781e8968f2239d56f">version</a>, int opcode, char **bufs, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de">ptlrpc_request_pack</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, __u32 <a class="el" href="mount__lustre_8c.html#aad880fc4455c253781e8968f2239d56f">version</a>, int opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack request buffers for <a class="el" href="structnetwork.html">network</a> transfer, performing necessary encryption steps if necessary.  <a href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a0733e53c54d594a59a4e00fd29737251">__ptlrpc_request_alloc</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to allocate new request on import <em>imp</em> and possibly using existing request from pool <em>pool</em> if provided.  <a href="#a0733e53c54d594a59a4e00fd29737251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a4ff637b549105e75326e7510745c4460">ptlrpc_request_alloc_internal</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool, const struct <a class="el" href="structreq__format.html">req_format</a> *format)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for creating a request.  <a href="#a4ff637b549105e75326e7510745c4460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2bf080a905f488f676248838514e264a">ptlrpc_request_alloc</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, const struct <a class="el" href="structreq__format.html">req_format</a> *format)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request structure for import <em>imp</em> and initialize its buffer structure according to capsule template <em>format</em>.  <a href="group__net.html#ga2bf080a905f488f676248838514e264a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1">ptlrpc_request_alloc_pool</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool, const struct <a class="el" href="structreq__format.html">req_format</a> *format)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request structure for import <em>imp</em> from pool <em>pool</em> and initialize its buffer structure according to capsule template <em>format</em>.  <a href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f">ptlrpc_request_free</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For requests not from pool, free memory of the request structure.  <a href="group__net.html#ga35e91945e5dfe7314c1b31519907929f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4">ptlrpc_request_alloc_pack</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, const struct <a class="el" href="structreq__format.html">req_format</a> *format, __u32 <a class="el" href="mount__lustre_8c.html#aad880fc4455c253781e8968f2239d56f">version</a>, int opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request for operatione <em>opcode</em> and immediatelly pack it for <a class="el" href="structnetwork.html">network</a> transfer.  <a href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4">ptlrpc_prep_set</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new request set structure on the current CPT.  <a href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc">ptlrpc_prep_fcset</a> (int <a class="el" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>, <a class="el" href="group__net.html#ga17aa5caeef85aa78f71add31bf7afbe1">set_producer_func</a> func, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new request set structure with flow control extension.  <a href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8">ptlrpc_set_destroy</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wind down and free request set structure previously allocated with ptlrpc_prep_set.  <a href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af">ptlrpc_set_add_cb</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set, <a class="el" href="group__net.html#ga8ba8258387b636ab4e5695917aa2847d">set_interpreter_func</a> fn, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a callback function <em>fn</em> to the set.  <a href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8">ptlrpc_set_add_req</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new request to the general purpose request set.  <a href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a6978d733f46bb41c9ac9b5195aff2837">ptlrpc_set_add_new_req</a> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a request to a request with dedicated server thread and wake the thread to make any necessary processing.  <a href="#a6978d733f46bb41c9ac9b5195aff2837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a74e44d223c09372b3da86638b5621408">ptlrpc_import_delay_req</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int *<a class="el" href="lustre__rsync_8c.html#a55591f17a60f597b63f070969c54fd6c">status</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on the current state of the import, determine if the request can be sent, is an error, or should be delayed.  <a href="#a74e44d223c09372b3da86638b5621408"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a580cf37bc55b91080058efbadba962be">ptlrpc_console_allow</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decide if the error message should be printed to the console or not.  <a href="#a580cf37bc55b91080058efbadba962be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a6b651e0480deaadb0e28fbf083ccdc34">ptlrpc_check_status</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check request processing status.  <a href="#a6b651e0480deaadb0e28fbf083ccdc34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a2682790d1283c97c02274330db6fa61d">ptlrpc_save_versions</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save pre-versions of objects into request for replay.  <a href="#a2682790d1283c97c02274330db6fa61d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a61c8458a53357bfdd5228af942c30c55">ptlrpc_known_replied_xid</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a209615db20b7e62560cea22a3f32032b">after_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function called when client receives RPC reply for <em>req</em>.  <a href="#a209615db20b7e62560cea22a3f32032b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a55c3422e2f7b2aefd2d79bc53c91e14b">ptlrpc_set_producer</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga63613680c8953223c8efc4331656b11a">ptlrpc_check_set</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this sends any unsent RPCs in <em>set</em> and returns 1 if all are sent and no more replies are expected.  <a href="group__net.html#ga63613680c8953223c8efc4331656b11a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a9b3fbdcfa3f3e2d017c7fcc37c3e7ae5">ptlrpc_expire_one_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int async_unlink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time out request <em>req</em>.  <a href="#a9b3fbdcfa3f3e2d017c7fcc37c3e7ae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ac5d7cfee5628090111ef04b2e7054a3e">ptlrpc_expired_set</a> (void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time out all uncompleted requests in request set pointed by <em>data</em> Callback used when waiting on sets with l_wait_event.  <a href="#ac5d7cfee5628090111ef04b2e7054a3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7">ptlrpc_mark_interrupted</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets rq_intr flag in <em>req</em> under spinlock.  <a href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ad23d1dda34326ebe892d96015c2fcf5d">ptlrpc_interrupted_set</a> (void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts (sets interrupted flag) all uncompleted requests in a set <em>data</em>.  <a href="#ad23d1dda34326ebe892d96015c2fcf5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a1a571f24a883004b3deb6c6706e22972">ptlrpc_set_next_timeout</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the smallest timeout in the set; this does NOT set a timeout.  <a href="#a1a571f24a883004b3deb6c6706e22972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac072432ff0e3366be99c8456895e28d1">ptlrpc_set_wait</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send all unset request from the set and then wait untill all requests in the set complete (either get a reply, timeout, get an error or otherwise be interrupted).  <a href="group__net.html#gac072432ff0e3366be99c8456895e28d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#aa0abe14412ee392f4b2826663aaf1331">__ptlrpc_free_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, int locked)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper fuction for request freeing.  <a href="#aa0abe14412ee392f4b2826663aaf1331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a8fb86cb7b68c1c3f5dfefbcb1106edbb">__ptlrpc_req_finished</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, int locked)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function Drops one reference count for request <em>request</em>.  <a href="#a8fb86cb7b68c1c3f5dfefbcb1106edbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac030d75f1b39211b69e4974fc328669d">ptlrpc_req_finished_with_imp_lock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop one request reference.  <a href="group__net.html#gac030d75f1b39211b69e4974fc328669d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288">ptlrpc_req_finished</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops one reference count for a request.  <a href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga283d8a396288df3e34efd571d9d30018">ptlrpc_req_xid</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns xid of a <em>request</em>.  <a href="group__net.html#ga283d8a396288df3e34efd571d9d30018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#abc2f27f5e53ebc3d0e83b2c9d65f6f7b">ptlrpc_free_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacab48d448ba12ade8093383e054814cc">ptlrpc_request_committed</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the request is committed and dropped from the replay list of its import  <a href="group__net.html#gacab48d448ba12ade8093383e054814cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11">ptlrpc_free_committed</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through replay_list on import and prunes all requests have transno smaller than last_committed for the import and don't have rq_replay set.  <a href="group__ha.html#ga1201e450853aba39256bafedcfae7f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga1b758fc8a90798b7f3f82ad51ed8b518">ptlrpc_cleanup_client</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ab780f18489fd5668f8437d66d9ddad52">ptlrpc_resend_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule previously sent request for resend.  <a href="#ab780f18489fd5668f8437d66d9ddad52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga469a6dc4c139ecc1ab2fd3562c693986">ptlrpc_restart_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3">ptlrpc_request_addref</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab additional reference on a request <em>req</em>.  <a href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268">ptlrpc_retain_replayable_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a request to import replay_list.  <a href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48">ptlrpc_queue_wait</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send request and wait until it completes.  <a href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a76b6e6fbb082dbd89cbf9b49e2c67beb">ptlrpc_replay_interpret</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, void *data, int rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used for replayed requests reply processing.  <a href="#a76b6e6fbb082dbd89cbf9b49e2c67beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc">ptlrpc_replay_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares and queues request for replay.  <a href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c">ptlrpc_abort_inflight</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aborts all in-flight request on import <em>imp</em> sending and delayed lists.  <a href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77">ptlrpc_abort_set</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort all uncompleted requests in request set <em>set</em>.  <a href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a2c3a77dc12500211df2df050eae99040">ptlrpc_init_xid</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf2442fe17f822101d45881701da27f40">ptlrpc_next_xid</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase xid and returns resulting new value to the caller.  <a href="group__net.html#gaf2442fe17f822101d45881701da27f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ad93d8710b114f9917eda916dd057035e">ptlrpc_set_bulk_mbits</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If request has a new allocated XID (new request or EINPROGRESS resend), use this XID as matchbits of bulk, otherwise allocate a new matchbits for request to ensure previous bulk fails and avoid problems with lost replies and therefore several transfers landing into the same buffer from different sending attempts.  <a href="#ad93d8710b114f9917eda916dd057035e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3">ptlrpc_sample_next_xid</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a glimpse at what next xid value might have been.  <a href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a6e976a291c91cb72637176dd5eea4bf8">ptlrpcd_add_work_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a9e58537db5ff163c5f186d08e209a245">work_interpreter</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, void *data, int rc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108">ptlrpcd_alloc_work</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int(*cb)(const struct <a class="el" href="structlu__env.html">lu_env</a> *, void *), void *cbdata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a work for ptlrpc.  <a href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga4f31480e3a6bf61fb70da03169ffef2c">ptlrpcd_destroy_work</a> (void *handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a> (void *handler)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga1194825a0870adce9de4d05b19500152">ptlrpc_bulk_kiov_pin_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga687589e95f98270c665ebde62a874d03">ptlrpc_bulk_kiov_nopin_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga72925c5dcb81674f2d733fc975dc4748">ptlrpc_bulk_kvec_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#ad2df9ba379d2443dbdd19139c6f57b7d">request_cache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a2bd21382b3b02652a0be8715ccb3d625">ptlrpc_last_xid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#add2bc631499eb5b705b215ac894a018a">ptlrpc_last_xid_lock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8c.html#a417af1d347a74240bb697d4f0655c29b">worker_format</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="client.c::DEBUG_SUBSYSTEM" ref="abda60744d497fcfe370cfd6b2d65c7ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SUBSYSTEM&nbsp;&nbsp;&nbsp;S_RPC</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of client-side PortalRPC interfaces. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00039">39</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

</div>
</div>
<a class="anchor" id="a90fa0703e95d68f79e54a4db5f6ed8f7"></a><!-- doxytag: member="client.c::YEAR_2004" ref="a90fa0703e95d68f79e54a4db5f6ed8f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YEAR_2004&nbsp;&nbsp;&nbsp;(1ULL &lt;&lt; 30)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the XID for the node. </p>
<p>This is common among all requests on this node, and only requires the property that it is monotonically increasing. It does not need to be sequential. Since this is also used as the RDMA match bits, it is important that a single client NOT have the same match bits for two different in-flight requests, hence we do NOT want to have an XID per target or similar.</p>
<p>To avoid an unlikely collision between match bits after a client reboot (which would deliver old data into the wrong RDMA buffer) initialize the XID based on the current time, assuming a maximum RPC rate of 1M RPC/s. If the time is clearly incorrect, we instead use a 62-bit random number. In the worst case the random number will overflow 1M RPCs per second in 9133 years, or permutations thereof. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l03146">3146</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l03147">ptlrpc_init_xid()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa0abe14412ee392f4b2826663aaf1331"></a><!-- doxytag: member="client.c::__ptlrpc_free_req" ref="aa0abe14412ee392f4b2826663aaf1331" args="(struct ptlrpc_request *request, int locked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __ptlrpc_free_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>locked</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper fuction for request freeing. </p>
<p>Called when request count reached zero and request needs to be freed. Removes request from all sorts of sending/replay lists it might be on, frees <a class="el" href="structnetwork.html">network</a> buffers if any are present. If <em>locked</em> is set, that means caller is already holding import imp_lock and so we no longer need to reobtain it (for certain lists manipulations) </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02389">2389</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00647">__ptlrpc_free_req_to_pool()</a>, <a class="el" href="genops_8c_source.html#l01015">class_import_put()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00146">D_ERROR</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="client_8c_source.html#l00257">ptlrpc_free_bulk()</a>, <a class="el" href="client_8c_source.html#l00500">ptlrpc_request_cache_free()</a>, <a class="el" href="layout_8c_source.html#l01792">req_capsule_fini()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00358">RETURN_EXIT</a>, <a class="el" href="lustre__net_8h_source.html#l01083">ptlrpc_request::rq_clrbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01102">ptlrpc_request::rq_export</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>, <a class="el" href="lustre__net_8h_source.html#l01028">ptlrpc_request::rq_pool</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_receiving_reply</a>, <a class="el" href="lustre__net_8h_source.html#l01016">ptlrpc_request::rq_refcount</a>, <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_replay</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01059">ptlrpc_request::rq_srv_req</a>, <a class="el" href="sec_8c_source.html#l01728">sptlrpc_cli_free_repbuf()</a>, <a class="el" href="sec_8c_source.html#l01610">sptlrpc_cli_free_reqbuf()</a>, and <a class="el" href="sec_8c_source.html#l00460">sptlrpc_req_put_ctx()</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02463">__ptlrpc_req_finished()</a>.</p>

</div>
</div>
<a class="anchor" id="af1c9b131ae9d549d58bde259e41ea159"></a><!-- doxytag: member="client.c::__ptlrpc_free_req_to_pool" ref="af1c9b131ae9d549d58bde259e41ea159" args="(struct ptlrpc_request *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __ptlrpc_free_req_to_pool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns freed <em>request</em> to pool. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00647">647</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="lustre__net_8h_source.html#l00742">ptlrpc_request_pool::prp_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00744">ptlrpc_request_pool::prp_req_list</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l01028">ptlrpc_request::rq_pool</a>, and <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_receiving_reply</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02389">__ptlrpc_free_req()</a>, and <a class="el" href="client_8c_source.html#l00875">ptlrpc_request_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb86cb7b68c1c3f5dfefbcb1106edbb"></a><!-- doxytag: member="client.c::__ptlrpc_req_finished" ref="a8fb86cb7b68c1c3f5dfefbcb1106edbb" args="(struct ptlrpc_request *request, int locked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __ptlrpc_req_finished </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>locked</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function Drops one reference count for request <em>request</em>. </p>
<p><em>locked</em> set indicates that caller holds import imp_lock. Frees the request whe reference count reaches zero. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02463">2463</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l02389">__ptlrpc_free_req()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01016">ptlrpc_request::rq_refcount</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02585">ptlrpc_free_request()</a>, <a class="el" href="client_8c_source.html#l02490">ptlrpc_req_finished()</a>, and <a class="el" href="client_8c_source.html#l02451">ptlrpc_req_finished_with_imp_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a0733e53c54d594a59a4e00fd29737251"></a><!-- doxytag: member="client.c::__ptlrpc_request_alloc" ref="a0733e53c54d594a59a4e00fd29737251" args="(struct obd_import *imp, struct ptlrpc_request_pool *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* __ptlrpc_request_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to allocate new request on import <em>imp</em> and possibly using existing request from pool <em>pool</em> if provided. </p>
<p>Returns allocated request structure with import field filled or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00799">799</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="genops_8c_source.html#l01005">class_import_get()</a>, <a class="el" href="lustre__import_8h_source.html#l00172">obd_import::imp_client</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00368">ptlrpc_cli_req_init()</a>, <a class="el" href="client_8c_source.html#l00608">ptlrpc_prep_req_from_pool()</a>, <a class="el" href="client_8c_source.html#l00492">ptlrpc_request_cache_alloc()</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00833">ptlrpc_request_alloc_internal()</a>.</p>

</div>
</div>
<a class="anchor" id="a209615db20b7e62560cea22a3f32032b"></a><!-- doxytag: member="client.c::after_reply" ref="a209615db20b7e62560cea22a3f32032b" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int after_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function called when client receives RPC reply for <em>req</em>. </p>
<p>Returns 0 on success or error code. The return alue would be assigned to req-&gt;rq_status by the caller as request processing status. This function also decides if the request needs to be saved for later replay. </p>

<p><p>version recovery </p>
</p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01297">1297</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="libcfs__fail_8h_source.html#l00139">CFS_FAIL_TIMEOUT</a>, <a class="el" href="fail_8c_source.html#l00039">cfs_fail_val</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="libcfs__time_8h_source.html#l00072">cfs_timeval_sub()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00146">D_ERROR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00149">D_RPCTRACE</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__import_8h_source.html#l00318">obd_import::imp_connect_error</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_dlm_fake</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00248">obd_import::imp_peer_committed_transno</a>, <a class="el" href="lustre__import_8h_source.html#l00183">obd_import::imp_replay_list</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_replayable</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="ldlm__request_8c_source.html#l01294">ldlm_cli_update_pool()</a>, <a class="el" href="libcfs__private_8h_source.html#l00309">likely</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="lprocfs__status_8h_source.html#l00866">lprocfs_counter_add()</a>, <a class="el" href="lustre__import_8h_source.html#l00106">LUSTRE_IMP_FULL</a>, <a class="el" href="pack__generic_8c_source.html#l00829">lustre_msg_get_flags()</a>, <a class="el" href="pack__generic_8c_source.html#l01044">lustre_msg_get_last_committed()</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="pack__generic_8c_source.html#l01234">lustre_msg_get_service_time()</a>, <a class="el" href="pack__generic_8c_source.html#l01098">lustre_msg_get_status()</a>, <a class="el" href="pack__generic_8c_source.html#l01217">lustre_msg_get_timeout()</a>, <a class="el" href="pack__generic_8c_source.html#l01080">lustre_msg_get_transno()</a>, <a class="el" href="pack__generic_8c_source.html#l00940">lustre_msg_get_type()</a>, <a class="el" href="pack__generic_8c_source.html#l01424">lustre_msg_set_transno()</a>, <a class="el" href="lustre__idl_8h_source.html#l01154">MSG_REPLAY</a>, <a class="el" href="createmany_8c_source.html#l00069">now()</a>, <a class="el" href="obd__support_8h_source.html#l00404">OBD_FAIL_PTLRPC_PAUSE_REP</a>, <a class="el" href="obd_8h_source.html#l00603">obd_device::obd_no_recov</a>, <a class="el" href="packet-lustre_8c_source.html#l00303">OBD_PING</a>, <a class="el" href="obd_8h_source.html#l00715">obd_device::obd_svc_stats</a>, <a class="el" href="list_8h_source.html#l00043">list_head::prev</a>, <a class="el" href="packet-lustre_8c_source.html#l00360">PTL_RPC_MSG_ERR</a>, <a class="el" href="packet-lustre_8c_source.html#l00361">PTL_RPC_MSG_REPLY</a>, <a class="el" href="client_8c_source.html#l00357">ptlrpc_at_adj_net_latency()</a>, <a class="el" href="client_8c_source.html#l00329">ptlrpc_at_adj_service()</a>, <a class="el" href="client_8c_source.html#l00293">ptlrpc_at_set_req_timeout()</a>, <a class="el" href="client_8c_source.html#l01219">ptlrpc_check_status()</a>, <a class="el" href="client_8c_source.html#l02626">ptlrpc_free_committed()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00121">ptlrpc_lprocfs_rpc_sent</a>, <a class="el" href="lustre__net_8h_source.html#l02563">ptlrpc_no_resend()</a>, <a class="el" href="pinger_8c_source.html#l00390">ptlrpc_pinger_commit_expected()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00320">ptlrpc_recoverable_error()</a>, <a class="el" href="recover_8c_source.html#l00249">ptlrpc_request_handle_notconn()</a>, <a class="el" href="lprocfs__status_8h_source.html#l00331">PTLRPC_REQWAIT_CNTR</a>, <a class="el" href="client_8c_source.html#l02769">ptlrpc_retain_replayable_request()</a>, <a class="el" href="client_8c_source.html#l01254">ptlrpc_save_versions()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_no_retry_einprogress</a>, <a class="el" href="lustre__net_8h_source.html#l01022">ptlrpc_request::rq_nob_received</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_receiving_reply</a>, <a class="el" href="lustre__net_8h_source.html#l01086">ptlrpc_request::rq_repbuf_len</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_replay</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, <a class="el" href="lustre__net_8h_source.html#l01026">ptlrpc_request::rq_replen</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_reply_truncated</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_reply_unlinked</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_resend</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>, <a class="el" href="lustre__net_8h_source.html#l01034">ptlrpc_request::rq_transno</a>, <a class="el" href="sec_8c_source.html#l01728">sptlrpc_cli_free_repbuf()</a>, <a class="el" href="sec_8c_source.html#l01090">sptlrpc_cli_unwrap_reply()</a>, and <a class="el" href="client_8c_source.html#l00397">unpack_reply()</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>.</p>

</div>
</div>
<a class="anchor" id="ae067008055fbc59b0c9f72abe8531fac"></a><!-- doxytag: member="client.c::ptlrpc_add_unreplied" ref="ae067008055fbc59b0c9f72abe8531fac" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_add_unreplied </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00658">658</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00200">obd_import::imp_unreplied_list</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00076">list_add()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="list_8h_source.html#l00449">list_for_each_prev</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00875">rq_unreplied_list</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00681">ptlrpc_assign_next_xid_nolock()</a>, <a class="el" href="import_8c_source.html#l00952">ptlrpc_prepare_replay()</a>, and <a class="el" href="recover_8c_source.html#l00072">ptlrpc_replay_next()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0df30933980097e8c390f870e4cc1a5"></a><!-- doxytag: member="client.c::ptlrpc_assign_next_xid" ref="ad0df30933980097e8c390f870e4cc1a5" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_assign_next_xid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00687">687</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="client_8c_source.html#l00681">ptlrpc_assign_next_xid_nolock()</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00694">ptlrpc_request_bufs_pack()</a>.</p>

</div>
</div>
<a class="anchor" id="ac179b6ddfe8bdcc1dddfa84f0f5178b3"></a><!-- doxytag: member="client.c::ptlrpc_assign_next_xid_nolock" ref="ac179b6ddfe8bdcc1dddfa84f0f5178b3" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_assign_next_xid_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00681">681</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00658">ptlrpc_add_unreplied()</a>, <a class="el" href="client_8c_source.html#l03177">ptlrpc_next_xid()</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, and <a class="el" href="client_8c_source.html#l00687">ptlrpc_assign_next_xid()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba563478c05c9e93c9a322e6b2803c4"></a><!-- doxytag: member="client.c::ptlrpc_at_adj_net_latency" ref="a5ba563478c05c9e93c9a322e6b2803c4" args="(struct ptlrpc_request *req, unsigned int service_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_at_adj_net_latency </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>service_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00357">357</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00373">at_get()</a>, <a class="el" href="import_8c_source.html#l01665">at_measured()</a>, <a class="el" href="lustre__net_8h_source.html#l00523">ptlrpc_connection::c_remote_uuid</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="linux-time_8h_source.html#l00263">CFS_DURATION_T</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="libcfs__time_8h_source.html#l00051">cfs_time_sub()</a>, <a class="el" href="lustre__import_8h_source.html#l00059">D_ADAPTTO</a>, <a class="el" href="libcfs__debug_8h_source.html#l00139">D_WARNING</a>, <a class="el" href="lustre__import_8h_source.html#l00089">imp_at::iat_net_latency</a>, <a class="el" href="lustre__import_8h_source.html#l00323">obd_import::imp_at</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="pack__generic_8c_source.html#l00829">lustre_msg_get_flags()</a>, <a class="el" href="lustre__idl_8h_source.html#l01153">MSG_RESENT</a>, <a class="el" href="createmany_8c_source.html#l00069">now()</a>, <a class="el" href="obd_8h_source.html#l00599">obd_device::obd_name</a>, <a class="el" href="lustre__user_8h_source.html#l00513">obd_uuid2str()</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01297">after_reply()</a>, <a class="el" href="client_8c_source.html#l00421">ptlrpc_at_recv_early_reply()</a>, and <a class="el" href="import_8c_source.html#l00984">ptlrpc_connect_interpret()</a>.</p>

</div>
</div>
<a class="anchor" id="ab79ac5fad8084d595c3a3cc10c237961"></a><!-- doxytag: member="client.c::ptlrpc_at_adj_service" ref="ab79ac5fad8084d595c3a3cc10c237961" args="(struct ptlrpc_request *req, unsigned int serv_est)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_at_adj_service </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>serv_est</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00329">329</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00373">at_get()</a>, <a class="el" href="import_8c_source.html#l01665">at_measured()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="lustre__import_8h_source.html#l00059">D_ADAPTTO</a>, <a class="el" href="lustre__import_8h_source.html#l00090">imp_at::iat_service_estimate</a>, <a class="el" href="lustre__import_8h_source.html#l00323">obd_import::imp_at</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="import_8c_source.html#l01742">import_at_get_index()</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="obd_8h_source.html#l00599">obd_device::obd_name</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01297">after_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="a576041a28a9b577e7ee6f7c598cd1bbe"></a><!-- doxytag: member="client.c::ptlrpc_at_recv_early_reply" ref="a576041a28a9b577e7ee6f7c598cd1bbe" args="(struct ptlrpc_request *req) __must_hold(&amp;req&#45;&gt;rq_lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_at_recv_early_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle an early reply message, called with the rq_lock held. </p>
<p>If anything goes wrong just ignore it - same as if it never happened </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00421">421</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00263">CFS_DURATION_T</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="libcfs__time_8h_source.html#l00051">cfs_time_sub()</a>, <a class="el" href="lustre__import_8h_source.html#l00059">D_ADAPTTO</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="pack__generic_8c_source.html#l01234">lustre_msg_get_service_time()</a>, <a class="el" href="pack__generic_8c_source.html#l01217">lustre_msg_get_timeout()</a>, <a class="el" href="pack__generic_8c_source.html#l01468">lustre_msg_set_timeout()</a>, <a class="el" href="client_8c_source.html#l00357">ptlrpc_at_adj_net_latency()</a>, <a class="el" href="client_8c_source.html#l00351">ptlrpc_at_get_net_latency()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="sec_8c_source.html#l01221">sptlrpc_cli_finish_early_reply()</a>, <a class="el" href="sec_8c_source.html#l01130">sptlrpc_cli_unwrap_early_reply()</a>, and <a class="el" href="client_8c_source.html#l00397">unpack_reply()</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b651e0480deaadb0e28fbf083ccdc34"></a><!-- doxytag: member="client.c::ptlrpc_check_status" ref="a6b651e0480deaadb0e28fbf083ccdc34" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_check_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check request processing status. </p>
<p>Returns the status. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01219">1219</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="libcfs__debug_8h_source.html#l00285">LCONSOLE_ERROR_MSG</a>, <a class="el" href="nidstr_8h_source.html#l00077">libcfs_nid2str()</a>, <a class="el" href="lproc__ptlrpc_8c_source.html#l00163">ll_opcode2str()</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="pack__generic_8c_source.html#l01098">lustre_msg_get_status()</a>, <a class="el" href="pack__generic_8c_source.html#l00940">lustre_msg_get_type()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>, <a class="el" href="obd_8h_source.html#l00599">obd_device::obd_name</a>, <a class="el" href="packet-lustre_8c_source.html#l00360">PTL_RPC_MSG_ERR</a>, <a class="el" href="client_8c_source.html#l01187">ptlrpc_console_allow()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01297">after_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="a580cf37bc55b91080058efbadba962be"></a><!-- doxytag: member="client.c::ptlrpc_console_allow" ref="a580cf37bc55b91080058efbadba962be" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ptlrpc_console_allow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decide if the error message should be printed to the console or not. </p>
<p>Makes its decision based on request type, status, and failure frequency.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>request that failed and may need a console message</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>if no message should be printed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>if console message should be printed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="client_8c_source.html#l01187">1187</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00239">obd_import::imp_conn_cnt</a>, <a class="el" href="lustre__import_8h_source.html#l00260">obd_import::imp_remote_handle</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__idl_8h_source.html#l01021">lustre_handle_is_used()</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="pack__generic_8c_source.html#l01098">lustre_msg_get_status()</a>, <a class="el" href="packet-lustre_8c_source.html#l00206">MDS_CONNECT</a>, <a class="el" href="packet-lustre_8c_source.html#l00309">MGS_CONNECT</a>, <a class="el" href="packet-lustre_8c_source.html#l00171">OST_CONNECT</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_timedout</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01219">ptlrpc_check_status()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b3fbdcfa3f3e2d017c7fcc37c3e7ae5"></a><!-- doxytag: member="client.c::ptlrpc_expire_one_request" ref="a9b3fbdcfa3f3e2d017c7fcc37c3e7ae5" args="(struct ptlrpc_request *req, int async_unlink)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_expire_one_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>async_unlink</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time out request <em>req</em>. </p>
<p>is <em>async_unlink</em> is set, that means do not wait until LNet actually confirms <a class="el" href="structnetwork.html">network</a> buffer unlinking. Return 1 if we should give up further retrying attempts or 0 otherwise. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02050">2050</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="linux-time_8h_source.html#l00263">CFS_DURATION_T</a>, <a class="el" href="libcfs__time_8h_source.html#l00061">cfs_time_aftereq()</a>, <a class="el" href="linux-time_8h_source.html#l00142">cfs_time_before()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="libcfs__debug_8h_source.html#l00149">D_RPCTRACE</a>, <a class="el" href="libcfs__debug_8h_source.html#l00139">D_WARNING</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_dlm_fake</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="lustre__import_8h_source.html#l00228">obd_import::imp_timeouts</a>, <a class="el" href="libcfs_2libcfs_2debug_8c_source.html#l00251">libcfs_debug_dumplog()</a>, <a class="el" href="api-ni_8c_source.html#l02111">LNetDebugPeer()</a>, <a class="el" href="lustre__import_8h_source.html#l00106">LUSTRE_IMP_FULL</a>, <a class="el" href="pack__generic_8c_source.html#l01188">lustre_msg_get_conn_cnt()</a>, <a class="el" href="class__obd_8c_source.html#l00073">obd_debug_peer_on_timeout</a>, <a class="el" href="class__obd_8c_source.html#l00075">obd_dump_on_timeout</a>, <a class="el" href="obd_8h_source.html#l00603">obd_device::obd_no_recov</a>, <a class="el" href="import_8c_source.html#l00429">ptlrpc_fail_import()</a>, <a class="el" href="lustre__import_8h_source.html#l00111">ptlrpc_import_state_name()</a>, <a class="el" href="lustre__net_8h_source.html#l02563">ptlrpc_no_resend()</a>, <a class="el" href="niobuf_8c_source.html#l00420">ptlrpc_unregister_bulk()</a>, <a class="el" href="client_8c_source.html#l02512">ptlrpc_unregister_reply()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01059">ptlrpc_request::rq_ctx_fini</a>, <a class="el" href="lustre__net_8h_source.html#l01059">ptlrpc_request::rq_ctx_init</a>, <a class="el" href="lustre__net_8h_source.html#l01119">ptlrpc_request::rq_deadline</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_err</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_net_err</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, and <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_timedout</a>.</p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00622">ctx_refresh_timeout()</a>, <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="client_8c_source.html#l02121">ptlrpc_expired_set()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5d7cfee5628090111ef04b2e7054a3e"></a><!-- doxytag: member="client.c::ptlrpc_expired_set" ref="ac5d7cfee5628090111ef04b2e7054a3e" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_expired_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time out all uncompleted requests in request set pointed by <em>data</em> Callback used when waiting on sets with l_wait_event. </p>
<p>Always returns 1. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02121">2121</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="list_8h_source.html#l00253">list_for_each</a>, <a class="el" href="createmany_8c_source.html#l00069">now()</a>, <a class="el" href="client_8c_source.html#l02050">ptlrpc_expire_one_request()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01119">ptlrpc_request::rq_deadline</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00719">RQ_PHASE_BULK</a>, <a class="el" href="lustre__net_8h_source.html#l00718">RQ_PHASE_RPC</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_resend</a>, <a class="el" href="lustre__net_8h_source.html#l00861">rq_set_chain</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_timedout</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_wait_ctx</a>, and <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_waiting</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>, and <a class="el" href="ptlrpcd_8c_source.html#l00427">ptlrpcd()</a>.</p>

</div>
</div>
<a class="anchor" id="abc2f27f5e53ebc3d0e83b2c9d65f6f7b"></a><!-- doxytag: member="client.c::ptlrpc_free_request" ref="abc2f27f5e53ebc3d0e83b2c9d65f6f7b" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_free_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l02585">2585</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l02463">__ptlrpc_req_finished()</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_replay</a>, and <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02626">ptlrpc_free_committed()</a>, <a class="el" href="client_8c_source.html#l02862">ptlrpc_replay_interpret()</a>, and <a class="el" href="client_8c_source.html#l02601">ptlrpc_request_committed()</a>.</p>

</div>
</div>
<a class="anchor" id="a74e44d223c09372b3da86638b5621408"></a><!-- doxytag: member="client.c::ptlrpc_import_delay_req" ref="a74e44d223c09372b3da86638b5621408" args="(struct obd_import *imp, struct ptlrpc_request *req, int *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_import_delay_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Based on the current state of the import, determine if the request can be sent, is an error, or should be delayed. </p>
<p>Returns true if this request should be delayed. If false, and *status is set, then the request can not be sent and *status is the error code. If false and status is 0, then request can be sent.</p>
<p>The imp-&gt;imp_lock must be held. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01120">1120</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00146">D_ERROR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="libcfs__debug_8h_source.html#l00138">D_NET</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_deactive</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_dlm_fake</a>, <a class="el" href="lustre__import_8h_source.html#l00237">obd_import::imp_generation</a>, <a class="el" href="lustre__import_8h_source.html#l00226">obd_import::imp_inval_count</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_invalid</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__import_8h_source.html#l00098">LUSTRE_IMP_CLOSED</a>, <a class="el" href="lustre__import_8h_source.html#l00101">LUSTRE_IMP_CONNECTING</a>, <a class="el" href="lustre__import_8h_source.html#l00099">LUSTRE_IMP_NEW</a>, <a class="el" href="lustre__import_8h_source.html#l00105">LUSTRE_IMP_RECOVER</a>, <a class="el" href="lustre__import_8h_source.html#l00102">LUSTRE_IMP_REPLAY</a>, <a class="el" href="lustre__import_8h_source.html#l00103">LUSTRE_IMP_REPLAY_LOCKS</a>, <a class="el" href="lustre__import_8h_source.html#l00104">LUSTRE_IMP_REPLAY_WAIT</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="obd_8h_source.html#l00603">obd_device::obd_no_recov</a>, <a class="el" href="packet-lustre_8c_source.html#l00303">OBD_PING</a>, <a class="el" href="lustre__net_8h_source.html#l02552">ptlrpc_send_limit_expired()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_allow_replay</a>, <a class="el" href="lustre__net_8h_source.html#l01059">ptlrpc_request::rq_ctx_fini</a>, <a class="el" href="lustre__net_8h_source.html#l01059">ptlrpc_request::rq_ctx_init</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_no_delay</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="client_8c_source.html#l01494">ptlrpc_send_new_req()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c3a77dc12500211df2df050eae99040"></a><!-- doxytag: member="client.c::ptlrpc_init_xid" ref="a2c3a77dc12500211df2df050eae99040" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_init_xid </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03147">3147</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="prng_8c_source.html#l00111">cfs_get_random_bytes()</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="osd__iam_8h_source.html#l00054">CLASSERT</a>, <a class="el" href="createmany_8c_source.html#l00069">now()</a>, <a class="el" href="lustre__net_8h_source.html#l00086">PTLRPC_BULK_OPS_COUNT</a>, <a class="el" href="lustre__net_8h_source.html#l00094">PTLRPC_BULK_OPS_MASK</a>, and <a class="el" href="client_8c_source.html#l03146">YEAR_2004</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__module_8c_source.html#l00052">ptlrpc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ad23d1dda34326ebe892d96015c2fcf5d"></a><!-- doxytag: member="client.c::ptlrpc_interrupted_set" ref="ad23d1dda34326ebe892d96015c2fcf5d" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_interrupted_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupts (sets interrupted flag) all uncompleted requests in a set <em>data</em>. </p>
<p>Callback for l_wait_event for interruptible waits. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02180">2180</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00149">D_RPCTRACE</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="list_8h_source.html#l00253">list_for_each</a>, <a class="el" href="client_8c_source.html#l02168">ptlrpc_mark_interrupted()</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_allow_intr</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_intr</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00718">RQ_PHASE_RPC</a>, <a class="el" href="lustre__net_8h_source.html#l00722">RQ_PHASE_UNREGISTERING</a>, and <a class="el" href="lustre__net_8h_source.html#l00861">rq_set_chain</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>.</p>

</div>
</div>
<a class="anchor" id="a61c8458a53357bfdd5228af942c30c55"></a><!-- doxytag: member="client.c::ptlrpc_known_replied_xid" ref="a61c8458a53357bfdd5228af942c30c55" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> ptlrpc_known_replied_xid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l01272">1272</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00202">obd_import::imp_known_replied_xid</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00200">obd_import::imp_unreplied_list</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00045">LPU64</a>, <a class="el" href="list_8h_source.html#l00043">list_head::next</a>, <a class="el" href="lustre__net_8h_source.html#l00875">rq_unreplied_list</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="import_8c_source.html#l00952">ptlrpc_prepare_replay()</a>, and <a class="el" href="client_8c_source.html#l01494">ptlrpc_send_new_req()</a>.</p>

</div>
</div>
<a class="anchor" id="a31aa6ca99e0b2ba7be0ddf0e653800f0"></a><!-- doxytag: member="client.c::ptlrpc_new_bulk" ref="a31aa6ca99e0b2ba7be0ddf0e653800f0" args="(unsigned nfrags, unsigned max_brw, enum ptlrpc_bulk_op_type type, unsigned portal, const struct ptlrpc_bulk_frag_ops *ops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a>* ptlrpc_new_bulk </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nfrags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>max_brw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__net.html#gaa3f75b2ff04d1cf65bcbbe7ab0ea1bef">ptlrpc_bulk_op_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *&nbsp;</td>
          <td class="paramname"> <em>ops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize new bulk descriptor on the sender. </p>
<p>Returns pointer to the descriptor or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00117">117</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="structptlrpc__bulk__frag__ops.html#a071eacf4504ae84799e0f989a0e43229">ptlrpc_bulk_frag_ops::add_iov_frag</a>, <a class="el" href="structptlrpc__bulk__frag__ops.html#a3338125828618910ae190978e235d52a">ptlrpc_bulk_frag_ops::add_kiov_frag</a>, <a class="el" href="lustre__net_8h_source.html#l01451">ptlrpc_bulk_desc::bd_frag_ops</a>, <a class="el" href="lustre__net_8h_source.html#l01453">ptlrpc_bulk_desc::bd_iov_count</a>, <a class="el" href="lustre__net_8h_source.html#l01438">ptlrpc_bulk_desc::bd_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01454">ptlrpc_bulk_desc::bd_max_iov</a>, <a class="el" href="lustre__net_8h_source.html#l01462">ptlrpc_bulk_desc::bd_md_count</a>, <a class="el" href="lustre__net_8h_source.html#l01463">ptlrpc_bulk_desc::bd_md_max_brw</a>, <a class="el" href="lustre__net_8h_source.html#l01465">ptlrpc_bulk_desc::bd_mds</a>, <a class="el" href="lustre__net_8h_source.html#l01444">ptlrpc_bulk_desc::bd_portal</a>, <a class="el" href="lustre__net_8h_source.html#l01442">ptlrpc_bulk_desc::bd_type</a>, <a class="el" href="lustre__net_8h_source.html#l01452">ptlrpc_bulk_desc::bd_waitq</a>, <a class="el" href="lustre__net_8h_source.html#l01484">GET_KIOV</a>, <a class="el" href="lustre__net_8h_source.html#l01488">GET_KVEC</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00274">LNetInvalidateHandle()</a>, <a class="el" href="obd__support_8h_source.html#l00747">OBD_ALLOC_LARGE</a>, <a class="el" href="obd__support_8h_source.html#l00710">OBD_ALLOC_PTR</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="lustre__net_8h_source.html#l01337">PTLRPC_BULK_BUF_KIOV</a>, <a class="el" href="lustre__net_8h_source.html#l00086">PTLRPC_BULK_OPS_COUNT</a>, <a class="el" href="lustre__net_8h_source.html#l01375">ptlrpc_is_bulk_desc_kiov()</a>, and <a class="el" href="lustre__net_8h_source.html#l01369">ptlrpc_is_bulk_desc_kvec()</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00174">ptlrpc_prep_bulk_imp()</a>.</p>

</div>
</div>
<a class="anchor" id="a84c042e583e04fef04174397ef6ec867"></a><!-- doxytag: member="client.c::ptlrpc_prep_req_from_pool" ref="a84c042e583e04fef04174397ef6ec867" args="(struct ptlrpc_request_pool *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* ptlrpc_prep_req_from_pool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches one request from pool <em>pool</em>. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00608">608</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="lustre__idl_8h_source.html#l01047">lustre_msg</a>, <a class="el" href="list_8h_source.html#l00043">list_head::next</a>, <a class="el" href="lustre__net_8h_source.html#l00742">ptlrpc_request_pool::prp_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00744">ptlrpc_request_pool::prp_req_list</a>, <a class="el" href="lustre__net_8h_source.html#l00746">ptlrpc_request_pool::prp_rq_size</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l01028">ptlrpc_request::rq_pool</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01084">ptlrpc_request::rq_reqbuf_len</a>, and <a class="el" href="libcfs__private_8h_source.html#l00310">unlikely</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00799">__ptlrpc_request_alloc()</a>.</p>

</div>
</div>
<a class="anchor" id="a76b6e6fbb082dbd89cbf9b49e2c67beb"></a><!-- doxytag: member="client.c::ptlrpc_replay_interpret" ref="a76b6e6fbb082dbd89cbf9b49e2c67beb" args="(const struct lu_env *env, struct ptlrpc_request *req, void *data, int rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_replay_interpret </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used for replayed requests reply processing. </p>
<p>In case of successful reply calls registered request replay callback. In case of error restart replay process. </p>

<p><p>VBR: check version failure</p>
<p>replay was failed due to version mismatch</p>
<p>The transno had better not change over replay.</p>
<p>if replays by version then gap occur on server, no trust to locks </p>
</p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02862">2862</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00146">D_ERROR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="libcfs__debug_8h_source.html#l00139">D_WARNING</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lustre__import_8h_source.html#l00195">obd_import::imp_committed_list</a>, <a class="el" href="lustre__import_8h_source.html#l00317">obd_import::imp_connect_flags_orig</a>, <a class="el" href="lustre__import_8h_source.html#l00185">obd_import::imp_delayed_list</a>, <a class="el" href="lustre__import_8h_source.html#l00246">obd_import::imp_last_replay_transno</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_no_lock_replay</a>, <a class="el" href="lustre__import_8h_source.html#l00224">obd_import::imp_replay_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00183">obd_import::imp_replay_list</a>, <a class="el" href="lustre__import_8h_source.html#l00184">obd_import::imp_sending_list</a>, <a class="el" href="lustre__import_8h_source.html#l00277">obd_import::imp_vbr_failed</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="list_8h_source.html#l00484">list_for_each_entry_safe</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00045">LPU64</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00047">LPX64</a>, <a class="el" href="pack__generic_8c_source.html#l00829">lustre_msg_get_flags()</a>, <a class="el" href="pack__generic_8c_source.html#l01098">lustre_msg_get_status()</a>, <a class="el" href="pack__generic_8c_source.html#l01080">lustre_msg_get_transno()</a>, <a class="el" href="pack__generic_8c_source.html#l00940">lustre_msg_get_type()</a>, <a class="el" href="pack__generic_8c_source.html#l01439">lustre_msg_set_status()</a>, <a class="el" href="lustre__idl_8h_source.html#l01160">MSG_VERSION_REPLAY</a>, <a class="el" href="lustre__idl_8h_source.html#l01209">OBD_CONNECT_MDS_MDS</a>, <a class="el" href="lustre__net_8h_source.html#l00508">ptlrpc_replay_async_args::praa_old_state</a>, <a class="el" href="lustre__net_8h_source.html#l00509">ptlrpc_replay_async_args::praa_old_status</a>, <a class="el" href="packet-lustre_8c_source.html#l00360">PTL_RPC_MSG_ERR</a>, <a class="el" href="lustre__net_8h_source.html#l02466">ptlrpc_client_replied()</a>, <a class="el" href="lustre__net_8h_source.html#l02502">ptlrpc_client_wake_req()</a>, <a class="el" href="import_8c_source.html#l00648">ptlrpc_connect_import()</a>, <a class="el" href="client_8c_source.html#l02585">ptlrpc_free_request()</a>, <a class="el" href="import_8c_source.html#l01449">ptlrpc_import_recovery_state_machine()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_err</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, and <a class="el" href="lustre__net_8h_source.html#l01034">ptlrpc_request::rq_transno</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l03006">ptlrpc_replay_req()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ff637b549105e75326e7510745c4460"></a><!-- doxytag: member="client.c::ptlrpc_request_alloc_internal" ref="a4ff637b549105e75326e7510745c4460" args="(struct obd_import *imp, struct ptlrpc_request_pool *pool, const struct req_format *format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* ptlrpc_request_alloc_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structreq__format.html">req_format</a> *&nbsp;</td>
          <td class="paramname"> <em>format</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for creating a request. </p>
<p>Calls __ptlrpc_request_alloc to allocate new request sturcture and inits buffer structures according to capsule template <em>format</em>. Returns allocated request structure pointer or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00833">833</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00799">__ptlrpc_request_alloc()</a>, <a class="el" href="lustre__req__layout_8h_source.html#l00058">RCL_CLIENT</a>, <a class="el" href="layout_8c_source.html#l01762">req_capsule_init()</a>, <a class="el" href="layout_8c_source.html#l01816">req_capsule_set()</a>, and <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00852">ptlrpc_request_alloc()</a>, and <a class="el" href="client_8c_source.html#l00863">ptlrpc_request_alloc_pool()</a>.</p>

</div>
</div>
<a class="anchor" id="af6ed95facf669fc40ac53a9ffa67cf1b"></a><!-- doxytag: member="client.c::ptlrpc_request_cache_alloc" ref="af6ed95facf669fc40ac53a9ffa67cf1b" args="(gfp_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* ptlrpc_request_cache_alloc </td>
          <td>(</td>
          <td class="paramtype">gfp_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00492">492</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="obd__support_8h_source.html#l00851">OBD_SLAB_ALLOC_PTR_GFP</a>, and <a class="el" href="client_8c_source.html#l00477">request_cache</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00799">__ptlrpc_request_alloc()</a>, <a class="el" href="client_8c_source.html#l00533">ptlrpc_add_rqs_to_pool()</a>, <a class="el" href="service_8c_source.html#l01259">ptlrpc_at_send_early_reply()</a>, <a class="el" href="client_8c_source.html#l03315">ptlrpcd_alloc_work()</a>, <a class="el" href="events_8c_source.html#l00291">request_in_callback()</a>, <a class="el" href="sec_8c_source.html#l01130">sptlrpc_cli_unwrap_early_reply()</a>, and <a class="el" href="sec_8c_source.html#l00926">sptlrpc_import_check_ctx()</a>.</p>

</div>
</div>
<a class="anchor" id="a522ac1657e956ed4312113516aec1e6f"></a><!-- doxytag: member="client.c::ptlrpc_request_cache_fini" ref="a522ac1657e956ed4312113516aec1e6f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_request_cache_fini </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00487">487</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00477">request_cache</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__module_8c_source.html#l00138">ptlrpc_exit()</a>, and <a class="el" href="ptlrpc__module_8c_source.html#l00052">ptlrpc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a62d5a40d5504554ad53443f0ccae0cb2"></a><!-- doxytag: member="client.c::ptlrpc_request_cache_free" ref="a62d5a40d5504554ad53443f0ccae0cb2" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_request_cache_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00500">500</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="obd__support_8h_source.html#l00857">OBD_SLAB_FREE_PTR</a>, and <a class="el" href="client_8c_source.html#l00477">request_cache</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02389">__ptlrpc_free_req()</a>, <a class="el" href="client_8c_source.html#l00533">ptlrpc_add_rqs_to_pool()</a>, <a class="el" href="service_8c_source.html#l01259">ptlrpc_at_send_early_reply()</a>, <a class="el" href="client_8c_source.html#l00509">ptlrpc_free_rq_pool()</a>, <a class="el" href="client_8c_source.html#l00875">ptlrpc_request_free()</a>, <a class="el" href="service_8c_source.html#l00836">ptlrpc_server_free_request()</a>, <a class="el" href="sec_8c_source.html#l01221">sptlrpc_cli_finish_early_reply()</a>, <a class="el" href="sec_8c_source.html#l01130">sptlrpc_cli_unwrap_early_reply()</a>, and <a class="el" href="sec_8c_source.html#l00926">sptlrpc_import_check_ctx()</a>.</p>

</div>
</div>
<a class="anchor" id="adf2f9b7a11e7944536c9232a455bb43a"></a><!-- doxytag: member="client.c::ptlrpc_request_cache_init" ref="adf2f9b7a11e7944536c9232a455bb43a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_request_cache_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00479">479</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00477">request_cache</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__module_8c_source.html#l00052">ptlrpc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ab780f18489fd5668f8437d66d9ddad52"></a><!-- doxytag: member="client.c::ptlrpc_resend_req" ref="ab780f18489fd5668f8437d66d9ddad52" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_resend_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule previously sent request for resend. </p>
<p>For bulk requests we assign new xid (to avoid problems with lost replies and therefore several transfers landing into same buffer from different sending attempts). </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02717">2717</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="pack__generic_8c_source.html#l01320">lustre_msg_set_handle()</a>, <a class="el" href="lustre__net_8h_source.html#l02466">ptlrpc_client_replied()</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="recover_8c_source.html#l00196">ptlrpc_resend()</a>.</p>

</div>
</div>
<a class="anchor" id="a2682790d1283c97c02274330db6fa61d"></a><!-- doxytag: member="client.c::ptlrpc_save_versions" ref="a2682790d1283c97c02274330db6fa61d" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_save_versions </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>save pre-versions of objects into request for replay. </p>
<p>Versions are obtained from server reply. used for VBR. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01254">1254</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00047">LPX64</a>, <a class="el" href="lustre__idl_8h_source.html#l01047">lustre_msg</a>, <a class="el" href="pack__generic_8c_source.html#l00829">lustre_msg_get_flags()</a>, <a class="el" href="pack__generic_8c_source.html#l01062">lustre_msg_get_versions()</a>, <a class="el" href="pack__generic_8c_source.html#l01406">lustre_msg_set_versions()</a>, <a class="el" href="lustre__idl_8h_source.html#l01154">MSG_REPLAY</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01297">after_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="af8657be69f4248389a7d148f254ee45d"></a><!-- doxytag: member="client.c::ptlrpc_send_new_req" ref="af8657be69f4248389a7d148f254ee45d" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_send_new_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to send request <em>req</em> over the <a class="el" href="structnetwork.html">network</a> for the first time Also adjusts request phase. </p>
<p>Returns 0 on success or error code. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01494">1494</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="linux_2libcfs_8h_source.html#l00146">current_comm</a>, <a class="el" href="linux_2libcfs_8h_source.html#l00145">current_pid</a>, <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="libcfs__debug_8h_source.html#l00149">D_RPCTRACE</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="sec__bulk_8c_source.html#l00528">get_free_pages_in_pool()</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00185">obd_import::imp_delayed_list</a>, <a class="el" href="lustre__import_8h_source.html#l00237">obd_import::imp_generation</a>, <a class="el" href="lustre__import_8h_source.html#l00220">obd_import::imp_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00184">obd_import::imp_sending_list</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="nidstr_8h_source.html#l00077">libcfs_nid2str()</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00045">LPU64</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="pack__generic_8c_source.html#l01098">lustre_msg_get_status()</a>, <a class="el" href="pack__generic_8c_source.html#l01362">lustre_msg_set_last_xid()</a>, <a class="el" href="pack__generic_8c_source.html#l01439">lustre_msg_set_status()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>, <a class="el" href="obd_8h_source.html#l00598">obd_device::obd_uuid</a>, <a class="el" href="sec__bulk_8c_source.html#l00537">pool_is_at_full_capacity()</a>, <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="client_8c_source.html#l01120">ptlrpc_import_delay_req()</a>, <a class="el" href="lustre__import_8h_source.html#l00111">ptlrpc_import_state_name()</a>, <a class="el" href="client_8c_source.html#l01272">ptlrpc_known_replied_xid()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00396">ptlrpc_req_is_connect()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00406">ptlrpc_req_is_disconnect()</a>, <a class="el" href="lustre__net_8h_source.html#l02428">ptlrpc_rqphase_move()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_err</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_generation_set</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_net_err</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00720">RQ_PHASE_INTERPRET</a>, <a class="el" href="lustre__net_8h_source.html#l00717">RQ_PHASE_NEW</a>, <a class="el" href="lustre__net_8h_source.html#l00718">RQ_PHASE_RPC</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_wait_ctx</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_waiting</a>, <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>, <a class="el" href="sec_8c_source.html#l00675">sptlrpc_req_refresh_ctx()</a>, and <a class="el" href="lustre__user_8h_source.html#l00492">obd_uuid::uuid</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, <a class="el" href="client_8c_source.html#l01050">ptlrpc_set_add_req()</a>, and <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>.</p>

</div>
</div>
<a class="anchor" id="a6978d733f46bb41c9ac9b5195aff2837"></a><!-- doxytag: member="client.c::ptlrpc_set_add_new_req" ref="a6978d733f46bb41c9ac9b5195aff2837" args="(struct ptlrpcd_ctl *pc, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_set_add_new_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a request to a request with dedicated server thread and wake the thread to make any necessary processing. </p>
<p>Currently only used for <a class="el" href="structptlrpcd.html">ptlrpcd</a>. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01079">1079</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00152">cfs_time_current()</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__net_8h_source.html#l01930">LIOD_STOP</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="lustre__net_8h_source.html#l01870">ptlrpcd_ctl::pc_flags</a>, <a class="el" href="lustre__net_8h_source.html#l01910">ptlrpcd_ctl::pc_npartners</a>, <a class="el" href="lustre__net_8h_source.html#l01906">ptlrpcd_ctl::pc_partners</a>, <a class="el" href="lustre__net_8h_source.html#l01886">ptlrpcd_ctl::pc_set</a>, and <a class="el" href="lustre__net_8h_source.html#l00579">ptlrpc_request_set::set_waitq</a>.</p>

<p>Referenced by <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>.</p>

</div>
</div>
<a class="anchor" id="ad93d8710b114f9917eda916dd057035e"></a><!-- doxytag: member="client.c::ptlrpc_set_bulk_mbits" ref="ad93d8710b114f9917eda916dd057035e" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_set_bulk_mbits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If request has a new allocated XID (new request or EINPROGRESS resend), use this XID as matchbits of bulk, otherwise allocate a new matchbits for request to ensure previous bulk fails and avoid problems with lost replies and therefore several transfers landing into the same buffer from different sending attempts. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l03196">3196</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="lustre__net_8h_source.html#l01448">ptlrpc_bulk_desc::bd_import</a>, <a class="el" href="lustre__net_8h_source.html#l01453">ptlrpc_bulk_desc::bd_iov_count</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00148">D_HA</a>, <a class="el" href="lustre__import_8h_source.html#l00316">obd_import::imp_connect_data</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00450">LNET_MAX_IOV</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00045">LPU64</a>, <a class="el" href="lustre__idl_8h_source.html#l01250">OBD_CONNECT_BULK_MBITS</a>, <a class="el" href="lustre__idl_8h_source.html#l01336">obd_connect_data::ocd_connect_flags</a>, <a class="el" href="client_8c_source.html#l03177">ptlrpc_next_xid()</a>, <a class="el" href="lustre__net_8h_source.html#l01038">ptlrpc_request::rq_mbits</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_resend</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a571f24a883004b3deb6c6706e22972"></a><!-- doxytag: member="client.c::ptlrpc_set_next_timeout" ref="a1a571f24a883004b3deb6c6706e22972" args="(struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_set_next_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the smallest timeout in the set; this does NOT set a timeout. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02207">2207</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00242">list_entry</a>, <a class="el" href="list_8h_source.html#l00253">list_for_each</a>, <a class="el" href="createmany_8c_source.html#l00069">now()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00719">RQ_PHASE_BULK</a>, <a class="el" href="lustre__net_8h_source.html#l00717">RQ_PHASE_NEW</a>, <a class="el" href="lustre__net_8h_source.html#l00718">RQ_PHASE_RPC</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_resend</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00861">rq_set_chain</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_timedout</a>, <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_wait_ctx</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_waiting</a>, and <a class="el" href="gnilnd__modparams_8c_source.html#l00052">timeout</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>, and <a class="el" href="ptlrpcd_8c_source.html#l00427">ptlrpcd()</a>.</p>

</div>
</div>
<a class="anchor" id="a55c3422e2f7b2aefd2d79bc53c91e14b"></a><!-- doxytag: member="client.c::ptlrpc_set_producer" ref="a55c3422e2f7b2aefd2d79bc53c91e14b" args="(struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_set_producer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l01612">1612</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e6cdd967c36c6d238e9943e6d205c79"></a><!-- doxytag: member="client.c::ptlrpc_unregister_reply" ref="a9e6cdd967c36c6d238e9943e6d205c79" args="(struct ptlrpc_request *request, int async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpc_unregister_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>async</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disengage the client's reply buffer from the <a class="el" href="structnetwork.html">network</a> NB does _NOT_ unregister any client-side bulk. </p>
<p>IDEMPOTENT, but _not_ safe against concurrent callers. The request owner (i.e. the thread doing the I/O) must call... Returns 0 on success or 1 if unregistering cannot be made. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02512">2512</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="linux-time_8h_source.html#l00182">cfs_time_seconds()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00139">D_WARNING</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__lib_8h_source.html#l00329">l_wait_event</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lib-md_8c_source.html#l00417">LNetMDUnlink()</a>, <a class="el" href="obd__support_8h_source.html#l00151">LONG_UNLINK</a>, <a class="el" href="lustre__lib_8h_source.html#l00180">LWI_TIMEOUT_INTERVAL</a>, <a class="el" href="obd__support_8h_source.html#l00619">OBD_FAIL_CHECK</a>, <a class="el" href="obd__support_8h_source.html#l00407">OBD_FAIL_PTLRPC_LONG_REPL_UNLINK</a>, <a class="el" href="lustre__net_8h_source.html#l02485">ptlrpc_client_recv_or_unlink()</a>, <a class="el" href="lustre__net_8h_source.html#l02428">ptlrpc_rqphase_move()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01011">ptlrpc_request::rq_next_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00722">RQ_PHASE_UNREGISTERING</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_receiving_reply</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_reply_unlinked</a>, and <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_req_unlinked</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="client_8c_source.html#l02050">ptlrpc_expire_one_request()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e976a291c91cb72637176dd5eea4bf8"></a><!-- doxytag: member="client.c::ptlrpcd_add_work_req" ref="a6e976a291c91cb72637176dd5eea4bf8" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpcd_add_work_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03270">3270</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="lustre__import_8h_source.html#l00237">obd_import::imp_generation</a>, <a class="el" href="class__obd_8c_source.html#l00083">obd_timeout</a>, <a class="el" href="client_8c_source.html#l03177">ptlrpc_next_xid()</a>, <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>, <a class="el" href="lustre__net_8h_source.html#l01119">ptlrpc_request::rq_deadline</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01011">ptlrpc_request::rq_next_phase</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l00721">RQ_PHASE_COMPLETE</a>, <a class="el" href="lustre__net_8h_source.html#l00720">RQ_PHASE_INTERPRET</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l03362">ptlrpcd_queue_work()</a>, and <a class="el" href="client_8c_source.html#l03285">work_interpreter()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f65c1f73ee8212ca6a16e1eac64ac08"></a><!-- doxytag: member="client.c::ptlrpcd_check_work" ref="a4f65c1f73ee8212ca6a16e1eac64ac08" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ptlrpcd_check_work </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03307">3307</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__req__layout_8h_source.html#l00068">req_capsule::rc_fmt</a>, and <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="client_8c_source.html#l03285">work_interpreter()</a>.</p>

</div>
</div>
<a class="anchor" id="a23aafe587f2688c690d08b2a0e534790"></a><!-- doxytag: member="client.c::unpack_reply" ref="a23aafe587f2688c690d08b2a0e534790" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int unpack_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00397">397</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00146">D_ERROR</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="pack__generic_8c_source.html#l00661">lustre_unpack_rep_ptlrpc_body()</a>, <a class="el" href="lustre__idl_8h_source.html#l01125">MSG_PTLRPC_BODY_OFF</a>, <a class="el" href="pack__generic_8c_source.html#l00611">ptlrpc_unpack_rep_msg()</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01026">ptlrpc_request::rq_replen</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, <a class="el" href="lustre__sec_8h_source.html#l00152">SPTLRPC_FLVR_POLICY</a>, and <a class="el" href="lustre__sec_8h_source.html#l00088">SPTLRPC_POLICY_NULL</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01297">after_reply()</a>, and <a class="el" href="client_8c_source.html#l00421">ptlrpc_at_recv_early_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e58537db5ff163c5f186d08e209a245"></a><!-- doxytag: member="client.c::work_interpreter" ref="a9e58537db5ff163c5f186d08e209a245" args="(const struct lu_env *env, struct ptlrpc_request *req, void *data, int rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int work_interpreter </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03285">3285</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="structptlrpc__work__async__args.html#a305080bc302e39bc0c74ef07bf94dd89">ptlrpc_work_async_args::cb</a>, <a class="el" href="client_8c_source.html#l03267">ptlrpc_work_async_args::cbdata</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="client_8c_source.html#l03270">ptlrpcd_add_work_req()</a>, <a class="el" href="client_8c_source.html#l03307">ptlrpcd_check_work()</a>, and <a class="el" href="lustre__net_8h_source.html#l01016">ptlrpc_request::rq_refcount</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l03315">ptlrpcd_alloc_work()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a2bd21382b3b02652a0be8715ccb3d625"></a><!-- doxytag: member="client.c::ptlrpc_last_xid" ref="a2bd21382b3b02652a0be8715ccb3d625" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="client_8c.html#a2bd21382b3b02652a0be8715ccb3d625">ptlrpc_last_xid</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03128">3128</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

</div>
</div>
<a class="anchor" id="add2bc631499eb5b705b215ac894a018a"></a><!-- doxytag: member="client.c::ptlrpc_last_xid_lock" ref="add2bc631499eb5b705b215ac894a018a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spinlock_t <a class="el" href="ptlrpc__module_8c.html#add2bc631499eb5b705b215ac894a018a">ptlrpc_last_xid_lock</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03129">3129</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad2df9ba379d2443dbdd19139c6f57b7d"></a><!-- doxytag: member="client.c::request_cache" ref="ad2df9ba379d2443dbdd19139c6f57b7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct kmem_cache* <a class="el" href="client_8c.html#ad2df9ba379d2443dbdd19139c6f57b7d">request_cache</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l00477">477</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00492">ptlrpc_request_cache_alloc()</a>, <a class="el" href="client_8c_source.html#l00487">ptlrpc_request_cache_fini()</a>, <a class="el" href="client_8c_source.html#l00500">ptlrpc_request_cache_free()</a>, and <a class="el" href="client_8c_source.html#l00479">ptlrpc_request_cache_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a417af1d347a74240bb697d4f0655c29b"></a><!-- doxytag: member="client.c::worker_format" ref="a417af1d347a74240bb697d4f0655c29b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="client_8c.html#a417af1d347a74240bb697d4f0655c29b">worker_format</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="client_8c_source.html#l03305">3305</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:50 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
