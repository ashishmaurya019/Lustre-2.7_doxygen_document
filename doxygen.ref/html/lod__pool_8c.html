<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/lod/lod_pool.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/lod/lod_pool.c File Reference</h1><code>#include &lt;<a class="el" href="libcfs_8h_source.html">libcfs/libcfs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="obd_8h_source.html">obd.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="lod__internal_8h_source.html">lod_internal.h</a>&quot;</code><br/>

<p><a href="lod__pool_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlod__pool__iterator.html">lod_pool_iterator</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>&nbsp;&nbsp;&nbsp;S_LOV</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#ac611d04d8b780ca53d1e4384a199411f">pool_tgt</a>(_p, _i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a74776e86adbb0e52a86e0df5d13ea7e6">POOL_IT_MAGIC</a>&nbsp;&nbsp;&nbsp;0xB001CEA0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#af861452f822e1e3d6274fb9b9e81a633">POOL_INIT_COUNT</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the pool data structures at startup.  <a href="#af861452f822e1e3d6274fb9b9e81a633"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a06f0fb7841b08c2903761e194661f789">pool_getref</a> (struct <a class="el" href="structpool__desc.html">pool_desc</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference on the specified pool.  <a href="#a06f0fb7841b08c2903761e194661f789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a1c485560de66ce4213ead25955446b17">lod_pool_putref</a> (struct <a class="el" href="structpool__desc.html">pool_desc</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop a reference on the specified pool and free its memory if needed.  <a href="#a1c485560de66ce4213ead25955446b17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a673a758b9172d99d0f897d0f21f43b75">pool_putref_locked</a> (struct <a class="el" href="structpool__desc.html">pool_desc</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop the refcount in cases where the caller holds a spinlock.  <a href="#a673a758b9172d99d0f897d0f21f43b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static __u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a9bf5114e691ab53f89240552e2b92698">pool_hashfn</a> (struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *hash_body, const void *key, unsigned mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash the pool name for use by the <a class="el" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> handlers.  <a href="#a9bf5114e691ab53f89240552e2b92698"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a1ea2d56eab78b9a73e98c0c33b4c4db0">pool_key</a> (struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the actual key (pool name) from the hashed <em>hnode</em>.  <a href="#a1ea2d56eab78b9a73e98c0c33b4c4db0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a1f04a4c167824eda906f1941378442d0">pool_hashkey_keycmp</a> (const void *key, struct <a class="el" href="structhlist__node.html">hlist_node</a> *compared)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the specified hash key matches the hash node.  <a href="#a1f04a4c167824eda906f1941378442d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a8761a765d566cfb21ca464450267070e">pool_hashobject</a> (struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the actual pool data structure from the hash table entry.  <a href="#a8761a765d566cfb21ca464450267070e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a2d15e2b4d125ff7f7b29bb40a019a134">pool_hashrefcount_get</a> (struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *hs, struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a36613f3ccaf392cfa511bae9a8fafac6">pool_hashrefcount_put_locked</a> (struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *hs, struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a48aba6b5fd7228b3b0607fbbb186d714">pool_proc_next</a> (struct seq_file *seq, void *v, loff_t *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next configured target within one pool for seq_file iteration.  <a href="#a48aba6b5fd7228b3b0607fbbb186d714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a536e66dda7929b5cbb40c9b9a8fecfc6">pool_proc_start</a> (struct seq_file *seq, loff_t *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start seq_file iteration via /proc for a single pool.  <a href="#a536e66dda7929b5cbb40c9b9a8fecfc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#aa0de3f05bf6cf48061b4189f793c014a">pool_proc_stop</a> (struct seq_file *seq, void *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish seq_file iteration for a single pool.  <a href="#aa0de3f05bf6cf48061b4189f793c014a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a6d3e838bad8804086770637dc06c0353">pool_proc_show</a> (struct seq_file *seq, void *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out one target entry from the pool for seq_file iteration.  <a href="#a6d3e838bad8804086770637dc06c0353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a2e4e7acd4df0efd345b41293bf44f673">pool_proc_open</a> (struct inode *inode, struct file *file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new /proc file for seq_file iteration of targets in one pool.  <a href="#a2e4e7acd4df0efd345b41293bf44f673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a2635fac975d0de8a4d6ceaba75051eda">lod_dump_pool</a> (int level, struct <a class="el" href="structpool__desc.html">pool_desc</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump the pool target list into the Lustre debug log.  <a href="#a2635fac975d0de8a4d6ceaba75051eda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#aeebb7bbfebfd5aa9155e5f886f7a9b54">lod_ost_pool_init</a> (struct <a class="el" href="structost__pool.html">ost_pool</a> *<a class="el" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a>, unsigned int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#adbc089920b13fc4cea3cb470319a6b0f">lod_ost_pool_extend</a> (struct <a class="el" href="structost__pool.html">ost_pool</a> *<a class="el" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a>, unsigned int min_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase the op_array size to hold more targets in this pool.  <a href="#adbc089920b13fc4cea3cb470319a6b0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a62f8ccafd2a84d0276f4ce68e199034b">lod_ost_pool_add</a> (struct <a class="el" href="structost__pool.html">ost_pool</a> *<a class="el" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a>, __u32 idx, unsigned int min_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new target to an existing pool.  <a href="#a62f8ccafd2a84d0276f4ce68e199034b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#adb9e2dc6c66aaf4d7c42c8de2b79c104">lod_ost_pool_remove</a> (struct <a class="el" href="structost__pool.html">ost_pool</a> *<a class="el" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a>, __u32 idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an existing pool from the system.  <a href="#adb9e2dc6c66aaf4d7c42c8de2b79c104"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a621d46b5a406a380656cd36827fd1fe2">lod_ost_pool_free</a> (struct <a class="el" href="structost__pool.html">ost_pool</a> *<a class="el" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the pool after it was emptied and removed from /proc.  <a href="#a621d46b5a406a380656cd36827fd1fe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#ac6fc44bfd045a27ab59c17185443c46a">lod_pool_new</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, char *<a class="el" href="llapi__layout__test_8c.html#a9d096844ad7d6672fe415306cd352062">poolname</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new pool for the specified device.  <a href="#ac6fc44bfd045a27ab59c17185443c46a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a6275dc528c9d9e9e83e762bc650bd75f">lod_pool_del</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, char *<a class="el" href="llapi__layout__test_8c.html#a9d096844ad7d6672fe415306cd352062">poolname</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the named pool from the OBD device.  <a href="#a6275dc528c9d9e9e83e762bc650bd75f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a0cab6622ab68dbb7af618ea38d371403">lod_pool_add</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, char *<a class="el" href="llapi__layout__test_8c.html#a9d096844ad7d6672fe415306cd352062">poolname</a>, char *ostname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a single target device to the named pool.  <a href="#a0cab6622ab68dbb7af618ea38d371403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a84ae23967718a25e3168650a991f65c9">lod_pool_remove</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, char *<a class="el" href="llapi__layout__test_8c.html#a9d096844ad7d6672fe415306cd352062">poolname</a>, char *ostname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the named target from the specified pool.  <a href="#a84ae23967718a25e3168650a991f65c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a4e717f312def8139f51af44c17a9afd5">lod_check_index_in_pool</a> (__u32 idx, struct <a class="el" href="structpool__desc.html">pool_desc</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the specified target exists in the pool.  <a href="#a4e717f312def8139f51af44c17a9afd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a286e56927560983374c2f7b9224feda2">lod_find_pool</a> (struct <a class="el" href="structlod__device.html">lod_device</a> *lod, char *<a class="el" href="llapi__layout__test_8c.html#a9d096844ad7d6672fe415306cd352062">poolname</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the pool descriptor for the specified pool and return it with a reference to the caller if found.  <a href="#a286e56927560983374c2f7b9224feda2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcfs__hash__ops.html">cfs_hash_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a482f6f8430424db32b75a1344cb3eaea">pool_hash_operations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct seq_operations&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a78164d0ba4682a7f995a63e2f3641134">pool_proc_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct file_operations&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lod__pool_8c.html#a183ceba94cb42c36e82da892a3a26a54">pool_proc_operations</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="lod_pool.c::DEBUG_SUBSYSTEM" ref="abda60744d497fcfe370cfd6b2d65c7ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SUBSYSTEM&nbsp;&nbsp;&nbsp;S_LOV</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00058">58</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="af861452f822e1e3d6274fb9b9e81a633"></a><!-- doxytag: member="lod_pool.c::POOL_INIT_COUNT" ref="af861452f822e1e3d6274fb9b9e81a633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_INIT_COUNT&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the pool data structures at startup. </p>
<p>Allocate and initialize the pool data structures with the specified array size. If pool count is not specified (<em>count</em> == 0), then POOL_INIT_COUNT will be used. Allocating a non-zero initial array size avoids the need to reallocate as new pools are added.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op</em>&nbsp;</td><td>pool structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>initial size of the target op_array[] array</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>indicates successful pool initialization </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00467">467</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00468">lod_ost_pool_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a74776e86adbb0e52a86e0df5d13ea7e6"></a><!-- doxytag: member="lod_pool.c::POOL_IT_MAGIC" ref="a74776e86adbb0e52a86e0df5d13ea7e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_IT_MAGIC&nbsp;&nbsp;&nbsp;0xB001CEA0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00229">229</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00252">pool_proc_next()</a>, <a class="el" href="lod__pool_8c_source.html#l00363">pool_proc_show()</a>, <a class="el" href="lod__pool_8c_source.html#l00293">pool_proc_start()</a>, and <a class="el" href="lod__pool_8c_source.html#l00344">pool_proc_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="ac611d04d8b780ca53d1e4384a199411f"></a><!-- doxytag: member="lod_pool.c::pool_tgt" ref="ac611d04d8b780ca53d1e4384a199411f" args="(_p, _i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pool_tgt</td>
          <td>(</td>
          <td class="paramtype">_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="lod__internal_8h.html#a48a72349146d5033ba67b2f2326a3e44">OST_TGT</a>(<a class="code" href="lod__internal_8h.html#a463d5c14687298675a09ddb5b0a6a22b">lu2lod_dev</a>((_p)-&gt;pool_lobd-&gt;obd_lu_dev), \
                                 (_p)-&gt;pool_obds.op_array[_i])
</pre></div>
<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00064">64</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00431">lod_dump_pool()</a>, <a class="el" href="lov__pool_8c_source.html#l00301">lov_dump_pool()</a>, and <a class="el" href="lod__pool_8c_source.html#l00363">pool_proc_show()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4e717f312def8139f51af44c17a9afd5"></a><!-- doxytag: member="lod_pool.c::lod_check_index_in_pool" ref="a4e717f312def8139f51af44c17a9afd5" args="(__u32 idx, struct pool_desc *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_check_index_in_pool </td>
          <td>(</td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the specified target exists in the pool. </p>
<p>The caller may not have a reference on <em>pool</em> if it got the pool without calling <a class="el" href="lod__internal_8h.html#a286e56927560983374c2f7b9224feda2" title="Find the pool descriptor for the specified pool and return it with a reference to...">lod_find_pool()</a> (e.g. directly from the lod pool list)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>Target index to check </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool in which to check if target is added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>successfully found index in <em>pool</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error if device not found in <em>pool</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00876">876</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__pool_8c_source.html#l00077">pool_getref()</a>, <a class="el" href="lod__internal_8h_source.html#l00081">pool_tgt_array</a>, <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>, and <a class="el" href="lod__internal_8h_source.html#l00082">pool_tgt_rw_sem</a>.</p>

<p>Referenced by <a class="el" href="lod__qos_8c_source.html#l01696">lod_qos_parse_config()</a>, and <a class="el" href="lod__lov_8c_source.html#l01097">lod_verify_striping()</a>.</p>

</div>
</div>
<a class="anchor" id="a2635fac975d0de8a4d6ceaba75051eda"></a><!-- doxytag: member="lod_pool.c::lod_dump_pool" ref="a2635fac975d0de8a4d6ceaba75051eda" args="(int level, struct pool_desc *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lod_dump_pool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the pool target list into the Lustre debug log. </p>
<p>This is a debugging function to allow dumping the list of targets in <em>pool</em> to the Lustre kernel debug log at the given <em>level</em>.</p>
<p>This is not currently called by any existing code, but can be called from within gdb/crash to display the contents of the pool, or from code under development.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>Lustre debug level (D_INFO, D_WARN, D_ERROR, etc) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pool</em>&nbsp;</td><td>pool descriptor to be dumped </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00431">431</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lustre__user_8h_source.html#l00355">LOV_POOLNAMEF</a>, <a class="el" href="lustre__user_8h_source.html#l00513">obd_uuid2str()</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, <a class="el" href="lod__pool_8c_source.html#l00077">pool_getref()</a>, <a class="el" href="lod__internal_8h_source.html#l00069">pool_desc::pool_name</a>, <a class="el" href="lod__internal_8h_source.html#l00070">pool_desc::pool_obds</a>, <a class="el" href="lod__pool_8c_source.html#l00064">pool_tgt</a>, <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>, and <a class="el" href="lod__internal_8h_source.html#l00082">pool_tgt_rw_sem</a>.</p>

</div>
</div>
<a class="anchor" id="a286e56927560983374c2f7b9224feda2"></a><!-- doxytag: member="lod_pool.c::lod_find_pool" ref="a286e56927560983374c2f7b9224feda2" args="(struct lod_device *lod, char *poolname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpool__desc.html">pool_desc</a>* lod_find_pool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlod__device.html">lod_device</a> *&nbsp;</td>
          <td class="paramname"> <em>lod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the pool descriptor for the specified pool and return it with a reference to the caller if found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lod</em>&nbsp;</td><td>LOD on which the pools are configured </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolname</em>&nbsp;</td><td>NUL-terminated name of the pool</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>to pool descriptor on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>if <em>poolname</em> could not be found or poolname is empty </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00909">909</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="hash_8c_source.html#l01346">cfs_hash_lookup()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00153">D_CONFIG</a>, <a class="el" href="lustre__export_8h_source.html#l00209">obd_export::exp_obd</a>, <a class="el" href="lod__internal_8h_source.html#l00169">lod_device::lod_child_exp</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__internal_8h_source.html#l00206">lod_device::lod_pools_hash_body</a>, <a class="el" href="lustre__user_8h_source.html#l00355">LOV_POOLNAMEF</a>, <a class="el" href="obd_8h_source.html#l00599">obd_device::obd_name</a>, and <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>.</p>

<p>Referenced by <a class="el" href="lod__qos_8c_source.html#l01375">lod_alloc_qos()</a>, <a class="el" href="lod__qos_8c_source.html#l00933">lod_alloc_rr()</a>, <a class="el" href="lod__qos_8c_source.html#l01185">lod_alloc_specific()</a>, <a class="el" href="lod__qos_8c_source.html#l01696">lod_qos_parse_config()</a>, and <a class="el" href="lod__lov_8c_source.html#l01097">lod_verify_striping()</a>.</p>

</div>
</div>
<a class="anchor" id="a62f8ccafd2a84d0276f4ce68e199034b"></a><!-- doxytag: member="lod_pool.c::lod_ost_pool_add" ref="a62f8ccafd2a84d0276f4ce68e199034b" args="(struct ost_pool *op, __u32 idx, unsigned int min_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_ost_pool_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structost__pool.html">ost_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>min_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new target to an existing pool. </p>
<p>Add a new target device to the pool previously created and returned by <a class="el" href="lod__internal_8h.html#ac6fc44bfd045a27ab59c17185443c46a" title="Allocate a new pool for the specified device.">lod_pool_new()</a>. Each target can only be in each pool at most one time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op</em>&nbsp;</td><td>target pool to add new entry </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>pool index number to add to the <em>op</em> array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_count</em>&nbsp;</td><td>minimum number of entries to expect in the pool</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if target could be added to the pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error if target <em>idx</em> was not added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00537">537</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lod__pool_8c_source.html#l00500">lod_ost_pool_extend()</a>, <a class="el" href="obd_8h_source.html#l00349">ost_pool::op_array</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, and <a class="el" href="obd_8h_source.html#l00353">ost_pool::op_rw_sem</a>.</p>

<p>Referenced by <a class="el" href="lod__lov_8c_source.html#l00207">lod_add_device()</a>, and <a class="el" href="lod__pool_8c_source.html#l00766">lod_pool_add()</a>.</p>

</div>
</div>
<a class="anchor" id="adbc089920b13fc4cea3cb470319a6b0f"></a><!-- doxytag: member="lod_pool.c::lod_ost_pool_extend" ref="adbc089920b13fc4cea3cb470319a6b0f" args="(struct ost_pool *op, unsigned int min_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_ost_pool_extend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structost__pool.html">ost_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>min_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase the op_array size to hold more targets in this pool. </p>
<p>The size is increased to at least <em>min_count</em>, but may be larger for an existing pool since -&gt;op_array[] is growing exponentially. Caller must hold write op_rwlock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op</em>&nbsp;</td><td>pool structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_count</em>&nbsp;</td><td>minimum number of entries to handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00500">500</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lnet_2utils_2debug_8c_source.html#l00068">max</a>, <a class="el" href="obd__support_8h_source.html#l00708">OBD_ALLOC</a>, <a class="el" href="obd__support_8h_source.html#l00776">OBD_FREE</a>, <a class="el" href="obd_8h_source.html#l00349">ost_pool::op_array</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, and <a class="el" href="obd_8h_source.html#l00352">ost_pool::op_size</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00537">lod_ost_pool_add()</a>, and <a class="el" href="lod__qos_8c_source.html#l00559">lod_qos_calc_rr()</a>.</p>

</div>
</div>
<a class="anchor" id="a621d46b5a406a380656cd36827fd1fe2"></a><!-- doxytag: member="lod_pool.c::lod_ost_pool_free" ref="a621d46b5a406a380656cd36827fd1fe2" args="(struct ost_pool *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_ost_pool_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structost__pool.html">ost_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the pool after it was emptied and removed from /proc. </p>
<p>Note that all of the child/target entries referenced by this pool must have been removed by <a class="el" href="lod__internal_8h.html#adb9e2dc6c66aaf4d7c42c8de2b79c104" title="Remove an existing pool from the system.">lod_ost_pool_remove()</a> before it can be deleted from memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op</em>&nbsp;</td><td>pool to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success or if pool was already freed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00611">611</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="obd__support_8h_source.html#l00776">OBD_FREE</a>, <a class="el" href="obd_8h_source.html#l00349">ost_pool::op_array</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, <a class="el" href="obd_8h_source.html#l00353">ost_pool::op_rw_sem</a>, <a class="el" href="obd_8h_source.html#l00352">ost_pool::op_size</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00643">lod_pool_new()</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__lov_8c_source.html#l01372">lod_pools_fini()</a>, and <a class="el" href="lod__lov_8c_source.html#l01280">lod_pools_init()</a>.</p>

</div>
</div>
<a class="anchor" id="aeebb7bbfebfd5aa9155e5f886f7a9b54"></a><!-- doxytag: member="lod_pool.c::lod_ost_pool_init" ref="aeebb7bbfebfd5aa9155e5f886f7a9b54" args="(struct ost_pool *op, unsigned int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_ost_pool_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structost__pool.html">ost_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00468">468</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="obd__support_8h_source.html#l00708">OBD_ALLOC</a>, <a class="el" href="obd_8h_source.html#l00349">ost_pool::op_array</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, <a class="el" href="obd_8h_source.html#l00353">ost_pool::op_rw_sem</a>, <a class="el" href="obd_8h_source.html#l00352">ost_pool::op_size</a>, <a class="el" href="lod__pool_8c_source.html#l00467">POOL_INIT_COUNT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00643">lod_pool_new()</a>, and <a class="el" href="lod__lov_8c_source.html#l01280">lod_pools_init()</a>.</p>

</div>
</div>
<a class="anchor" id="adb9e2dc6c66aaf4d7c42c8de2b79c104"></a><!-- doxytag: member="lod_pool.c::lod_ost_pool_remove" ref="adb9e2dc6c66aaf4d7c42c8de2b79c104" args="(struct ost_pool *op, __u32 idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_ost_pool_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structost__pool.html">ost_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an existing pool from the system. </p>
<p>The specified pool must have previously been allocated by <a class="el" href="lod__internal_8h.html#ac6fc44bfd045a27ab59c17185443c46a" title="Allocate a new pool for the specified device.">lod_pool_new()</a> and not have any target members in the pool. If the removed target is not the last, compact the array to remove empty spaces.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op</em>&nbsp;</td><td>pointer to the original data structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>target index to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00577">577</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="obd_8h_source.html#l00349">ost_pool::op_array</a>, <a class="el" href="obd_8h_source.html#l00351">ost_pool::op_count</a>, <a class="el" href="obd_8h_source.html#l00353">ost_pool::op_rw_sem</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="lod__lov_8c_source.html#l00207">lod_add_device()</a>, <a class="el" href="lod__pool_8c_source.html#l00823">lod_pool_remove()</a>, and <a class="el" href="lod__lov_8c_source.html#l00073">lod_putref()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cab6622ab68dbb7af618ea38d371403"></a><!-- doxytag: member="lod_pool.c::lod_pool_add" ref="a0cab6622ab68dbb7af618ea38d371403" args="(struct obd_device *obd, char *poolname, char *ostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_pool_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__device.html">obd_device</a> *&nbsp;</td>
          <td class="paramname"> <em>obd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>ostname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a single target device to the named pool. </p>
<p>Add the target specified by <em>ostname</em> to the specified <em>poolname</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obd</em>&nbsp;</td><td>OBD device on which to add the pool </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolname</em>&nbsp;</td><td>name of the pool to which to add the target <em>ostname</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ostname</em>&nbsp;</td><td>name of the target device to be added</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if <em>ostname</em> was (previously) added to the named pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00766">766</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="hash_8c_source.html#l01346">cfs_hash_lookup()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00153">D_CONFIG</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lod__internal_8h_source.html#l00391">lod_foreach_ost</a>, <a class="el" href="lod__lov_8c_source.html#l00055">lod_getref()</a>, <a class="el" href="lod__internal_8h_source.html#l00187">lod_device::lod_ost_descs</a>, <a class="el" href="lod__pool_8c_source.html#l00537">lod_ost_pool_add()</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__internal_8h_source.html#l00206">lod_device::lod_pools_hash_body</a>, <a class="el" href="lod__lov_8c_source.html#l00073">lod_putref()</a>, <a class="el" href="lustre__user_8h_source.html#l00355">LOV_POOLNAMEF</a>, <a class="el" href="lod__internal_8h_source.html#l00065">lod_qos_rr::lqr_dirty</a>, <a class="el" href="lod__internal_8h_source.html#l00320">lu2lod_dev()</a>, <a class="el" href="obd_8h_source.html#l00595">obd_device::obd_lu_dev</a>, <a class="el" href="lustre__user_8h_source.html#l00506">obd_str2uuid()</a>, <a class="el" href="lustre__user_8h_source.html#l00495">obd_uuid_equals()</a>, <a class="el" href="lod__internal_8h_source.html#l00146">OST_TGT</a>, <a class="el" href="lod__internal_8h_source.html#l00070">pool_desc::pool_obds</a>, <a class="el" href="lod__internal_8h_source.html#l00072">pool_desc::pool_rr</a>, <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

</div>
</div>
<a class="anchor" id="a6275dc528c9d9e9e83e762bc650bd75f"></a><!-- doxytag: member="lod_pool.c::lod_pool_del" ref="a6275dc528c9d9e9e83e762bc650bd75f" args="(struct obd_device *obd, char *poolname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_pool_del </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__device.html">obd_device</a> *&nbsp;</td>
          <td class="paramname"> <em>obd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the named pool from the OBD device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obd</em>&nbsp;</td><td>OBD device on which pool was previously created </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolname</em>&nbsp;</td><td>name of pool to remove from <em>obd</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on successfully removing the pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error numbers for failures </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00726">726</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="hash_8c_source.html#l01331">cfs_hash_del_key()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="lod__internal_8h_source.html#l00205">lod_device::lod_pool_count</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__internal_8h_source.html#l00206">lod_device::lod_pools_hash_body</a>, <a class="el" href="lprocfs__status_8h_source.html#l00952">lprocfs_remove()</a>, <a class="el" href="lod__internal_8h_source.html#l00320">lu2lod_dev()</a>, <a class="el" href="obd_8h_source.html#l00644">obd_device::obd_dev_lock</a>, <a class="el" href="obd_8h_source.html#l00595">obd_device::obd_lu_dev</a>, <a class="el" href="lod__internal_8h_source.html#l00074">pool_desc::pool_list</a>, <a class="el" href="lod__internal_8h_source.html#l00075">pool_desc::pool_proc_entry</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="lod__lov_8c_source.html#l01372">lod_pools_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6fc44bfd045a27ab59c17185443c46a"></a><!-- doxytag: member="lod_pool.c::lod_pool_new" ref="ac6fc44bfd045a27ab59c17185443c46a" args="(struct obd_device *obd, char *poolname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_pool_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__device.html">obd_device</a> *&nbsp;</td>
          <td class="paramname"> <em>obd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new pool for the specified device. </p>
<p>Allocate a new <a class="el" href="structpool__desc.html">pool_desc</a> structure for the specified <em>new_pool</em> device to create a pool with the given <em>poolname</em>. The new pool structure is created with a single reference, and is freed when the reference count drops to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obd</em>&nbsp;</td><td>Lustre OBD device on which to add a pool iterator </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolname</em>&nbsp;</td><td>the name of the pool to be created</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>in case of success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error code in case of error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00643">643</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="hash_8c_source.html#l01259">cfs_hash_add_unique()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00153">D_CONFIG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="list_8h_source.html#l00316">INIT_HLIST_NODE</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="lod__pool_8c_source.html#l00611">lod_ost_pool_free()</a>, <a class="el" href="lod__pool_8c_source.html#l00468">lod_ost_pool_init()</a>, <a class="el" href="lod__internal_8h_source.html#l00205">lod_device::lod_pool_count</a>, <a class="el" href="lod__internal_8h_source.html#l00207">lod_device::lod_pool_list</a>, <a class="el" href="lod__internal_8h_source.html#l00208">lod_device::lod_pool_proc_entry</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__internal_8h_source.html#l00206">lod_device::lod_pools_hash_body</a>, <a class="el" href="lod__qos_8c_source.html#l00534">lod_qos_rr_init()</a>, <a class="el" href="lustre__user_8h_source.html#l00354">LOV_MAXPOOLNAME</a>, <a class="el" href="lustre__user_8h_source.html#l00355">LOV_POOLNAMEF</a>, <a class="el" href="lprocfs__status_8h_source.html#l00938">lprocfs_add_simple()</a>, <a class="el" href="lprocfs__status_8h_source.html#l00952">lprocfs_remove()</a>, <a class="el" href="lod__internal_8h_source.html#l00064">lod_qos_rr::lqr_pool</a>, <a class="el" href="lod__internal_8h_source.html#l00320">lu2lod_dev()</a>, <a class="el" href="obd__support_8h_source.html#l00710">OBD_ALLOC_PTR</a>, <a class="el" href="obd_8h_source.html#l00644">obd_device::obd_dev_lock</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="obd_8h_source.html#l00595">obd_device::obd_lu_dev</a>, <a class="el" href="obd_8h_source.html#l00599">obd_device::obd_name</a>, <a class="el" href="lod__pool_8c_source.html#l00077">pool_getref()</a>, <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>, <a class="el" href="lod__internal_8h_source.html#l00074">pool_desc::pool_list</a>, <a class="el" href="lod__internal_8h_source.html#l00076">pool_desc::pool_lobd</a>, <a class="el" href="lod__internal_8h_source.html#l00069">pool_desc::pool_name</a>, <a class="el" href="lod__internal_8h_source.html#l00070">pool_desc::pool_obds</a>, <a class="el" href="lod__internal_8h_source.html#l00075">pool_desc::pool_proc_entry</a>, <a class="el" href="lod__pool_8c_source.html#l00411">pool_proc_operations</a>, <a class="el" href="lod__internal_8h_source.html#l00071">pool_desc::pool_refcount</a>, <a class="el" href="lod__internal_8h_source.html#l00072">pool_desc::pool_rr</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="string_8c_source.html#l00058">strlcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c485560de66ce4213ead25955446b17"></a><!-- doxytag: member="lod_pool.c::lod_pool_putref" ref="a1c485560de66ce4213ead25955446b17" args="(struct pool_desc *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lod_pool_putref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop a reference on the specified pool and free its memory if needed. </p>
<p>One reference is held by the LOD OBD device while it is configured, from the time the configuration log defines the pool until the time when it is dropped when the LOD OBD is cleaned up or the pool is deleted. This means that the pool will not be freed while the LOD device is configured, unless it is explicitly destroyed by the sysadmin. The pool structure is freed after the last reference on the structure is released.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pool</em>&nbsp;</td><td>pool descriptor to drop reference on and possibly free </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00095">95</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="list_8h_source.html#l00318">hlist_unhashed()</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="lod__pool_8c_source.html#l00611">lod_ost_pool_free()</a>, <a class="el" href="lod__internal_8h_source.html#l00064">lod_qos_rr::lqr_pool</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>, <a class="el" href="lod__internal_8h_source.html#l00074">pool_desc::pool_list</a>, <a class="el" href="lod__internal_8h_source.html#l00070">pool_desc::pool_obds</a>, <a class="el" href="lod__internal_8h_source.html#l00075">pool_desc::pool_proc_entry</a>, <a class="el" href="lod__internal_8h_source.html#l00071">pool_desc::pool_refcount</a>, and <a class="el" href="lod__internal_8h_source.html#l00072">pool_desc::pool_rr</a>.</p>

<p>Referenced by <a class="el" href="lod__qos_8c_source.html#l01375">lod_alloc_qos()</a>, <a class="el" href="lod__qos_8c_source.html#l00933">lod_alloc_rr()</a>, <a class="el" href="lod__qos_8c_source.html#l01185">lod_alloc_specific()</a>, <a class="el" href="lod__pool_8c_source.html#l00876">lod_check_index_in_pool()</a>, <a class="el" href="lod__pool_8c_source.html#l00431">lod_dump_pool()</a>, <a class="el" href="lod__pool_8c_source.html#l00909">lod_find_pool()</a>, <a class="el" href="lod__pool_8c_source.html#l00766">lod_pool_add()</a>, <a class="el" href="lod__pool_8c_source.html#l00726">lod_pool_del()</a>, <a class="el" href="lod__pool_8c_source.html#l00643">lod_pool_new()</a>, <a class="el" href="lod__pool_8c_source.html#l00823">lod_pool_remove()</a>, <a class="el" href="lod__qos_8c_source.html#l01696">lod_qos_parse_config()</a>, <a class="el" href="lod__lov_8c_source.html#l01097">lod_verify_striping()</a>, <a class="el" href="lod__pool_8c_source.html#l00293">pool_proc_start()</a>, and <a class="el" href="lod__pool_8c_source.html#l00344">pool_proc_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a84ae23967718a25e3168650a991f65c9"></a><!-- doxytag: member="lod_pool.c::lod_pool_remove" ref="a84ae23967718a25e3168650a991f65c9" args="(struct obd_device *obd, char *poolname, char *ostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lod_pool_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__device.html">obd_device</a> *&nbsp;</td>
          <td class="paramname"> <em>obd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>ostname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the named target from the specified pool. </p>
<p>Remove one target named <em>ostname</em> from <em>poolname</em>. The <em>ostname</em> is searched for in the <a class="el" href="structlod__device.html">lod_device</a> lod_ost_bitmap array, to ensure the specified name actually exists in the pool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obd</em>&nbsp;</td><td>OBD device from which to remove <em>poolname</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poolname</em>&nbsp;</td><td>name of the pool to be changed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ostname</em>&nbsp;</td><td>name of the target to remove from <em>poolname</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on successfully removing <em>ostname</em> from the pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>number on error (e.g. <em>ostname</em> not in pool) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00823">823</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="bitmap_8h_source.html#l00116">cfs_foreach_bit</a>, <a class="el" href="hash_8c_source.html#l01346">cfs_hash_lookup()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00153">D_CONFIG</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lod__lov_8c_source.html#l00055">lod_getref()</a>, <a class="el" href="lod__internal_8h_source.html#l00187">lod_device::lod_ost_descs</a>, <a class="el" href="lod__pool_8c_source.html#l00577">lod_ost_pool_remove()</a>, <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__internal_8h_source.html#l00206">lod_device::lod_pools_hash_body</a>, <a class="el" href="lod__lov_8c_source.html#l00073">lod_putref()</a>, <a class="el" href="lustre__user_8h_source.html#l00355">LOV_POOLNAMEF</a>, <a class="el" href="lod__internal_8h_source.html#l00065">lod_qos_rr::lqr_dirty</a>, <a class="el" href="lod__internal_8h_source.html#l00320">lu2lod_dev()</a>, <a class="el" href="obd_8h_source.html#l00595">obd_device::obd_lu_dev</a>, <a class="el" href="lustre__user_8h_source.html#l00506">obd_str2uuid()</a>, <a class="el" href="lustre__user_8h_source.html#l00495">obd_uuid_equals()</a>, <a class="el" href="lod__internal_8h_source.html#l00146">OST_TGT</a>, <a class="el" href="lod__internal_8h_source.html#l00070">pool_desc::pool_obds</a>, <a class="el" href="lod__internal_8h_source.html#l00072">pool_desc::pool_rr</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

</div>
</div>
<a class="anchor" id="a06f0fb7841b08c2903761e194661f789"></a><!-- doxytag: member="lod_pool.c::pool_getref" ref="a06f0fb7841b08c2903761e194661f789" args="(struct pool_desc *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pool_getref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference on the specified pool. </p>
<p>To ensure the pool descriptor is not freed before the caller is finished with it. Any process that is accessing <em>pool</em> directly needs to hold reference on it, including /proc since a userspace thread may be holding the /proc file open and busy in the kernel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pool</em>&nbsp;</td><td>pool descriptor on which to gain reference </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00077">77</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, and <a class="el" href="lod__internal_8h_source.html#l00071">pool_desc::pool_refcount</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00876">lod_check_index_in_pool()</a>, <a class="el" href="lod__pool_8c_source.html#l00431">lod_dump_pool()</a>, <a class="el" href="lod__pool_8c_source.html#l00643">lod_pool_new()</a>, <a class="el" href="lod__pool_8c_source.html#l00199">pool_hashrefcount_get()</a>, and <a class="el" href="lod__pool_8c_source.html#l00293">pool_proc_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bf5114e691ab53f89240552e2b92698"></a><!-- doxytag: member="lod_pool.c::pool_hashfn" ref="a9bf5114e691ab53f89240552e2b92698" args="(struct cfs_hash *hash_body, const void *key, unsigned mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static __u32 pool_hashfn </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *&nbsp;</td>
          <td class="paramname"> <em>hash_body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash the pool name for use by the <a class="el" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> handlers. </p>
<p>Use the standard DJB2 hash function for ASCII strings in Lustre.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hash_body</em>&nbsp;</td><td>hash structure where this key is embedded (unused) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key to be hashed (in this case the pool name) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>bitmask to limit the hash value to the desired size</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>computed</em>&nbsp;</td><td>hash value from <em>key</em> and limited by <em>mask</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00143">143</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__hash_8h_source.html#l00813">cfs_hash_djb2_hash()</a>, <a class="el" href="lustre__user_8h_source.html#l00354">LOV_MAXPOOLNAME</a>, and <a class="el" href="lnet_2utils_2wirecheck_8c_source.html#l00051">strnlen</a>.</p>

</div>
</div>
<a class="anchor" id="a1f04a4c167824eda906f1941378442d0"></a><!-- doxytag: member="lod_pool.c::pool_hashkey_keycmp" ref="a1f04a4c167824eda906f1941378442d0" args="(const void *key, struct hlist_node *compared)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pool_hashkey_keycmp </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>compared</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the specified hash key matches the hash node. </p>
<p>This is needed in case there is a hash key collision, allowing the hash table lookup/iteration to distinguish between the two entries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key (pool name) being searched for </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>compared</em>&nbsp;</td><td>current entry being compared</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if <em>key</em> is the same as the key of <em>compared</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if <em>key</em> is different from the key of <em>compared</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00178">178</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="lustre__user_8h_source.html#l00354">LOV_MAXPOOLNAME</a>, and <a class="el" href="lod__pool_8c_source.html#l00158">pool_key()</a>.</p>

</div>
</div>
<a class="anchor" id="a8761a765d566cfb21ca464450267070e"></a><!-- doxytag: member="lod_pool.c::pool_hashobject" ref="a8761a765d566cfb21ca464450267070e" args="(struct hlist_node *hnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* pool_hashobject </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the actual pool data structure from the hash table entry. </p>
<p>Once the hash table entry is found, extract the pool data from it. The return type of this function is void * because it needs to be assigned to the generic hash operations table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hnode</em>&nbsp;</td><td>hash table entry</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>struct</em>&nbsp;</td><td><a class="el" href="structpool__desc.html">pool_desc</a> for the specified <em>hnode</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00194">194</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00382">hlist_entry</a>, and <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>.</p>

</div>
</div>
<a class="anchor" id="a2d15e2b4d125ff7f7b29bb40a019a134"></a><!-- doxytag: member="lod_pool.c::pool_hashrefcount_get" ref="a2d15e2b4d125ff7f7b29bb40a019a134" args="(struct cfs_hash *hs, struct hlist_node *hnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pool_hashrefcount_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *&nbsp;</td>
          <td class="paramname"> <em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00199">199</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00382">hlist_entry</a>, <a class="el" href="lod__pool_8c_source.html#l00077">pool_getref()</a>, and <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>.</p>

</div>
</div>
<a class="anchor" id="a36613f3ccaf392cfa511bae9a8fafac6"></a><!-- doxytag: member="lod_pool.c::pool_hashrefcount_put_locked" ref="a36613f3ccaf392cfa511bae9a8fafac6" args="(struct cfs_hash *hs, struct hlist_node *hnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pool_hashrefcount_put_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *&nbsp;</td>
          <td class="paramname"> <em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00207">207</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00382">hlist_entry</a>, <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>, and <a class="el" href="lod__pool_8c_source.html#l00119">pool_putref_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea2d56eab78b9a73e98c0c33b4c4db0"></a><!-- doxytag: member="lod_pool.c::pool_key" ref="a1ea2d56eab78b9a73e98c0c33b4c4db0" args="(struct hlist_node *hnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* pool_key </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the actual key (pool name) from the hashed <em>hnode</em>. </p>
<p>Allows extracting the key name when iterating over all hash entries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hnode</em>&nbsp;</td><td>hash node found by lookup or iteration</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char</em>&nbsp;</td><td>array referencing the pool name (no refcount) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00158">158</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00382">hlist_entry</a>, <a class="el" href="lod__internal_8h_source.html#l00073">pool_desc::pool_hash</a>, and <a class="el" href="lod__internal_8h_source.html#l00069">pool_desc::pool_name</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00178">pool_hashkey_keycmp()</a>.</p>

</div>
</div>
<a class="anchor" id="a48aba6b5fd7228b3b0607fbbb186d714"></a><!-- doxytag: member="lod_pool.c::pool_proc_next" ref="a48aba6b5fd7228b3b0607fbbb186d714" args="(struct seq_file *seq, void *v, loff_t *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* pool_proc_next </td>
          <td>(</td>
          <td class="paramtype">struct seq_file *&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next configured target within one pool for seq_file iteration. </p>
<p>Iterator is used to go through the target entries of a single pool (i.e. the list of OSTs configured for a named pool). lpi_idx is the current target index in the pool's op_array[].</p>
<p>The return type is a void * because this function is one of the struct seq_operations methods and must match the function template.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seq</em>&nbsp;</td><td>/proc sequence file iteration tracking structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>unused </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>position within iteration; 0 to number of targets - 1</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>struct</em>&nbsp;</td><td>pool_iterator of the next pool descriptor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00252">252</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="lod__pool_8c_source.html#l00232">lod_pool_iterator::lpi_idx</a>, <a class="el" href="lod__pool_8c_source.html#l00231">lod_pool_iterator::lpi_magic</a>, <a class="el" href="lod__pool_8c_source.html#l00233">lod_pool_iterator::lpi_pool</a>, <a class="el" href="lod__pool_8c_source.html#l00229">POOL_IT_MAGIC</a>, <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>, and <a class="el" href="lod__internal_8h_source.html#l00082">pool_tgt_rw_sem</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00293">pool_proc_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e4e7acd4df0efd345b41293bf44f673"></a><!-- doxytag: member="lod_pool.c::pool_proc_open" ref="a2e4e7acd4df0efd345b41293bf44f673" args="(struct inode *inode, struct file *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pool_proc_open </td>
          <td>(</td>
          <td class="paramtype">struct inode *&nbsp;</td>
          <td class="paramname"> <em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a new /proc file for seq_file iteration of targets in one pool. </p>
<p>Initialize the seq_file private pointer to reference the pool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inode</em>&nbsp;</td><td>inode to store iteration state for /proc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>file descriptor to store iteration methods</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>for success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00399">399</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="lod__pool_8c_source.html#l00381">pool_proc_ops</a>.</p>

</div>
</div>
<a class="anchor" id="a6d3e838bad8804086770637dc06c0353"></a><!-- doxytag: member="lod_pool.c::pool_proc_show" ref="a6d3e838bad8804086770637dc06c0353" args="(struct seq_file *seq, void *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pool_proc_show </td>
          <td>(</td>
          <td class="paramtype">struct seq_file *&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out one target entry from the pool for seq_file iteration. </p>
<p>The currently referenced pool target is given by op_array[lpi_idx].</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seq</em>&nbsp;</td><td>new sequence file structure to initialize </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>(unused) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00363">363</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="lod__pool_8c_source.html#l00232">lod_pool_iterator::lpi_idx</a>, <a class="el" href="lod__pool_8c_source.html#l00231">lod_pool_iterator::lpi_magic</a>, <a class="el" href="lod__pool_8c_source.html#l00233">lod_pool_iterator::lpi_pool</a>, <a class="el" href="lod__internal_8h_source.html#l00122">lod_tgt_desc::ltd_uuid</a>, <a class="el" href="lustre__user_8h_source.html#l00513">obd_uuid2str()</a>, <a class="el" href="lod__pool_8c_source.html#l00229">POOL_IT_MAGIC</a>, <a class="el" href="lod__pool_8c_source.html#l00064">pool_tgt</a>, <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>, and <a class="el" href="lod__internal_8h_source.html#l00082">pool_tgt_rw_sem</a>.</p>

</div>
</div>
<a class="anchor" id="a536e66dda7929b5cbb40c9b9a8fecfc6"></a><!-- doxytag: member="lod_pool.c::pool_proc_start" ref="a536e66dda7929b5cbb40c9b9a8fecfc6" args="(struct seq_file *seq, loff_t *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* pool_proc_start </td>
          <td>(</td>
          <td class="paramtype">struct seq_file *&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start seq_file iteration via /proc for a single pool. </p>
<p>The <em>pos</em> parameter may be non-zero, indicating that the iteration is starting at some offset in the target list. Use the seq_file private field to memorize the iterator so we can free it at <a class="el" href="rename__many_8c.html#a6c0af9f2e97842405fb15ed952ef2976">stop()</a>. Need to restore the private pointer to the pool before freeing it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seq</em>&nbsp;</td><td>new sequence file structure to initialize </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>initial target number at which to start iteration</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initialized</em>&nbsp;</td><td>pool iterator private structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>if <em>pos</em> exceeds the number of targets in <em>pool</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>error number on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00293">293</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__pool_8c_source.html#l00232">lod_pool_iterator::lpi_idx</a>, <a class="el" href="lod__pool_8c_source.html#l00231">lod_pool_iterator::lpi_magic</a>, <a class="el" href="lod__pool_8c_source.html#l00233">lod_pool_iterator::lpi_pool</a>, <a class="el" href="obd__support_8h_source.html#l00710">OBD_ALLOC_PTR</a>, <a class="el" href="lod__pool_8c_source.html#l00077">pool_getref()</a>, <a class="el" href="lod__pool_8c_source.html#l00229">POOL_IT_MAGIC</a>, <a class="el" href="lod__pool_8c_source.html#l00252">pool_proc_next()</a>, and <a class="el" href="lod__internal_8h_source.html#l00080">pool_tgt_count</a>.</p>

</div>
</div>
<a class="anchor" id="aa0de3f05bf6cf48061b4189f793c014a"></a><!-- doxytag: member="lod_pool.c::pool_proc_stop" ref="aa0de3f05bf6cf48061b4189f793c014a" args="(struct seq_file *seq, void *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pool_proc_stop </td>
          <td>(</td>
          <td class="paramtype">struct seq_file *&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish seq_file iteration for a single pool. </p>
<p>Once iteration has been completed, the pool_iterator struct must be freed, and the seq_file private pointer restored to the pool, as it was initially when <a class="el" href="lod__pool_8c.html#a536e66dda7929b5cbb40c9b9a8fecfc6" title="Start seq_file iteration via /proc for a single pool.">pool_proc_start()</a> was called.</p>
<p>In some cases the <a class="el" href="rename__many_8c.html#a6c0af9f2e97842405fb15ed952ef2976">stop()</a> method may be called 2 times, without calling the <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start()</a> method (see seq_read() from fs/seq_file.c). We have to free the private iterator struct only if seq-&gt;private points to the iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence file structure to clean up </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>(unused) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00344">344</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="lod__pool_8c_source.html#l00095">lod_pool_putref()</a>, <a class="el" href="lod__pool_8c_source.html#l00231">lod_pool_iterator::lpi_magic</a>, <a class="el" href="lod__pool_8c_source.html#l00233">lod_pool_iterator::lpi_pool</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, and <a class="el" href="lod__pool_8c_source.html#l00229">POOL_IT_MAGIC</a>.</p>

</div>
</div>
<a class="anchor" id="a673a758b9172d99d0f897d0f21f43b75"></a><!-- doxytag: member="lod_pool.c::pool_putref_locked" ref="a673a758b9172d99d0f897d0f21f43b75" args="(struct pool_desc *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pool_putref_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpool__desc.html">pool_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop the refcount in cases where the caller holds a spinlock. </p>
<p>This is needed if the caller cannot be blocked while freeing memory. It assumes that there is some other known refcount held on the <em>pool</em> and the memory cannot actually be freed, but the refcounting needs to be kept accurate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pool</em>&nbsp;</td><td>pool descriptor on which to drop reference </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00119">119</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00135">D_INFO</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, and <a class="el" href="lod__internal_8h_source.html#l00071">pool_desc::pool_refcount</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00207">pool_hashrefcount_put_locked()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a482f6f8430424db32b75a1344cb3eaea"></a><!-- doxytag: member="lod_pool.c::pool_hash_operations" ref="a482f6f8430424db32b75a1344cb3eaea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcfs__hash__ops.html">cfs_hash_ops</a> <a class="el" href="lov__pool_8c.html#a482f6f8430424db32b75a1344cb3eaea">pool_hash_operations</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .hs_hash        = <a class="code" href="lod__pool_8c.html#a9bf5114e691ab53f89240552e2b92698" title="Hash the pool name for use by the cfs_hash handlers.">pool_hashfn</a>,
        .hs_key         = <a class="code" href="lod__pool_8c.html#a1ea2d56eab78b9a73e98c0c33b4c4db0" title="Return the actual key (pool name) from the hashed hnode.">pool_key</a>,
        .hs_keycmp      = <a class="code" href="lod__pool_8c.html#a1f04a4c167824eda906f1941378442d0" title="Check if the specified hash key matches the hash node.">pool_hashkey_keycmp</a>,
        .hs_object      = <a class="code" href="lod__pool_8c.html#a8761a765d566cfb21ca464450267070e" title="Return the actual pool data structure from the hash table entry.">pool_hashobject</a>,
        .hs_get         = <a class="code" href="lod__pool_8c.html#a2d15e2b4d125ff7f7b29bb40a019a134">pool_hashrefcount_get</a>,
        .hs_put_locked  = <a class="code" href="lod__pool_8c.html#a36613f3ccaf392cfa511bae9a8fafac6">pool_hashrefcount_put_locked</a>,
}
</pre></div>
<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00216">216</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="a183ceba94cb42c36e82da892a3a26a54"></a><!-- doxytag: member="lod_pool.c::pool_proc_operations" ref="a183ceba94cb42c36e82da892a3a26a54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct file_operations <a class="el" href="lod__pool_8c.html#a183ceba94cb42c36e82da892a3a26a54">pool_proc_operations</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .open           = <a class="code" href="lod__pool_8c.html#a2e4e7acd4df0efd345b41293bf44f673" title="Open a new /proc file for seq_file iteration of targets in one pool.">pool_proc_open</a>,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
}
</pre></div>
<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00411">411</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00643">lod_pool_new()</a>.</p>

</div>
</div>
<a class="anchor" id="a78164d0ba4682a7f995a63e2f3641134"></a><!-- doxytag: member="lod_pool.c::pool_proc_ops" ref="a78164d0ba4682a7f995a63e2f3641134" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct seq_operations <a class="el" href="lod__pool_8c.html#a78164d0ba4682a7f995a63e2f3641134">pool_proc_ops</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .start  = <a class="code" href="lod__pool_8c.html#a536e66dda7929b5cbb40c9b9a8fecfc6" title="Start seq_file iteration via /proc for a single pool.">pool_proc_start</a>,
        .next   = <a class="code" href="lod__pool_8c.html#a48aba6b5fd7228b3b0607fbbb186d714" title="Return the next configured target within one pool for seq_file iteration.">pool_proc_next</a>,
        .stop   = <a class="code" href="lod__pool_8c.html#aa0de3f05bf6cf48061b4189f793c014a" title="Finish seq_file iteration for a single pool.">pool_proc_stop</a>,
        .show   = <a class="code" href="lod__pool_8c.html#a6d3e838bad8804086770637dc06c0353" title="Print out one target entry from the pool for seq_file iteration.">pool_proc_show</a>,
}
</pre></div>
<p>Definition at line <a class="el" href="lod__pool_8c_source.html#l00381">381</a> of file <a class="el" href="lod__pool_8c_source.html">lod_pool.c</a>.</p>

<p>Referenced by <a class="el" href="lod__pool_8c_source.html#l00399">pool_proc_open()</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:48 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
