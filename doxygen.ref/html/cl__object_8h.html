<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/cl_object.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/include/cl_object.h File Reference</h1><code>#include &lt;<a class="el" href="libcfs_8h_source.html">libcfs/libcfs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lu__object_8h_source.html">lu_object.h</a>&gt;</code><br/>
<code>#include &lt;linux/atomic.h&gt;</code><br/>
<code>#include &lt;linux/mutex.h&gt;</code><br/>
<code>#include &lt;linux/radix-tree.h&gt;</code><br/>
<code>#include &lt;linux/spinlock.h&gt;</code><br/>
<code>#include &lt;linux/wait.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>&gt;</code><br/>

<p><a href="cl__object_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__device.html">cl_device</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device in the client stack.  <a href="structcl__device.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__attr.html">cl_attr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Data attributes" of <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>.  <a href="structcl__attr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object.html">cl_object</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sub-class of <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> with methods common for objects on the client stacks.  <a href="structcl__object.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__conf.html">cl_object_conf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Description of the client object configuration.  <a href="structcl__object__conf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__layout.html">cl_layout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html">cl_object_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations implemented for each cl object layer.  <a href="structcl__object__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__header.html">cl_object_header</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended header for client object.  <a href="structcl__object__header.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html">cl_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fields are protected by the lock on struct page, except for atomics and immutables.  <a href="structcl__page.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__slice.html">cl_page_slice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer part of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.  <a href="structcl__page__slice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html">cl_page_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer page operations.  <a href="structcl__page__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock__descr.html">cl_lock_descr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock description.  <a href="structcl__lock__descr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock.html">cl_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Layered client lock.  <a href="structcl__lock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock__slice.html">cl_lock_slice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer part of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>.  <a href="structcl__lock__slice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock__operations.html">cl_lock_operations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__list.html">cl_page_list</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__2queue.html">cl_2queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-queue of pages.  <a href="structcl__2queue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__slice.html">cl_io_slice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO state private for a layer.  <a href="structcl__io__slice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__read__ahead.html">cl_read_ahead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html">cl_io_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer io operations.  <a href="structcl__io__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__lock__link.html">cl_io_lock_link</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link between lock and io.  <a href="structcl__io__lock__link.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lockset.html">cl_lockset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock-set represents a collection of locks, that io needs at a time.  <a href="structcl__lockset.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__rw__common.html">cl_io_rw_common</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html">cl_io</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State for io.  <a href="structcl__io.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__req__attr.html">cl_req_attr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-transfer attributes.  <a href="structcl__req__attr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcache__stats.html">cache_stats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stats for a generic cache (similar to inode, <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>, etc.  <a href="structcache__stats.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__site.html">cl_site</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client-side site.  <a href="structcl__site.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__client__cache.html">cl_client_cache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data structure managing a client's cached pages.  <a href="structcl__client__cache.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__sync__io.html">cl_sync_io</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Anchor for synchronous transfer.  <a href="structcl__sync__io.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__env__nest.html">cl_env_nest</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga6477841d5f3bd9c2a2ca05e2aa089ea9">cl_object_for_each</a>(slice, obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro: iterate over all layers of the object <em>obj</em>, assigning every layer top-to-bottom to <em>slice</em>.  <a href="group__cl__object.html#ga6477841d5f3bd9c2a2ca05e2aa089ea9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gade758968f8d058a2849df2f8f3e70762">cl_object_for_each_reverse</a>(slice, obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro: iterate over all layers of the object <em>obj</em>, assigning every layer bottom-to-top to <em>slice</em>.  <a href="group__cl__object.html#gade758968f8d058a2849df2f8f3e70762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gafe652221af494d72225936c18562922f">CL_PAGE_EOF</a>&nbsp;&nbsp;&nbsp;((pgoff_t)~0ull)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga912e7c9c7d73f184c724593eb42f857a">CL_PAGE_DEBUG</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping detailed information about <em>page</em> into a log.  <a href="group__cl__page.html#ga912e7c9c7d73f184c724593eb42f857a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4">CL_PAGE_HEADER</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping shorter information about <em>page</em> into a log.  <a href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga3f36ee0c41000fd2b189406ddfc160f1">cl_page_in_use</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller itself holds a refcount of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.  <a href="group__cl__page.html#ga3f36ee0c41000fd2b189406ddfc160f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad3d3c2d56b9ba8a228c82c097258b596">cl_page_in_use_noref</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller doesn't hold a refcount.  <a href="group__cl__page.html#gad3d3c2d56b9ba8a228c82c097258b596"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#gaa48eed39677054974791fe8eacf7db52">DDESCR</a>&nbsp;&nbsp;&nbsp;&quot;%s(%d):[%lu, %lu]:%x&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga207d24f359de64af33fe97e97dc08843">PDESCR</a>(descr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga81d354408ca5abbfe26fcd44665e7e23">CL_LOCK_DEBUG</a>(mask, env, lock, format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga141b4ac98e80211e16e7866b193053ef">CL_LOCK_ASSERT</a>(expr, env, lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gad8a155eb56429b6d2ad9515eb4c4c5b5">cill_descr</a>&nbsp;&nbsp;&nbsp;cill_lock.cll_descr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gab615588a450704f3b1c875ccfd9361de">CS_NAMES</a>&nbsp;&nbsp;&nbsp;{ &quot;lookup&quot;, &quot;hit&quot;, &quot;total&quot;, &quot;busy&quot;, &quot;create&quot; }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gac166b29f4371ce1ec6adb1d26633c4fa">CL_IO_SLICE_CLEAN</a>(foo_io, base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794">cl_page_list_for_each</a>(page, <a class="el" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)&nbsp;&nbsp;&nbsp;list_for_each_entry((page), &amp;(<a class="el" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)-&gt;pl_pages, cp_batch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over pages in a page list.  <a href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575">cl_page_list_for_each_safe</a>(page, temp, <a class="el" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)&nbsp;&nbsp;&nbsp;list_for_each_entry_safe((page), (temp), &amp;(<a class="el" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)-&gt;pl_pages, cp_batch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over pages in a page list, taking possible removals into account.  <a href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga54c4de6c969138d0642ef59a1ff5e0b0">cl_commit_cbt</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *, struct <a class="el" href="structcl__io.html">cl_io</a> *, struct <a class="el" href="structcl__page.html">cl_page</a> *)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga48fd4da7a215ef4bcc31582adceb8b83">cl_attr_valid</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a8ccb81e3f6a5cba7c8e9bd494874cd38">CAT_SIZE</a> =  1 &lt;&lt; 0, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83aa410b24e55de9c6bf1fb8da2d36a5c8d">CAT_KMS</a> =  1 &lt;&lt; 1, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83ac7e947d42c260c8df203b6d73da46f4c">CAT_MTIME</a> =  1 &lt;&lt; 3, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83af1b07764255dd3f79878a040e7cb73b0">CAT_ATIME</a> =  1 &lt;&lt; 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a3d90d16441447a6904e7932279f13cb3">CAT_CTIME</a> =  1 &lt;&lt; 5, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a0426f1a497ac52defd19a0f843de76dd">CAT_BLOCKS</a> =  1 &lt;&lt; 6, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a5b08cbafc7ea7a9a5bc7579fe8d1d7d4">CAT_UID</a> =  1 &lt;&lt; 7, 
<a class="el" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83aa0bf839b66fce54ab3eaf3744311f6f6">CAT_GID</a> =  1 &lt;&lt; 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Fields in <a class="el" href="structcl__attr.html" title="&quot;Data attributes&quot; of cl_object.">cl_attr</a> that are being set. </p>
 <a href="group__cl__object.html#ga48fd4da7a215ef4bcc31582adceb8b83">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5afbab2abc5d277403ef84e9bcd75ee7e5">OBJECT_CONF_SET</a> =  0, 
<a class="el" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5a008009ec8f83b28274d90a650cca813b">OBJECT_CONF_INVALIDATE</a> =  1, 
<a class="el" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5a916b610eabe05c138a1717820f9a0696">OBJECT_CONF_WAIT</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__cl__object.html#ggabc6126af1d45847bc59afa0aa3216b04a1b72f9397d6476c49c2e8d29c77f7020">CL_LAYOUT_GEN_NONE</a> =  (u32)-2, 
<a class="el" href="group__cl__object.html#ggabc6126af1d45847bc59afa0aa3216b04a24c291bae1cc38e81fe6ec49d17db612">CL_LAYOUT_GEN_EMPTY</a> =  (u32)-1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba">CPS_CACHED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9">CPS_OWNED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4">CPS_PAGEOUT</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998">CPS_PAGEIN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8">CPS_FREEING</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ae97a053a1e380f19d44c5c2f94e44f3c">CPS_NR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>States of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
 <a href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> { <a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936">CPT_CACHEABLE</a> =  1, 
<a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d">CPT_TRANSIENT</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">cl_lock_mode</a> { <a class="el" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 
<a class="el" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a>, 
<a class="el" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1a9216706e47555f5dcf27d23513323e52">CLM_GROUP</a>, 
<a class="el" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1a883af2aa9c32d858f479bd8e2fb36291">CLM_MAX</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Lock mode. </p>
 <a href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> { <a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a58002573909284f81e9a573147c902f9">CRT_READ</a>, 
<a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e">CRT_WRITE</a>, 
<a class="el" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a521eb2b78ce2d57a85e84b1452597426">CRT_NR</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Requested transfer type. </p>
 <a href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb">CIT_READ</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475">CIT_WRITE</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a0a7b38271be1f7d7faac2bfc3f8ce3a6">CIT_SETATTR</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ae0e5d488dc0faa7eca8a7ab4a48cbc25">CIT_DATA_VERSION</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378af6dd7f3f5e03ad52c7f5a42d5fd03322">CIT_FAULT</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a5e5f57a7ae1e41cc45aa7ec77eacf4b3">CIT_FSYNC</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c">CIT_MISC</a>, 
<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ad49f27c1cdc5be6e64ea32bcb4f16e8d">CIT_LADVISE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a0b99cf78607418a7e0d5a1ebf5599baa">CIT_OP_NR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>IO types. </p>
 <a href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga31cc6886dbe550ea8576111ded9814f3">cl_io_state</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a533479241f38018af1651a483ca85b91">CIS_ZERO</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a009e9e287aa930cf2a8aa288afbbe134">CIS_INIT</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ad8aa8993a7b31bf97b878e8ad84b9154">CIS_IT_STARTED</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a7aaaa8f4b4ceebebb8004c39f786d2ba">CIS_LOCKED</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ae890b65a3f8bcb1142724628e71c247a">CIS_IO_GOING</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a4c41fb95967777c249bd9b835a1e4a8e">CIS_IO_FINISHED</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a3d421a3505fbc9098add0227c3e978c5">CIS_UNLOCKED</a>, 
<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a4a452e3aadf68f37073952f26f59ecbe">CIS_IT_ENDED</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3aeb38a1f10d1e0e66044bbfe4f40a20c0">CIS_FINI</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>States of <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> state machine. </p>
 <a href="group__cl__io.html#ga31cc6886dbe550ea8576111ded9814f3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga37f72b37baaeba18d9e0fac4560ec902">cl_enq_flags</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a1562800e334f5cb2c074f41cc5b0bf1c">CEF_NONBLOCK</a> =  0x00000001, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a432de84a3a6c92d385d1455be6b0272b">CEF_ASYNC</a> =  0x00000002, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a2b96e0457cbff9ba9a8aa854009cf8da">CEF_DISCARD_DATA</a> =  0x00000004, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902acf6cb6d67732370185bebac31ca6ef29">CEF_MUST</a> =  0x00000008, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a0a16d738d6f6b4a50693501adc8e310d">CEF_NEVER</a> =  0x00000010, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a143ec61f815da4099f40d16b5e1b13d2">CEF_AGL</a> =  0x00000020, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a469f38a944b34de3f51d2f2964202604">CEF_PEEK</a> =  0x00000040, 
<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a61dce4cb6cb397ffffaf1c6d5d8608db">CEF_LOCK_MATCH</a> =  0x00000080, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a1a094fe2f0162ab8a02816903d804d97">CEF_MASK</a> =  0x000000ff
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags to lock enqueue procedure. </p>
 <a href="group__cl__lock.html#ga37f72b37baaeba18d9e0fac4560ec902">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gac7ff31ceda4789c9101711379ffe824b">cl_io_lock_dmd</a> { <a class="el" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824ba4e46f767dce68b1f061c35ec1edc0528">CILR_MANDATORY</a> =  0, 
<a class="el" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bafc402749f67a87f7c2508998b1caec47">CILR_MAYBE</a>, 
<a class="el" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bacfd43489ba9d674ad77c4bdd51d3a7bc">CILR_NEVER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Lock requirements(demand) for IO. </p>
 <a href="group__cl__io.html#gac7ff31ceda4789c9101711379ffe824b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gabb7d5d07a2e68b82b9b13cac60256a7d">cl_fsync_mode</a> { <a class="el" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da2efbba1b7d141493ec27186a908dfd02">CL_FSYNC_NONE</a> =  0, 
<a class="el" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da7421020b0252ff0989fd86dc2b3c2620">CL_FSYNC_LOCAL</a> =  1, 
<a class="el" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da26eec0d9c8b5fb4114c7841d531cd07e">CL_FSYNC_DISCARD</a> =  2, 
<a class="el" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da1289d6fd8294a72b7d758fd5d5c1aa2e">CL_FSYNC_ALL</a> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gae65e5f5fa59d73bc289f6c6f6e566e52">cache_stats_item</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52aa453d6bdec4a9c94fa728d9ece3a682e">CS_lookup</a> =  0, 
<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52af5a2cda59cd742b3182d202b1895f8d7">CS_hit</a>, 
<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52a232ade650d55eb6e9554284682464b0b">CS_total</a>, 
<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52a344d449ca6a9a6d812f7019929fd8a03">CS_busy</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52ae628f58c8c153c29328b6b5185bdff5a">CS_create</a>, 
<a class="el" href="group__clio.html#ggae65e5f5fa59d73bc289f6c6f6e566e52a89fe91d03a1aea7ea6e972f9fe42d849">CS_NR</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5">CLP_GANG_OKAY</a> =  0, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1279507e1987988d99116da1f362faaa">CLP_GANG_RESCHED</a>, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca7a07cd260bc2685503d74371b7af3fa5">CLP_GANG_AGAIN</a>, 
<a class="el" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7">CLP_GANG_ABORT</a>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct page *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga643f9383053507790b9c5a43cdfdb5bf">cl_page_vmpage</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaec4e53fca3e674f91259ef8dfec297a1">__page_in_use</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page, int refc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is in use.  <a href="group__cl__page.html#gaec4e53fca3e674f91259ef8dfec297a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#gaef00eb170071c4836742562b90e49750">cl_lock_mode_name</a> (const enum <a class="el" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">cl_lock_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga1baea8a3fa79436133fe8e9dd42c7893">cl_read_ahead_release</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__read__ahead.html">cl_read_ahead</a> *ra)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga1e4ceb0e1ebe73971d4b3e7f5efaad02">cache_stats_init</a> (struct <a class="el" href="structcache__stats.html">cache_stats</a> *cs, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are not exported so far.  <a href="group__clio.html#ga1e4ceb0e1ebe73971d4b3e7f5efaad02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga57611e1e5715dc94dd0eb503a72a8b33">cl_site_init</a> (struct <a class="el" href="structcl__site.html">cl_site</a> *s, struct <a class="el" href="structcl__device.html">cl_device</a> *top)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize client site.  <a href="group__clio.html#ga57611e1e5715dc94dd0eb503a72a8b33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga5384082c04872b0c11252ead509cdd7a">cl_site_fini</a> (struct <a class="el" href="structcl__site.html">cl_site</a> *s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize client site.  <a href="group__clio.html#ga5384082c04872b0c11252ead509cdd7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga0f3ca66265a771105086ea8d48cd814d">cl_stack_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__device.html">cl_device</a> *cl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize device stack by calling <a class="el" href="group__lu.html#gadaddcc81c2131ec1158c21f009cf1739" title="Finalize and free devices in the device stack.">lu_stack_fini()</a>.  <a href="group__clio.html#ga0f3ca66265a771105086ea8d48cd814d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga5898f38acc8064feb8aecae6b0cbffd4">cl_site_stats_print</a> (const struct <a class="el" href="structcl__site.html">cl_site</a> *site, struct seq_file *m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output client site statistical counters into a buffer.  <a href="group__clio.html#ga5898f38acc8064feb8aecae6b0cbffd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a">cl_object_top</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the top-object for a given <em>o</em>.  <a href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd">cl_object_find</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__device.html">cl_device</a> *cd, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid, const struct <a class="el" href="structcl__object__conf.html">cl_object_conf</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> with a given <em>fid</em>.  <a href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga0e1e8f1e195acfd9ad600b33e8f183e7">cl_object_header_init</a> (struct <a class="el" href="structcl__object__header.html">cl_object_header</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize <a class="el" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a>.  <a href="group__cl__object.html#ga0e1e8f1e195acfd9ad600b33e8f183e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga76b88e11955bc3109371ae6194189d25">cl_object_header_fini</a> (struct <a class="el" href="structcl__object__header.html">cl_object_header</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize <a class="el" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a>.  <a href="group__cl__object.html#ga76b88e11955bc3109371ae6194189d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16">cl_object_put</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a reference on <em>o</em>.  <a href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b">cl_object_get</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire an additional reference to the object <em>o</em>.  <a href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a">cl_object_attr_lock</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks data-attributes.  <a href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga2fc69699a9214cda8ac2e8264b709dac">cl_object_attr_unlock</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases data-attributes lock, acquired by <a class="el" href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a" title="Locks data-attributes.">cl_object_attr_lock()</a>.  <a href="group__cl__object.html#ga2fc69699a9214cda8ac2e8264b709dac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gadfa2c03f781edcc53976843d94c18b48">cl_object_attr_get</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns data-attributes of an object <em>obj</em>.  <a href="group__cl__object.html#gadfa2c03f781edcc53976843d94c18b48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gaaa4c4e2f092946a662c321e1aa7a4aab">cl_object_attr_update</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr, unsigned valid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates data-attributes of an object <em>obj</em>.  <a href="group__cl__object.html#gaaa4c4e2f092946a662c321e1aa7a4aab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gaeed557c8f4926f9d6492df7026fd4b13">cl_object_glimpse</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies layers (bottom-to-top) that glimpse AST was received.  <a href="group__cl__object.html#gaeed557c8f4926f9d6492df7026fd4b13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga2e572a2e5a92e017e5d45187657e3f94">cl_conf_set</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__object__conf.html">cl_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates a configuration of an object <em>obj</em>.  <a href="group__cl__object.html#ga2e572a2e5a92e017e5d45187657e3f94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gacbefea6c611d782bb7ccfac4be7f3ec9">cl_object_prune</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prunes caches of pages and locks for this object.  <a href="group__cl__object.html#gacbefea6c611d782bb7ccfac4be7f3ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga2969ac9d2e4cce406eb1bfa24838964f">cl_object_kill</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function removing all object locks, and marking object for deletion.  <a href="group__cl__object.html#ga2969ac9d2e4cce406eb1bfa24838964f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga746cc5d7737450ca64ba6997f3e9afd8">cl_object_getstripe</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct lov_user_md __user *lum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get stripe information of this object.  <a href="group__cl__object.html#ga746cc5d7737450ca64ba6997f3e9afd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gae661d62a9c4af07425119b1308c3ff61">cl_object_fiemap</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structll__fiemap__info__key.html">ll_fiemap_info_key</a> *fmkey, struct fiemap *fiemap, size_t *buflen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get fiemap extents from file object.  <a href="group__cl__object.html#gae661d62a9c4af07425119b1308c3ff61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gaed35f941df7b7d63305b33783313b235">cl_object_layout_get</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__layout.html">cl_layout</a> *cl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">loff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#gaa30ca80e8a50712e8ccf910be0bf0845">cl_object_maxbytes</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga49a29b0baac53b37e4a7e7334c081c21">cl_object_same</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *o0, struct <a class="el" href="structcl__object.html">cl_object</a> *o1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, iff <em>o0</em> and <em>o1</em> are slices of the same object.  <a href="group__cl__object.html#ga49a29b0baac53b37e4a7e7334c081c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga90d038bc9bf28000122750aa79e393b2">cl_object_page_init</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *clob, int <a class="el" href="parallel__grouplock_8c.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga22b6cf3a62d106fcfb7bee291d22ff70">cl_object_page_slice</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *clob, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__object.html#ga6468845263bc804e0badfe153da12081">cl_object_refc</a> (struct <a class="el" href="structcl__object.html">cl_object</a> *clob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return refcount of <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>.  <a href="group__cl__object.html#ga6468845263bc804e0badfe153da12081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga448fbdaea940886c756e4a2d659982ba">cl_page_find</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> with index <em>idx</em> at the object <em>o</em>, and associated with the VM page <em>vmpage</em>.  <a href="group__cl__page.html#ga448fbdaea940886c756e4a2d659982ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga630af4228e1e42063ce55e844dfc8c30">cl_page_alloc</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *o, pgoff_t ind, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13">cl_page_get</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquires an additional reference to a page.  <a href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1">cl_page_put</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a reference to a page.  <a href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2">cl_page_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>.  <a href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab">cl_page_header_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>.  <a href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed">cl_vmpage_page</a> (struct page *vmpage, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> associated with a VM page, and given <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>.  <a href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga5751d9274f61529ae1ec5a2b03b20db2">cl_page_top</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gab700fa091971e5f4dd53b2e7ec47334d">cl_page_at</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page, const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *dtype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa9cb2d06a33d48e9c15d7e311fb3c2be">cl_cache_init</a> (unsigned long lru_page_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cl_cache functions  <a href="group__cl__page.html#gaa9cb2d06a33d48e9c15d7e311fb3c2be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga81d50c8e80031f53132c1e66c54ee2c6">cl_cache_incref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase cl_cache refcount.  <a href="group__cl__page.html#ga81d50c8e80031f53132c1e66c54ee2c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaaabf78f7ae327b269ded9a824d9ccebf">cl_cache_decref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease cl_cache refcount and free the cache if refcount=0.  <a href="group__cl__page.html#gaaabf78f7ae327b269ded9a824d9ccebf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga4afe671873f4a7343d9c50c574557fd6">cl_lock_request</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main high-level entry point of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> interface that finds existing or enqueues new lock matching given description.  <a href="group__cl__lock.html#ga4afe671873f4a7343d9c50c574557fd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga936be055d2a7449907656154d8970dc0">cl_lock_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga61a295e97704c2509c99d3f7d8711a95">cl_lock_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga9b59ad7624c11fcecf6eadb1a58f6f8b">cl_lock_at</a> (const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *dtype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a slice with a lock, corresponding to the given layer in the device stack.  <a href="group__cl__lock.html#ga9b59ad7624c11fcecf6eadb1a58f6f8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#ga4e8069a400c6a75342649a6fc04fa2c3">cl_lock_release</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a hold and a reference on a lock, obtained by cl_lock_hold().  <a href="group__cl__lock.html#ga4e8069a400c6a75342649a6fc04fa2c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#gab9d3d1e316773c71555cbb8e29ca0403">cl_lock_enqueue</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a lock.  <a href="group__cl__lock.html#gab9d3d1e316773c71555cbb8e29ca0403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__lock.html#gaab3c1781a296023121c2641a117a57b1">cl_lock_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1">cl_io_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, enum <a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a> iot, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize <em>io</em>, by calling cl_io_operations::cio_init() top-to-bottom.  <a href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga485aa4a9e93475523519f07aca310bac">cl_io_sub_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, enum <a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a> iot, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize sub-io, by calling cl_io_operations::cio_init() top-to-bottom.  <a href="group__cl__io.html#ga485aa4a9e93475523519f07aca310bac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d">cl_io_rw_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, enum <a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a> iot, loff_t pos, size_t count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize read or write io.  <a href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e">cl_io_loop</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main io loop.  <a href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f">cl_io_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize <em>io</em>, by calling <a class="el" href="structcl__io__operations.html#a09ecbd759c7a3569d67a75e9f201d1ba" title="Called once per io, bottom-to-top to release io resources.">cl_io_operations::cio_fini()</a> bottom-to-top.  <a href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003">cl_io_iter_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares next iteration of io.  <a href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac">cl_io_iter_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes io iteration.  <a href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6">cl_io_lock</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes locks necessary for the current iteration of io.  <a href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681">cl_io_unlock</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release locks takes by io.  <a href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008">cl_io_start</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts io by calling <a class="el" href="structcl__io__operations.html#a29bbb031f049b8a1a5e54d575fa88209" title="Start io iteration.">cl_io_operations::cio_start()</a> top-to-bottom.  <a href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5">cl_io_end</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until current io iteration is finished by calling <a class="el" href="structcl__io__operations.html#a4d3dfb49a0fbf1f90b3de60841183d0a" title="Called top-to-bottom at the end of io loop.">cl_io_operations::cio_end()</a> bottom-to-top.  <a href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e">cl_io_lock_add</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__io__lock__link.html">cl_io_lock_link</a> *link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a lock to a lockset.  <a href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga3ce86bab1ea06d8d2d7ac15f3a0be3f6">cl_io_lock_alloc_add</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> *descr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates new lock link, and uses it to add a lock to a lockset.  <a href="group__cl__io.html#ga3ce86bab1ea06d8d2d7ac15f3a0be3f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c">cl_io_submit_rw</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> iot, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submits a list of pages for immediate io.  <a href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70">cl_io_submit_sync</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> iot, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue, long <a class="el" href="o2iblnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a sync_io and wait for the IO to be finished, or error happens.  <a href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb">cl_io_commit_async</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *queue, int from, int to, <a class="el" href="group__cl__io.html#ga54c4de6c969138d0642ef59a1ff5e0b0">cl_commit_cbt</a> cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit a list of contiguous pages into writeback cache.  <a href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gad5b4d2971764744ec2f5d30fe56d9781">cl_io_read_ahead</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, pgoff_t <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, struct <a class="el" href="structcl__read__ahead.html">cl_read_ahead</a> *ra)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by read io, to decide the readahead extent.  <a href="group__cl__io.html#gad5b4d2971764744ec2f5d30fe56d9781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga0e67009a999662295be41a4532bf6f37">cl_io_rw_advance</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, size_t nob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Records that read or write io progressed <em>nob</em> bytes forward.  <a href="group__cl__io.html#ga0e67009a999662295be41a4532bf6f37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga9e1b49d71ec98da5a7f4bd1fba415ad5">cl_io_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel an IO which has been submitted by cl_io_submit_rw.  <a href="group__cl__io.html#ga9e1b49d71ec98da5a7f4bd1fba415ad5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga2ae08af9fbe1af93e2d82049e7ae7e3c">cl_io_is_going</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true iff there is an IO ongoing in the given environment.  <a href="group__cl__io.html#ga2ae08af9fbe1af93e2d82049e7ae7e3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga81a17e84380b3479ecbe1e4a0a868801">cl_io_is_append</a> (const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True, iff <em>io</em> is an O_APPEND write(2).  <a href="group__cl__io.html#ga81a17e84380b3479ecbe1e4a0a868801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga48f4979293404667c5c1e8eb8e080dc7">cl_io_is_sync_write</a> (const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gabb552842f09a0899378f5a04410f4dc7">cl_io_is_mkwrite</a> (const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#gafc95427f78408eaab2a0857e92d1004a">cl_io_is_trunc</a> (const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True, iff <em>io</em> is a truncate(2).  <a href="group__cl__io.html#gafc95427f78408eaab2a0857e92d1004a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c">cl_io_top</a> (struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns top-level io.  <a href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__io.html#ga56de1ca2cd018d724e180da7eabbcad9">cl_io_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>io</em> to the <em>f</em>.  <a href="group__cl__io.html#ga56de1ca2cd018d724e180da7eabbcad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga934c63a7507d4e7379ec48f01468de6b">cl_page_list_last</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last page in the page list.  <a href="group__cl__page__list.html#ga934c63a7507d4e7379ec48f01468de6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga1fa83a01d78b01e4b47a1aef2d63cec7">cl_page_list_first</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0">cl_page_list_init</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes page list.  <a href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a">cl_page_list_add</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a page to a page list.  <a href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c">cl_page_list_move</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *dst, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *src, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves a page from one page list to another.  <a href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga06da834a47d10c42fdd688c728213d8c">cl_page_list_move_head</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *dst, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *src, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves a page from one page list to the head of another list.  <a href="group__cl__page__list.html#ga06da834a47d10c42fdd688c728213d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gac4c762cc3608863a8e5a766def8bf1c8">cl_page_list_splice</a> (struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *<a class="el" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *<a class="el" href="writemany_8c.html#af39400667a953a7c5c34e3964aa1ce9f">head</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">splice the <a class="el" href="structcl__page__list.html">cl_page_list</a>, just as list head does  <a href="group__cl__page__list.html#gac4c762cc3608863a8e5a766def8bf1c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9">cl_page_list_del</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a page from a page list.  <a href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6">cl_page_list_disown</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disowns pages in a queue.  <a href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a">cl_page_list_own</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Owns all pages in a queue.  <a href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693">cl_page_list_assume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assumes all pages in a queue.  <a href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8">cl_page_list_discard</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discards all pages in a queue.  <a href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe">cl_page_list_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *plist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases pages from queue.  <a href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0">cl_2queue_init</a> (struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize dual page queue.  <a href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac">cl_2queue_add</a> (struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a page to the incoming page list of 2-queue.  <a href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699">cl_2queue_disown</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disown pages in both lists of a 2-queue.  <a href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gaf1c12344f300cfdabbaabba9544db1da">cl_2queue_assume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume to own the pages in <a class="el" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a>.  <a href="group__cl__page__list.html#gaf1c12344f300cfdabbaabba9544db1da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e">cl_2queue_discard</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard (truncate) pages in both lists of a 2-queue.  <a href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379">cl_2queue_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize both page lists of a 2-queue.  <a href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c">cl_2queue_init_page</a> (struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a 2-queue to contain <em>page</em> in its incoming page list.  <a href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga596455746e16e88acee9318d8d95339d">cl_req_attr_set</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__req__attr.html">cl_req_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in attributes that are passed to server together with transfer.  <a href="group__clio.html#ga596455746e16e88acee9318d8d95339d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5">cl_sync_io_init</a> (struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor, int nr, void(*end)(const struct <a class="el" href="structlu__env.html">lu_env</a> *, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize synchronous io wait anchor.  <a href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871">cl_sync_io_wait</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor, long <a class="el" href="o2iblnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until all IO completes.  <a href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9">cl_sync_io_note</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate that transfer of a single page completed.  <a href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__sync__io.html#ga068e3a27f8967f8656fe3407c898d1d6">cl_sync_io_end</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gad6cae9e9e53d78c25ee1deae1ae3b8f4">cl_env_peek</a> (__u16 *refcheck)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1">cl_env_get</a> (__u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <a class="el" href="structlu__env.html" title="Environment.">lu_env</a>: if there already is an environment associated with the current thread, it is returned, otherwise, new environment is allocated.  <a href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga2d91b169de0380c5f5be4c1118c7af8e">cl_env_alloc</a> (__u16 *refcheck, __u32 tags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces an allocation of a fresh environment with given tags.  <a href="group__cl__env.html#ga2d91b169de0380c5f5be4c1118c7af8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a> (struct <a class="el" href="structcl__env__nest.html">cl_env_nest</a> *nest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2">cl_env_put</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release an environment.  <a href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a> (struct <a class="el" href="structcl__env__nest.html">cl_env_nest</a> *nest, struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga2c3cf05baa558c0e2888b5c82d0039a2">cl_env_reenter</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares a point of re-entrancy.  <a href="group__cl__env.html#ga2c3cf05baa558c0e2888b5c82d0039a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga6a2f0ccf8118ede1c1f191a545937eac">cl_env_reexit</a> (void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exits re-entrancy.  <a href="group__cl__env.html#ga6a2f0ccf8118ede1c1f191a545937eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc">cl_env_implant</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup user-supplied <em>env</em> as a current environment.  <a href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gace30ddb0f3834c7dad1c4d5315dd63ba">cl_env_unplant</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach environment installed earlier by <a class="el" href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc" title="Setup user-supplied env as a current environment.">cl_env_implant()</a>.  <a href="group__cl__env.html#gace30ddb0f3834c7dad1c4d5315dd63ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1">cl_env_cache_purge</a> (unsigned nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes and frees a given number of cached environments.  <a href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga8d7bb468153f7ccc6259ecef4dfa91bf">cl_env_percpu_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gabbd19d47d20a5e5787bb6e61acaf1461">cl_env_percpu_put</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga5a05126b8b0aeb6f733aa358791aeed2">cl_attr2lvb</a> (struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb, const struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts struct <a class="el" href="structcl__attr.html" title="&quot;Data attributes&quot; of cl_object.">cl_attr</a> to struct <a class="el" href="structost__lvb.html">ost_lvb</a>.  <a href="group__clio.html#ga5a05126b8b0aeb6f733aa358791aeed2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gad69ffcfdd3d835937721abdc10dd1098">cl_lvb2attr</a> (struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr, const struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts struct <a class="el" href="structost__lvb.html">ost_lvb</a> to struct <a class="el" href="structcl__attr.html" title="&quot;Data attributes&quot; of cl_object.">cl_attr</a>.  <a href="group__clio.html#gad69ffcfdd3d835937721abdc10dd1098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__device.html">cl_device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga673ce59def375f145c75249200d9dd53">cl_type_setup</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__site.html">lu_site</a> *site, struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *ldt, struct <a class="el" href="structlu__device.html">lu_device</a> *next)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cl__object_8h.html#a20177ecada73cc1cd7e366cde320ba33">cl_global_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global initialization of cl-data.  <a href="#a20177ecada73cc1cd7e366cde320ba33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cl__object_8h.html#aa126f7175676348b3f0e009121808cec">cl_global_fini</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalization of global cl-data.  <a href="#aa126f7175676348b3f0e009121808cec"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">helpers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc2c3081275569a523f7b887c77722c5b"></a>Type conversion and accessory functions. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__site.html">cl_site</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gab612cda4d5357f6688eb90f6d3eb3f9c">lu2cl_site</a> (const struct <a class="el" href="structlu__site.html">lu_site</a> *site)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__device.html">cl_device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga0bc86ec0f6618825413c723e59cb5fb9">lu2cl_dev</a> (const struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlu__device.html">lu_device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga6d0133d233b70dc158000a523dce686c">cl2lu_dev</a> (struct <a class="el" href="structcl__device.html">cl_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga1ae4d5000c0a29753ade60344f1a540e">lu2cl</a> (const struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__object__conf.html">cl_object_conf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gaf4a9986b1c729e89e3506d13224661e7">lu2cl_conf</a> (const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gab66ce6af7ff216c484f3b18981f5132e">cl_object_next</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__object__header.html">cl_object_header</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gaf75b5461b478252267f126d01ad2c9d5">luh2coh</a> (const struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__site.html">cl_site</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga025ca53eaf1b4af418db0706d71b5db5">cl_object_site</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__object__header.html">cl_object_header</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gad17616130821a452cbc77936980c2170">cl_object_header</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga6652d15262c9439bdab9802f6d4eefa8">cl_device_init</a> (struct <a class="el" href="structcl__device.html">cl_device</a> *d, struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga4ebf1f9e155daf82c914f39a85d48851">cl_device_fini</a> (struct <a class="el" href="structcl__device.html">cl_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#gaf9c2b2723494e52efc66d52fe2d0b93f">cl_page_slice_add</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page, struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t index, const struct <a class="el" href="structcl__page__operations.html">cl_page_operations</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds page slice to the compound page.  <a href="group__clio.html#gaf9c2b2723494e52efc66d52fe2d0b93f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga9c2fdf8ae73a6f36bc8df4249459da93">cl_lock_slice_add</a> (struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__lock__operations.html">cl_lock_operations</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds lock slice to the compound lock.  <a href="group__clio.html#ga9c2fdf8ae73a6f36bc8df4249459da93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clio.html#ga7f11d31070279077648197650a60f10e">cl_io_slice_add</a> (struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__io__operations.html">cl_io_operations</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds io slice to the <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>.  <a href="group__clio.html#ga7f11d31070279077648197650a60f10e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">ownership</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb46b517b77d347176f23adef739a8f39"></a>Functions dealing with the ownership of page by io. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a">cl_page_own</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Own a page, might be blocked.  <a href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7">cl_page_own_try</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nonblock version of <a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>.  <a href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4">cl_page_assume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume page ownership.  <a href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61">cl_page_unassume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership without unlocking the page.  <a href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb">cl_page_disown</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership.  <a href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf">cl_page_is_owned</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *pg, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true, iff page is owned by the given io.  <a href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp84a0f3455dcca894ace136be62efa292"></a>Functions dealing with the preparation of a page for a transfer, and tracking transfer state. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8216a843e48aa6d45d049b6aacb13744">cl_page_prep</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares page for immediate transfer.  <a href="group__cl__page.html#ga8216a843e48aa6d45d049b6aacb13744"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga778ad6a1a849ef9701db714913c879ec">cl_page_completion</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers about transfer completion.  <a href="group__cl__page.html#ga778ad6a1a849ef9701db714913c879ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga864bcec4bff9dd1f988f928348c08796">cl_page_make_ready</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers that transfer formation engine decided to yank this page from the cache and to make it a part of a transfer.  <a href="group__cl__page.html#ga864bcec4bff9dd1f988f928348c08796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga9022b1fa30e82cf1e69bd534022ffb8f">cl_page_cache_add</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f">cl_page_clip</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int from, int to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells transfer engine that only part of a page is to be transmitted.  <a href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2b98b954f28349bd90316fec9ebaec83">cl_page_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a page which is still in a transfer.  <a href="group__cl__page.html#ga2b98b954f28349bd90316fec9ebaec83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga0616bcd8605ed9a75e799f64bcdd5a2d">cl_page_flush</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called if a pge is being written back by kernel's intention.  <a href="group__cl__page.html#ga0616bcd8605ed9a75e799f64bcdd5a2d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">helper routines</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpbc5b051d66841a94152b2b685d83a4c9"></a>Functions to discard, delete and export a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03">cl_page_discard</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when page is to be removed from the object, e.g., as a result of truncate.  <a href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432">cl_page_delete</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a decision is made to throw page out of memory.  <a href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3">cl_page_is_vmlocked</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, iff <em>pg</em> is VM locked in a suitable sense by the calling thread.  <a href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafacf1187afd6e200c6f8d59539baf50c">cl_page_export</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int uptodate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks page up-to-date.  <a href="group__cl__page.html#gafacf1187afd6e200c6f8d59539baf50c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">loff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515">cl_offset</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a byte offset within object <em>obj</em> into a page index.  <a href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pgoff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4">cl_index</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, loff_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a page index into a byte offset within object <em>obj</em>.  <a href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga43006a6bc8ca6f3de9ce4af48d944cc7">cl_page_size</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae62cdffcc2ad419c1efe15d3f7e2b7be">cl_lock_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>lock</em> to the <em>f</em>.  <a href="group__cl__page.html#gae62cdffcc2ad419c1efe15d3f7e2b7be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad2a636ba7685701e15adf1818874fd50">cl_lock_descr_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> *descr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of a lock description.  <a href="group__cl__page.html#gad2a636ba7685701e15adf1818874fd50"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa126f7175676348b3f0e009121808cec"></a><!-- doxytag: member="cl_object.h::cl_global_fini" ref="aa126f7175676348b3f0e009121808cec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_global_fini </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalization of global cl-data. </p>
<p>Dual to <a class="el" href="cl__object_8h.html#a20177ecada73cc1cd7e366cde320ba33" title="Global initialization of cl-data.">cl_global_init()</a>. </p>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l01403">1403</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>References <a class="el" href="cl__object_8c_source.html#l01188">cl_env_percpu_fini()</a>, <a class="el" href="cl__object_8c_source.html#l00737">cl_env_store_fini()</a>, <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>, and <a class="el" href="lu__object_8c_source.html#l02275">lu_kmem_fini()</a>.</p>

<p>Referenced by <a class="el" href="class__obd_8c_source.html#l00610">obdclass_exit()</a>.</p>

</div>
</div>
<a class="anchor" id="a20177ecada73cc1cd7e366cde320ba33"></a><!-- doxytag: member="cl_object.h::cl_global_init" ref="a20177ecada73cc1cd7e366cde320ba33" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_global_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global initialization of cl-data. </p>
<p>Create kmem caches, register lu_context_key's, etc.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cl__object_8h.html#aa126f7175676348b3f0e009121808cec" title="Finalization of global cl-data.">cl_global_fini()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l01365">1365</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>References <a class="el" href="cl__object_8c_source.html#l01146">cl_env_percpu_init()</a>, <a class="el" href="cl__object_8c_source.html#l00737">cl_env_store_fini()</a>, <a class="el" href="cl__object_8c_source.html#l00726">cl_env_store_init()</a>, <a class="el" href="cl__object_8c_source.html#l00572">cl_envs</a>, <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>, <a class="el" href="lu__object_8h_source.html#l01172">LU_CONTEXT_KEY_INIT</a>, <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>, <a class="el" href="lu__object_8c_source.html#l02275">lu_kmem_fini()</a>, and <a class="el" href="lu__object_8c_source.html#l02251">lu_kmem_init()</a>.</p>

<p>Referenced by <a class="el" href="class__obd_8c_source.html#l00495">obdclass_init()</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:46 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
