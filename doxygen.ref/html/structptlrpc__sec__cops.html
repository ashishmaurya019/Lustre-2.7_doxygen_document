<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ptlrpc_sec_cops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptlrpc_sec_cops Struct Reference<br/>
<small>
[<a class="el" href="group__sptlrpc.html">sptlrpc</a>]</small>
</h1><!-- doxytag: class="ptlrpc_sec_cops" -->
<p>client side policy operation vector.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a8bf54ba0627dde53dbce14fd8ddf1808">create_sec</a> )(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flavor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an <em>imp</em>, create and initialize a <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> structure.  <a href="#a8bf54ba0627dde53dbce14fd8ddf1808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a53a9874a373d044027d52b2bf118fc00">destroy_sec</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>.  <a href="#a53a9874a373d044027d52b2bf118fc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a08e2b30856f5887883df0abf37c3a5c1">kill_sec</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify that this <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> is going to die.  <a href="#a08e2b30856f5887883df0abf37c3a5c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#ab3722080e66868d83901a114d4ac3897">lookup_ctx</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structvfs__cred.html">vfs_cred</a> *vcred, int create, int remove_dead)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given <em>vcred</em>, lookup and/or create its context.  <a href="#ab3722080e66868d83901a114d4ac3897"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#aabc06c431b7e2b62d2d81f0707834122">release_ctx</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, int sync)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called then the reference of <em>ctx</em> dropped to 0.  <a href="#aabc06c431b7e2b62d2d81f0707834122"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a26e276d2b4143cd7376a9a13b194b51a">flush_ctx_cache</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, uid_t uid, int grace, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the context cache.  <a href="#a26e276d2b4143cd7376a9a13b194b51a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#ae5fd60f1e3563bd552852ccbc51883d0">gc_ctx</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called periodically by garbage collector to remove dead contexts from cache.  <a href="#ae5fd60f1e3563bd552852ccbc51883d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#af147272a7b7761512f4e964a6b72d14d">install_rctx</a> )(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an context <em>ctx</em>, install a corresponding reverse service context on client side.  <a href="#af147272a7b7761512f4e964a6b72d14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5">alloc_reqbuf</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int lustre_msg_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To allocate request buffer for <em>req</em>.  <a href="#aa41ab203ee2687014b25d0876b7427e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3">free_reqbuf</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To free request buffer for <em>req</em>.  <a href="#a1ccde999a88cf1028d6e9f7106c3fdf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef">alloc_repbuf</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int lustre_msg_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To allocate reply buffer for <em>req</em>.  <a href="#a6b48ac1eaef3ac1159a8d8cac74d5eef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082">free_repbuf</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To free reply buffer for <em>req</em>.  <a href="#ae72ed3fbdbb93a9fb7d08931fd536082"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f">enlarge_reqbuf</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int segment, int newsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To expand the request buffer of <em>req</em>, thus the <em>segment</em> in the request message pointed by req-&gt;rq_reqmsg can accommodate at least <em>newsize</em> of data.  <a href="#a67af7eed6f87fb433e01dc500814723f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html#a0d4fa4afda3da8bf5573267dc0319148">display</a> )(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct seq_file *seq)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>client side policy operation vector. </p>

<p>Definition at line <a class="el" href="lustre__sec_8h_source.html#l00551">551</a> of file <a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a6b48ac1eaef3ac1159a8d8cac74d5eef"></a><!-- doxytag: member="ptlrpc_sec_cops::alloc_repbuf" ref="a6b48ac1eaef3ac1159a8d8cac74d5eef" args=")(struct ptlrpc_sec *sec, struct ptlrpc_request *req, int lustre_msg_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef">ptlrpc_sec_cops::alloc_repbuf</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int lustre_msg_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To allocate reply buffer for <em>req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_repbuf == NULL. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>if success, req-&gt;rq_repbuf point to a buffer with size req-&gt;rq_repbuf_len, the size should be large enough to receive reply which be transformed from <em>lustre_msg_size</em> of clear text.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#aea53533ec274c5d1d99da169ebb12aed">null_alloc_repbuf()</a>, <a class="el" href="sec__plain_8c.html#a92c6e258ea2ef0216a50626db2256143">plain_alloc_repbuf()</a>, <a class="el" href="gss__internal_8h.html#a2122d6a74dbfbfeaf8e33dde73f5d67d">gss_alloc_repbuf()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01707">sptlrpc_cli_alloc_repbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="aa41ab203ee2687014b25d0876b7427e5"></a><!-- doxytag: member="ptlrpc_sec_cops::alloc_reqbuf" ref="aa41ab203ee2687014b25d0876b7427e5" args=")(struct ptlrpc_sec *sec, struct ptlrpc_request *req, int lustre_msg_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5">ptlrpc_sec_cops::alloc_reqbuf</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int lustre_msg_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To allocate request buffer for <em>req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_reqmsg == NULL. </dd>
<dd>
req-&gt;rq_reqbuf == NULL, otherwise it must be pre-allocated, we are not supposed to free it. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>if success, req-&gt;rq_reqmsg point to a buffer with size at least <em>lustre_msg_size</em>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#af8d28567edcef86d8e472d56a2cea528">null_alloc_reqbuf()</a>, <a class="el" href="sec__plain_8c.html#abe890ef3d79c50a008beab8cce8d0c3c">plain_alloc_reqbuf()</a>, <a class="el" href="gss__internal_8h.html#a790db4923bc126ade067f3a42c85ec37">gss_alloc_reqbuf()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01580">sptlrpc_cli_alloc_reqbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bf54ba0627dde53dbce14fd8ddf1808"></a><!-- doxytag: member="ptlrpc_sec_cops::create_sec" ref="a8bf54ba0627dde53dbce14fd8ddf1808" args=")(struct obd_import *imp, struct ptlrpc_svc_ctx *ctx, struct sptlrpc_flavor *flavor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a>*(* <a class="el" href="structptlrpc__sec__cops.html#a8bf54ba0627dde53dbce14fd8ddf1808">ptlrpc_sec_cops::create_sec</a>)(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flavor)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an <em>imp</em>, create and initialize a <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>service context:</p>
<ul>
<li>regular import: <em>ctx</em> should be NULL;</li>
<li>reverse import: <em>ctx</em> is obtained from incoming request. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flavor</em>&nbsp;</td><td>specify what flavor to use.</td></tr>
  </table>
  </dd>
</dl>
<p>When necessary, policy module is responsible for taking reference on the import.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a513d6c4575219d1306da9d0da6a92b75">null_create_sec()</a>, <a class="el" href="sec__plain_8c.html#a6cb39b882916bbb69acb480065819123">plain_create_sec()</a>, <a class="el" href="gss__keyring_8c.html#aad20b6d21cebcad1912409a00e644680">gss_sec_create_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01319">sptlrpc_sec_create()</a>.</p>

</div>
</div>
<a class="anchor" id="a53a9874a373d044027d52b2bf118fc00"></a><!-- doxytag: member="ptlrpc_sec_cops::destroy_sec" ref="a53a9874a373d044027d52b2bf118fc00" args=")(struct ptlrpc_sec *sec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#a53a9874a373d044027d52b2bf118fc00">ptlrpc_sec_cops::destroy_sec</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor of <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>. </p>
<p>When called, refcount has been dropped to 0 and all contexts has been destroyed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a9fce45686b4ff9977cee71ffdb984de4">null_destroy_sec()</a>, <a class="el" href="sec__plain_8c.html#a867908e0a04cb694ad7b525817cc22f5">plain_destroy_sec()</a>, <a class="el" href="gss__keyring_8c.html#ae5a3328ecbb8e49fb839a6d50bf1f8a5">gss_sec_destroy_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01262">sec_cop_destroy_sec()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d4fa4afda3da8bf5573267dc0319148"></a><!-- doxytag: member="ptlrpc_sec_cops::display" ref="a0d4fa4afda3da8bf5573267dc0319148" args=")(struct ptlrpc_sec *sec, struct seq_file *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#a0d4fa4afda3da8bf5573267dc0319148">ptlrpc_sec_cops::display</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct seq_file *seq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sec__lproc_8c_source.html#l00119">sptlrpc_ctxs_lprocfs_seq_show()</a>.</p>

</div>
</div>
<a class="anchor" id="a67af7eed6f87fb433e01dc500814723f"></a><!-- doxytag: member="ptlrpc_sec_cops::enlarge_reqbuf" ref="a67af7eed6f87fb433e01dc500814723f" args=")(struct ptlrpc_sec *sec, struct ptlrpc_request *req, int segment, int newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f">ptlrpc_sec_cops::enlarge_reqbuf</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int segment, int newsize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To expand the request buffer of <em>req</em>, thus the <em>segment</em> in the request message pointed by req-&gt;rq_reqmsg can accommodate at least <em>newsize</em> of data. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_reqmsg-&gt;lm_buflens[segment] &lt; newsize.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a8a9374950f5e356c39fd518c2d166d80">null_enlarge_reqbuf()</a>, <a class="el" href="sec__plain_8c.html#a584833f4f7b83c4156aab1111489e2bd">plain_enlarge_reqbuf()</a>, <a class="el" href="gss__internal_8h.html#af2276f33c9fca9b062941bd2921a798c">gss_enlarge_reqbuf()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01681">sptlrpc_cli_enlarge_reqbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a26e276d2b4143cd7376a9a13b194b51a"></a><!-- doxytag: member="ptlrpc_sec_cops::flush_ctx_cache" ref="a26e276d2b4143cd7376a9a13b194b51a" args=")(struct ptlrpc_sec *sec, uid_t uid, int grace, int force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#a26e276d2b4143cd7376a9a13b194b51a">ptlrpc_sec_cops::flush_ctx_cache</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, uid_t uid, int grace, int force)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush the context cache. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uid</em>&nbsp;</td><td>context of which user, -1 means all contexts. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grace</em>&nbsp;</td><td>if zero, the PTLRPC_CTX_UPTODATE_BIT of affected contexts should be cleared immediately. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>force</em>&nbsp;</td><td>if zero, only idle contexts will be flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__plain_8c.html#af8e163e58e08d5f7d5f85f367a5fecea">plain_flush_ctx_cache()</a>, <a class="el" href="gss__keyring_8c.html#a17268710fe2fc7c8267e7a054b4d78a6">gss_sec_flush_ctx_cache_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01251">sec_cop_flush_ctx_cache()</a>.</p>

</div>
</div>
<a class="anchor" id="ae72ed3fbdbb93a9fb7d08931fd536082"></a><!-- doxytag: member="ptlrpc_sec_cops::free_repbuf" ref="ae72ed3fbdbb93a9fb7d08931fd536082" args=")(struct ptlrpc_sec *sec, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082">ptlrpc_sec_cops::free_repbuf</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To free reply buffer for <em>req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_repbuf != NULL. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_repbuf == NULL. </dd>
<dd>
req-&gt;rq_repbuf_len == 0.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#ae59a91ec316129663ff4ef1bbbb2f3b0">null_free_repbuf()</a>, <a class="el" href="sec__plain_8c.html#a548d559fd03734c4d389a76a48792577">plain_free_repbuf()</a>, <a class="el" href="gss__internal_8h.html#a865d6db82f15ac488e72d6f25f29b585">gss_free_repbuf()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01728">sptlrpc_cli_free_repbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ccde999a88cf1028d6e9f7106c3fdf3"></a><!-- doxytag: member="ptlrpc_sec_cops::free_reqbuf" ref="a1ccde999a88cf1028d6e9f7106c3fdf3" args=")(struct ptlrpc_sec *sec, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3">ptlrpc_sec_cops::free_reqbuf</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To free request buffer for <em>req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_reqbuf != NULL.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a6ffcc4909bcbf6f90c8539799d1e91a0">null_free_reqbuf()</a>, <a class="el" href="sec__plain_8c.html#ae2b64a223622aafc1ad141e884601e59">plain_free_reqbuf()</a>, <a class="el" href="gss__internal_8h.html#ae0d2dc87ab5dced59080c99e48412579">gss_free_reqbuf()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01610">sptlrpc_cli_free_reqbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5fd60f1e3563bd552852ccbc51883d0"></a><!-- doxytag: member="ptlrpc_sec_cops::gc_ctx" ref="ae5fd60f1e3563bd552852ccbc51883d0" args=")(struct ptlrpc_sec *sec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#ae5fd60f1e3563bd552852ccbc51883d0">ptlrpc_sec_cops::gc_ctx</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called periodically by garbage collector to remove dead contexts from cache. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gss__keyring_8c.html#a4a13ec845f896aee3b14b6687cecb5a5">gss_sec_gc_ctx_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec__gc_8c_source.html#l00144">sec_do_gc()</a>, <a class="el" href="sec__gc_8c_source.html#l00067">sptlrpc_gc_add_sec()</a>, and <a class="el" href="sec_8c_source.html#l01319">sptlrpc_sec_create()</a>.</p>

</div>
</div>
<a class="anchor" id="af147272a7b7761512f4e964a6b72d14d"></a><!-- doxytag: member="ptlrpc_sec_cops::install_rctx" ref="af147272a7b7761512f4e964a6b72d14d" args=")(struct obd_import *imp, struct ptlrpc_sec *sec, struct ptlrpc_cli_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__cops.html#af147272a7b7761512f4e964a6b72d14d">ptlrpc_sec_cops::install_rctx</a>)(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an context <em>ctx</em>, install a corresponding reverse service context on client side. </p>
<p>XXX currently it's only used by GSS module, maybe we should remove this from general API. </p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01749">sptlrpc_cli_install_rvs_ctx()</a>.</p>

</div>
</div>
<a class="anchor" id="a08e2b30856f5887883df0abf37c3a5c1"></a><!-- doxytag: member="ptlrpc_sec_cops::kill_sec" ref="a08e2b30856f5887883df0abf37c3a5c1" args=")(struct ptlrpc_sec *sec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#a08e2b30856f5887883df0abf37c3a5c1">ptlrpc_sec_cops::kill_sec</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify that this <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> is going to die. </p>
<p>Optionally, policy module is supposed to set sec-&gt;ps_dying and whatever necessary actions.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__plain_8c.html#a1322e5670005e0bac0da12a791570e83">plain_kill_sec()</a>, <a class="el" href="gss__internal_8h.html#ac32200df78f9c91e30d9a815e4a6766c">gss_sec_kill()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01282">sptlrpc_sec_kill()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3722080e66868d83901a114d4ac3897"></a><!-- doxytag: member="ptlrpc_sec_cops::lookup_ctx" ref="ab3722080e66868d83901a114d4ac3897" args=")(struct ptlrpc_sec *sec, struct vfs_cred *vcred, int create, int remove_dead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>*(* <a class="el" href="structptlrpc__sec__cops.html#ab3722080e66868d83901a114d4ac3897">ptlrpc_sec_cops::lookup_ctx</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structvfs__cred.html">vfs_cred</a> *vcred, int create, int remove_dead)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given <em>vcred</em>, lookup and/or create its context. </p>
<p>The policy module is supposed to maintain its own context cache. XXX currently <em>create</em> and <em>remove_dead</em> is always 1, perhaps should be removed completely.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a95aace0167d20c2a956c285df7be0af4">null_lookup_ctx()</a>, <a class="el" href="sec__plain_8c.html#a6ea32f5668a9191c0028a16ecfcba06d">plain_lookup_ctx()</a>, <a class="el" href="gss__keyring_8c.html#a505ff4936cd36347d5bfc58cc0768a52">gss_sec_lookup_ctx_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00271">get_my_ctx()</a>.</p>

</div>
</div>
<a class="anchor" id="aabc06c431b7e2b62d2d81f0707834122"></a><!-- doxytag: member="ptlrpc_sec_cops::release_ctx" ref="aabc06c431b7e2b62d2d81f0707834122" args=")(struct ptlrpc_sec *sec, struct ptlrpc_cli_ctx *ctx, int sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__cops.html#aabc06c431b7e2b62d2d81f0707834122">ptlrpc_sec_cops::release_ctx</a>)(struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, int sync)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called then the reference of <em>ctx</em> dropped to 0. </p>
<p>The policy module is supposed to destroy this context or whatever else according to its cache maintainance mechamism.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sync</em>&nbsp;</td><td>if zero, we shouldn't wait for the context being destroyed completely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__plain_8c.html#af2c4e09b334e032251761e5bd8e7001a">plain_release_ctx()</a>, <a class="el" href="gss__keyring_8c.html#ac6129db720554623b2cc23b0a77f3ec9">gss_sec_release_ctx_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00303">sptlrpc_cli_ctx_put()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:54 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
