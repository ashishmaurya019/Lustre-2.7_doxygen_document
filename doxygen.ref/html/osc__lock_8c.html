<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osc/osc_lock.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/osc/osc_lock.c File Reference</h1><code>#include &lt;<a class="el" href="libcfs_8h_source.html">libcfs/libcfs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__fid_8h_source.html">lustre_fid.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>&quot;</code><br/>

<p><a href="osc__lock_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="osc__lock_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>&nbsp;&nbsp;&nbsp;S_OSC</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d">osc_lock_to_lockless</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__lock.html">osc_lock</a> *ols, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the lock should be converted into a lockless lock.  <a href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a> (const struct <a class="el" href="structosc__lock.html">osc_lock</a> *olck)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga95f7cfb7218e8b72b11725001f63b02c">osc_handle_ptr</a> (struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a weak pointer to the ldlm lock identified by a handle.  <a href="group__osc.html#ga95f7cfb7218e8b72b11725001f63b02c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e">osc_lock_invariant</a> (struct <a class="el" href="structosc__lock.html">osc_lock</a> *ols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invariant that has to be true all of the time.  <a href="group__osc.html#ga54adc12953bce11081c44d696c8b147e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gab6bded0dd5d3b8886cb39393501ee7e3">osc_lock_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaa5a7b973cac7b99a2bd42990c4d5f368">osc_lock_build_policy</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga8dd2b15bab97b5408114762ab5c22c95">osc_enq2ldlm_flags</a> (__u32 enqflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7">osc_lock_lvb_update</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *osc, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock, struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates object attributes from a lock value block (lvb) received together with the DLM lock reply from the server.  <a href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga5bd9e2d847a8448e23dcf09c6b73766f">osc_lock_granted</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__lock.html">osc_lock</a> *oscl, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, bool lvb_update)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga29f791d1abf24609d793f38771cc90b3">osc_lock_upcall</a> (void *cookie, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, int errcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock upcall function that is executed either when a reply to ENQUEUE rpc is received from a server, or after <a class="el" href="osc__internal_8h.html#aad7a0f5242c750c4920c0b3f801ea07f">osc_enqueue_base()</a> matched a local DLM lock.  <a href="group__osc.html#ga29f791d1abf24609d793f38771cc90b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaf9b0a5fcc4fbfa6437afc998a0b8657d">osc_lock_upcall_agl</a> (void *cookie, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, int errcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga3a7f4b12063dd00ce41a418fb3818e39">osc_lock_flush</a> (struct <a class="el" href="structosc__object.html">osc_object</a> *obj, pgoff_t <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, pgoff_t end, enum <a class="el" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">cl_lock_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, int discard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaa7b3a2727168eb22303066140b94eef4">osc_dlm_blocking_ast0</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock, void *data, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for osc_dlm_blocking_ast() handling discrepancies between <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> and <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> caches.  <a href="group__osc.html#gaa7b3a2727168eb22303066140b94eef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga3d96731374882d1b601e94dab8f92397">osc_ldlm_blocking_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *new, void *data, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocking ast invoked by ldlm when dlm lock is either blocking progress of some other lock, or is canceled.  <a href="group__osc.html#ga3d96731374882d1b601e94dab8f92397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gabeb20790e130bf97ca7999f0832fba5f">osc_ldlm_glimpse_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga3b7c17bc704a969f4148b6735fb9d7dc">weigh_cb</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structosc__page.html">osc_page</a> *ops, void *cbdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga9325a913aeaac8dbe7867ac4a8e86a12">osc_lock_weight</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *oscobj, struct <a class="el" href="structldlm__extent.html">ldlm_extent</a> *extent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga35e11197afdf291ad1614fe6217d4108">osc_ldlm_weigh_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the weight of dlm lock for early cancellation.  <a href="group__osc.html#ga35e11197afdf291ad1614fe6217d4108"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaf9d3972737301af659fe94269be36549">osc_lock_build_einfo</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, struct <a class="el" href="structosc__object.html">osc_object</a> *osc, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gab65f4d86251c42976f7a34615d12d7fb">osc_lock_compatible</a> (const struct <a class="el" href="structosc__lock.html">osc_lock</a> *qing, const struct <a class="el" href="structosc__lock.html">osc_lock</a> *qed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">osc_lock_wake_waiters</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *osc, struct <a class="el" href="structosc__lock.html">osc_lock</a> *oscl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gab799760ac0c7ccb8e4f6b7f109ad619e">osc_lock_enqueue_wait</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, struct <a class="el" href="structosc__lock.html">osc_lock</a> *oscl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2">osc_lock_enqueue</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *unused, struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *anchor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="structcl__lock__operations.html#ac662a1c9135cac8c084a7c95d6fc19d7" title="Attempts to enqueue the lock.">cl_lock_operations::clo_enqueue()</a> method for osc layer.  <a href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df">osc_lock_detach</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__lock.html">osc_lock</a> *olck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Breaks a link between <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> and dlm_lock.  <a href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0">osc_lock_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements <a class="el" href="structcl__lock__operations.html#adac391a682e572a776b39e552fa6e931" title="Cancel a lock, release its DLM lock ref, while does not cancel the DLM lock.">cl_lock_operations::clo_cancel()</a> method for osc layer.  <a href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga3448ad07c07772caeab7bc754ce00c9f">osc_lock_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p, const struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaf0377559340dde5b6d5c16cfabc67d64">osc_lock_lockless_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> *slice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga7e5994ba02ffc93e8e2ccc8d91c4b19e">osc_lock_set_writer</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structosc__lock.html">osc_lock</a> *oscl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gabd5ab860e2021ff6b4cd161a7392744a">osc_lock_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga8977a8e1e24c419f01c5a96f6fbf65a2">osc_dlmlock_at_pgoff</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, pgoff_t index, enum <a class="el" href="osc__internal_8h.html#a89099d25428f6679c80d1b0bffc08660">osc_dap_flags</a> dap_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an existing lock covering given index and optionally different from a given <em>except</em> lock.  <a href="group__osc.html#ga8977a8e1e24c419f01c5a96f6fbf65a2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__lock__operations.html">cl_lock_operations</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaf69bf16bf23d5ce82362b480fcb0a331">osc_lock_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcl__lock__operations.html">cl_lock_operations</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="osc_lock.c::DEBUG_SUBSYSTEM" ref="abda60744d497fcfe370cfd6b2d65c7ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SUBSYSTEM&nbsp;&nbsp;&nbsp;S_OSC</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="osc__lock_8c_source.html#l00042">42</a> of file <a class="el" href="osc__lock_8c_source.html">osc_lock.c</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:49 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
