<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osc/osc_page.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/osc/osc_page.c</h1><a href="osc__page_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * Implementation of cl_page for OSC layer.</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *   Author: Nikita Danilov &lt;nikita.danilov@sun.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> *   Author: Jinshan Xiong &lt;jinshan.xiong@intel.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="osc__page_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">00042</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_OSC</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="osc__cl__internal_8h.html">osc_cl_internal.h</a>&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga3bfb464116e04404400ef71fa34298de" title="Page is being destroyed.">osc_lru_del</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg);
<a name="l00047"></a>00047 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaf9beb39b2726984894d0264480dba48f" title="Delete page from LRUlist for redirty.">osc_lru_use</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg);
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gad3d816668d6cfc8e6ff86c4bae42db4e" title="osc_lru_alloc() is called to allocate an LRU slot for a cl_page.">osc_lru_alloc</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli,
<a name="l00049"></a>00049                          <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg);
<a name="l00050"></a>00050 
<a name="l00055"></a>00055 <span class="comment">/*</span>
<a name="l00056"></a>00056 <span class="comment"> * Comment out osc_page_protected because it may sleep inside the</span>
<a name="l00057"></a>00057 <span class="comment"> * the client_obd_list_lock.</span>
<a name="l00058"></a>00058 <span class="comment"> * client_obd_list_lock -&gt; osc_ap_completion -&gt; osc_completion -&gt;</span>
<a name="l00059"></a>00059 <span class="comment"> *   -&gt; osc_page_protected -&gt; osc_page_is_dlocked -&gt; osc_match_base</span>
<a name="l00060"></a>00060 <span class="comment"> *   -&gt; ldlm_lock_match -&gt; sptlrpc_import_check_ctx -&gt; sleep.</span>
<a name="l00061"></a>00061 <span class="comment"> */</span>
<a name="l00062"></a>00062 <span class="preprocessor">#if 0</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> osc_page_is_dlocked(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00064"></a>00064                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00065"></a>00065                                <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> <a class="code" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <span class="keywordtype">int</span> pending, <span class="keywordtype">int</span> unref)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>         *page;
<a name="l00068"></a>00068         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>      *obj;
<a name="l00069"></a>00069         <span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a> *info;
<a name="l00070"></a>00070         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a>     *resname;
<a name="l00071"></a>00071         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>   *lockh;
<a name="l00072"></a>00072         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy;
<a name="l00073"></a>00073         <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a>          dlmmode;
<a name="l00074"></a>00074         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   flags;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         might_sleep();
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         info = <a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env);
<a name="l00079"></a>00079         resname = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a4ddc57930642d6fa4191333d22ed2d4b">oti_resname</a>;
<a name="l00080"></a>00080         policy = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a2fee545583b6ef8741d83fbb3d42dae1">oti_policy</a>;
<a name="l00081"></a>00081         lockh = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a471bd51d9f3964d965320255fd72f320">oti_handle</a>;
<a name="l00082"></a>00082         page = opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00083"></a>00083         obj = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         flags = <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a> | <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>;
<a name="l00086"></a>00086         <span class="keywordflow">if</span> (pending)
<a name="l00087"></a>00087                 flags |= <a class="code" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc" title="this lock is being destroyed">LDLM_FL_CBPENDING</a>;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         dlmmode = <a class="code" href="group__osc.html#ga10c33ef023f6e4826b12f531287ecb74">osc_cl_lock2ldlm</a>(mode) | <a class="code" href="packet-lustre_8c.html#acfddf2f902384575528f1e893c561afc">LCK_PW</a>;
<a name="l00090"></a>00090         osc_lock_build_res(env, obj, resname);
<a name="l00091"></a>00091         <a class="code" href="group__osc.html#ga5023e2c6d3427c41c4f8002c8845bcfe">osc_index2policy</a>(policy, page-&gt;<a class="code" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cp_obj</a>, <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg), <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg));
<a name="l00092"></a>00092         <span class="keywordflow">return</span> <a class="code" href="osc__internal_8h.html#af6ccff10ed40679babebb500c67e4930">osc_match_base</a>(<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(obj), resname, <a class="code" href="packet-lustre_8c.html#ab92227eb33b3bc79ee12e10421865cad">LDLM_EXTENT</a>, policy,
<a name="l00093"></a>00093                               dlmmode, &amp;flags, NULL, lockh, unref);
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00101"></a>00101                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00102"></a>00102                               <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> mode, <span class="keywordtype">int</span> unref)
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104         <span class="keyword">struct </span><a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a> *hdr;
<a name="l00105"></a>00105         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>          *scan;
<a name="l00106"></a>00106         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>          *page;
<a name="l00107"></a>00107         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a>    *descr;
<a name="l00108"></a>00108         <span class="keywordtype">int</span> result;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(!opg-&gt;<a class="code" href="structosc__page.html#a3169ca9d568a6d318b2e9e15ecfd27fa" title="True for a `temporary page&amp;#39; created by read-ahead code, probably outside of any...">ops_temp</a>);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         page = opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00113"></a>00113         <span class="keywordflow">if</span> (page-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a> != NULL &amp;&amp;
<a name="l00114"></a>00114             <a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(page-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a>)-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bacfd43489ba9d674ad77c4bdd51d3a7bc" title="Never lock: there is no cache (e.g., liblustre).">CILR_NEVER</a>)
<a name="l00115"></a>00115                 <span class="comment">/*</span>
<a name="l00116"></a>00116 <span class="comment">                 * If IO is done without locks (liblustre, or lloop), lock is</span>
<a name="l00117"></a>00117 <span class="comment">                 * not required.</span>
<a name="l00118"></a>00118 <span class="comment">                 */</span>
<a name="l00119"></a>00119                 result = 1;
<a name="l00120"></a>00120         <span class="keywordflow">else</span>
<a name="l00121"></a>00121                 <span class="comment">/* otherwise check for a DLM lock */</span>
<a name="l00122"></a>00122         result = osc_page_is_dlocked(env, opg, mode, 1, unref);
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (result == 0) {
<a name="l00124"></a>00124                 <span class="comment">/* maybe this page is a part of a lockless io? */</span>
<a name="l00125"></a>00125                 hdr = <a class="code" href="group__clio.html#gad17616130821a452cbc77936980c2170">cl_object_header</a>(opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00126"></a>00126                 descr = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#a64ecf31ad9813f3bedec62a5a0bf545f">oti_descr</a>;
<a name="l00127"></a>00127                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> = mode;
<a name="l00128"></a>00128                 descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> = <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg);
<a name="l00129"></a>00129                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>   = <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg);
<a name="l00130"></a>00130                 spin_lock(&amp;hdr-&gt;coh_lock_guard);
<a name="l00131"></a>00131                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(scan, &amp;hdr-&gt;coh_locks, cll_linkage) {
<a name="l00132"></a>00132                         <span class="comment">/*</span>
<a name="l00133"></a>00133 <span class="comment">                         * Lock-less sub-lock has to be either in HELD state</span>
<a name="l00134"></a>00134 <span class="comment">                         * (when io is actively going on), or in CACHED state,</span>
<a name="l00135"></a>00135 <span class="comment">                         * when top-lock is being unlocked:</span>
<a name="l00136"></a>00136 <span class="comment">                         * cl_io_unlock()-&gt;cl_unuse()-&gt;...-&gt;lov_lock_unuse().</span>
<a name="l00137"></a>00137 <span class="comment">                         */</span>
<a name="l00138"></a>00138                         <span class="keywordflow">if</span> ((scan-&gt;cll_state == CLS_HELD ||
<a name="l00139"></a>00139                              scan-&gt;cll_state == CLS_CACHED) &amp;&amp;
<a name="l00140"></a>00140                             cl_lock_ext_match(&amp;scan-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>, descr)) {
<a name="l00141"></a>00141                                 <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *olck;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143                                 olck = <a class="code" href="group__osc.html#ga84a80676350de280c21124330f8509e0">osc_lock_at</a>(scan);
<a name="l00144"></a>00144                                 result = <a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(olck);
<a name="l00145"></a>00145                                 <span class="keywordflow">break</span>;
<a name="l00146"></a>00146                         }
<a name="l00147"></a>00147                 }
<a name="l00148"></a>00148                 spin_unlock(&amp;hdr-&gt;coh_lock_guard);
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150         <span class="keywordflow">return</span> result;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 <span class="preprocessor">#else</span>
<a name="l00153"></a><a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">00153</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00154"></a>00154                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00155"></a>00155                               <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> mode, <span class="keywordtype">int</span> unref)
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157         <span class="keywordflow">return</span> 1;
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 <span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>
<a name="l00161"></a>00161 <span class="comment">/*****************************************************************************</span>
<a name="l00162"></a>00162 <span class="comment"> *</span>
<a name="l00163"></a>00163 <span class="comment"> * Page operations.</span>
<a name="l00164"></a>00164 <span class="comment"> *</span>
<a name="l00165"></a>00165 <span class="comment"> */</span>
<a name="l00166"></a><a class="code" href="group__osc.html#gaef0e98d65a1cb06f7206f01a0096392b">00166</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaef0e98d65a1cb06f7206f01a0096392b">osc_page_transfer_get</a>(<span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg, <span class="keyword">const</span> <span class="keywordtype">char</span> *label)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page = opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a>);
<a name="l00171"></a>00171         <a class="code" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13" title="Acquires an additional reference to a page.">cl_page_get</a>(page);
<a name="l00172"></a>00172         <a class="code" href="group__lu__ref.html#ga53f12cf34123caa33e548e6884577b78">lu_ref_add_atomic</a>(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, label, page);
<a name="l00173"></a>00173         opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a> = 1;
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a><a class="code" href="group__osc.html#ga0471f9eae5fc88013c61d30a43ab6fb6">00176</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga0471f9eae5fc88013c61d30a43ab6fb6">osc_page_transfer_put</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00177"></a>00177                                   <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page = opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         <span class="keywordflow">if</span> (opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a>) {
<a name="l00182"></a>00182                 opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a> = 0;
<a name="l00183"></a>00183                 <a class="code" href="group__lu__ref.html#ga9502d6573eadb28a4ea33ff6482e1752">lu_ref_del</a>(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, <span class="stringliteral">&quot;transfer&quot;</span>, page);
<a name="l00184"></a>00184                 <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, page);
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00193"></a><a class="code" href="group__osc.html#ga925522309d1e870b6317c13595114a4b">00193</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga925522309d1e870b6317c13595114a4b" title="This is called once for every page when it is submitted for a transfer either opportunistic...">osc_page_transfer_add</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00194"></a>00194                                   <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg, <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> crt)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *obj = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="comment">/* ops_lru and ops_inflight share the same field, so take it from LRU</span>
<a name="l00199"></a>00199 <span class="comment">         * first and then use it as inflight. */</span>
<a name="l00200"></a>00200         <a class="code" href="group__osc.html#gaf9beb39b2726984894d0264480dba48f" title="Delete page from LRUlist for redirty.">osc_lru_use</a>(<a class="code" href="group__osc.html#gae06087775e3f624877cb35cd9a0c80fe">osc_cli</a>(obj), opg);
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00203"></a><a class="code" href="group__osc.html#ga191a56f071d6752db73aed4510a49639">00203</a> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga191a56f071d6752db73aed4510a49639">osc_page_cache_add</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00204"></a>00204                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00207"></a>00207         <span class="keywordtype">int</span> result;
<a name="l00208"></a>00208         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg, <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a>, 0));
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         <a class="code" href="group__osc.html#gaef0e98d65a1cb06f7206f01a0096392b">osc_page_transfer_get</a>(opg, <span class="stringliteral">&quot;transfer\0cache&quot;</span>);
<a name="l00213"></a>00213         result = <a class="code" href="group__osc.html#gaa5ccfa774e02b3b82a4ef0ae1d9bc936">osc_queue_async_io</a>(env, io, opg);
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (result != 0)
<a name="l00215"></a>00215                 <a class="code" href="group__osc.html#ga0471f9eae5fc88013c61d30a43ab6fb6">osc_page_transfer_put</a>(env, opg);
<a name="l00216"></a>00216         <span class="keywordflow">else</span>
<a name="l00217"></a>00217                 <a class="code" href="group__osc.html#ga925522309d1e870b6317c13595114a4b" title="This is called once for every page when it is submitted for a transfer either opportunistic...">osc_page_transfer_add</a>(env, opg, <a class="code" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e">CRT_WRITE</a>);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="group__osc.html#ga5023e2c6d3427c41c4f8002c8845bcfe">00222</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga5023e2c6d3427c41c4f8002c8845bcfe">osc_index2policy</a>(<span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy,
<a name="l00223"></a>00223                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, pgoff_t <a class="code" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, pgoff_t <a class="code" href="mdsrate_8c.html#abce9f5dc9c83f2639b72024fdee5d388">end</a>)
<a name="l00224"></a>00224 {
<a name="l00225"></a>00225         memset(policy, 0, <span class="keyword">sizeof</span> *policy);
<a name="l00226"></a>00226         policy-&gt;<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#af09bacd52ee801eb10e12807fc6ed5b7">start</a> = <a class="code" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515" title="Converts a byte offset within object obj into a page index.">cl_offset</a>(obj, start);
<a name="l00227"></a>00227         policy-&gt;<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>   = <a class="code" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515" title="Converts a byte offset within object obj into a page index.">cl_offset</a>(obj, end + 1) - 1;
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">00230</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="writemany_8c.html#af39400667a953a7c5c34e3964aa1ce9f">head</a>)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232         <span class="keywordflow">return</span> <a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(head) ? <span class="stringliteral">&quot;-&quot;</span> : <span class="stringliteral">&quot;+&quot;</span>;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a><a class="code" href="group__osc.html#ga60696e19562a4a322b062b4ec96db649">00235</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a> <a class="code" href="group__osc.html#ga60696e19562a4a322b062b4ec96db649">osc_submit_duration</a>(<span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237         <span class="keywordflow">if</span> (opg-&gt;<a class="code" href="structosc__page.html#ae2717ab94b4940fbd543f76a06d3e289" title="Submit time - the time when the page is starting RPC.">ops_submit_time</a> == 0)
<a name="l00238"></a>00238                 <span class="keywordflow">return</span> 0;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="keywordflow">return</span> (<a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>() - opg-&gt;<a class="code" href="structosc__page.html#ae2717ab94b4940fbd543f76a06d3e289" title="Submit time - the time when the page is starting RPC.">ops_submit_time</a>);
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="group__osc.html#ga588f41464fa8615c958a1691612f7579">00243</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga588f41464fa8615c958a1691612f7579">osc_page_print</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00244"></a>00244                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00245"></a>00245                           <span class="keywordtype">void</span> *cookie, <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> printer)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>       *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00248"></a>00248         <span class="keyword">struct </span><a class="code" href="structosc__async__page.html">osc_async_page</a> *oap = &amp;opg-&gt;<a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>;
<a name="l00249"></a>00249         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>     *obj = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00250"></a>00250         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a>     *cli = &amp;<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(obj)-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#aebe227afed9945c803b5bda6794bb729">u</a>.<a class="code" href="structobd__device.html#aab14b15f2359afc1da23bbc47decdd0c">cli</a>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <span class="keywordflow">return</span> (*printer)(env, cookie, <a class="code" href="obd_8h.html#a2ae5b0d66c37e995d787f3ed67a050c0">LUSTRE_OSC_NAME</a><span class="stringliteral">&quot;-page@%p %lu: &quot;</span>
<a name="l00253"></a>00253                           <span class="stringliteral">&quot;1&lt; %#x %d %u %s %s &gt; &quot;</span>
<a name="l00254"></a>00254                           <span class="stringliteral">&quot;2&lt; &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a414a71ca04d1db8d7875631cf51d45bf">LPD64</a><span class="stringliteral">&quot; %u %u %#x %#x | %p %p %p &gt; &quot;</span>
<a name="l00255"></a>00255                           <span class="stringliteral">&quot;3&lt; %d %lu %d &gt; &quot;</span>
<a name="l00256"></a>00256                           <span class="stringliteral">&quot;4&lt; %d %d %d %lu %s | %s %s %s %s &gt; &quot;</span>
<a name="l00257"></a>00257                           <span class="stringliteral">&quot;5&lt; %s %s %s %s | %d %s | %d %s %s&gt;\n&quot;</span>,
<a name="l00258"></a>00258                           opg, <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg),
<a name="l00259"></a>00259                           <span class="comment">/* 1 */</span>
<a name="l00260"></a>00260                           oap-&gt;<a class="code" href="structosc__async__page.html#a1ffd70fa26e32a37cdaa1de458fc56a8">oap_magic</a>, oap-&gt;<a class="code" href="structosc__async__page.html#a76447e742bffe1bd81580d3bf39f4dae">oap_cmd</a>,
<a name="l00261"></a>00261                           oap-&gt;<a class="code" href="structosc__async__page.html#a994ce3a16c1c45fad476a9aa32a2471b">oap_interrupted</a>,
<a name="l00262"></a>00262                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;oap-&gt;<a class="code" href="structosc__async__page.html#ade93ff9642d3b45ff804080a94d13d4a">oap_pending_item</a>),
<a name="l00263"></a>00263                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;oap-&gt;<a class="code" href="structosc__async__page.html#ab766f019caba46ae364dd38b305fd7fc">oap_rpc_item</a>),
<a name="l00264"></a>00264                           <span class="comment">/* 2 */</span>
<a name="l00265"></a>00265                           oap-&gt;<a class="code" href="structosc__async__page.html#a46868243e9e11db9a58be3a4dc846401">oap_obj_off</a>, oap-&gt;<a class="code" href="structosc__async__page.html#af981fcaae58646f2063b882e811e105f">oap_page_off</a>, oap-&gt;oap_count,
<a name="l00266"></a>00266                           oap-&gt;<a class="code" href="structosc__async__page.html#ac3fda41438a7390f71a21154dbf86fd6">oap_async_flags</a>, oap-&gt;oap_brw_flags,
<a name="l00267"></a>00267                           oap-&gt;<a class="code" href="structosc__async__page.html#a4d3fda51f2734fd5dc7cfe20c322b8ca">oap_request</a>, oap-&gt;<a class="code" href="structosc__async__page.html#a4b2e11512a9371853a69c1209467b111">oap_cli</a>, obj,
<a name="l00268"></a>00268                           <span class="comment">/* 3 */</span>
<a name="l00269"></a>00269                           opg-&gt;ops_transfer_pinned,
<a name="l00270"></a>00270                           <a class="code" href="group__osc.html#ga60696e19562a4a322b062b4ec96db649">osc_submit_duration</a>(opg), opg-&gt;ops_srvlock,
<a name="l00271"></a>00271                           <span class="comment">/* 4 */</span>
<a name="l00272"></a>00272                           cli-&gt;<a class="code" href="structclient__obd.html#a557165b1961d70ca9a09a83f70e33f70">cl_r_in_flight</a>, cli-&gt;<a class="code" href="structclient__obd.html#ad0503c92679f7b9827471f0ff62f5a87">cl_w_in_flight</a>,
<a name="l00273"></a>00273                           cli-&gt;<a class="code" href="structclient__obd.html#a8e77a281528593754771125a793b0cec">cl_max_rpcs_in_flight</a>,
<a name="l00274"></a>00274                           cli-&gt;<a class="code" href="structclient__obd.html#a4dc7afcfe4ced702cff6034f78c79e42">cl_avail_grant</a>,
<a name="l00275"></a>00275                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a722ad02b16131a6676447f5b10c7e122">cl_cache_waiters</a>),
<a name="l00276"></a>00276                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#afba14d439840d4aee82ce9ac28df0ae3">cl_loi_ready_list</a>),
<a name="l00277"></a>00277                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a8396cc7ebf0b414c4ab140eaac228731">cl_loi_hp_ready_list</a>),
<a name="l00278"></a>00278                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a10aecd518ef0b24a6bdf7550438d5463">cl_loi_write_list</a>),
<a name="l00279"></a>00279                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a9efb728193b2aabc5d39b371d210d62d">cl_loi_read_list</a>),
<a name="l00280"></a>00280                           <span class="comment">/* 5 */</span>
<a name="l00281"></a>00281                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a19d2ca658694060f0f358885959fa46d" title="used by the osc to keep track of what objects to build into rpcs.">oo_ready_item</a>),
<a name="l00282"></a>00282                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a2761a3c0fa974a7047b9fb5cf053cc47">oo_hp_ready_item</a>),
<a name="l00283"></a>00283                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#ad889bed4dd5b40a79ffa5a23c282b3f0">oo_write_item</a>),
<a name="l00284"></a>00284                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a716fd5815101c1981a5986c4f76cbb6a">oo_read_item</a>),
<a name="l00285"></a>00285                           atomic_read(&amp;obj-&gt;<a class="code" href="structosc__object.html#a168b7fe54e363cebe29d3f46be9251ae">oo_nr_reads</a>),
<a name="l00286"></a>00286                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a4afd7daab9748a9408f27416600d51e9">oo_reading_exts</a>),
<a name="l00287"></a>00287                           atomic_read(&amp;obj-&gt;<a class="code" href="structosc__object.html#ae30dfba305747b75f6b71a53f4db78d4">oo_nr_writes</a>),
<a name="l00288"></a>00288                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a4f61788f7362518e03287458c7bb1006" title="Manage write(dirty) extents.">oo_hp_exts</a>),
<a name="l00289"></a>00289                           <a class="code" href="group__osc.html#gae2afadc16f0731dc8bbf9e71f18a5835">osc_list</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#a7b750a3cadc3f6c1451a3e4d2874bd79">oo_urgent_exts</a>));
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a><a class="code" href="group__osc.html#ga44b16168cf595ce24f67e0ff359f7a2d">00292</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga44b16168cf595ce24f67e0ff359f7a2d">osc_page_delete</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00293"></a>00293                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>   *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00296"></a>00296         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *obj = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00297"></a>00297         <span class="keywordtype">int</span> rc;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(opg-&gt;<a class="code" href="structosc__page.html#a3169ca9d568a6d318b2e9e15ecfd27fa" title="True for a `temporary page&amp;#39; created by read-ahead code, probably outside of any...">ops_temp</a> || <a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg, <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 1));
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00302"></a>00302         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a0d8304d29c79bce29fd8bc194e9b1df0">D_TRACE</a>, <span class="stringliteral">&quot;%p\n&quot;</span>, opg);
<a name="l00303"></a>00303         <a class="code" href="group__osc.html#ga0471f9eae5fc88013c61d30a43ab6fb6">osc_page_transfer_put</a>(env, opg);
<a name="l00304"></a>00304         rc = <a class="code" href="group__osc.html#ga6ea34d6cb6b65bbd9ed9e7322b5589cd">osc_teardown_async_page</a>(env, obj, opg);
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (rc) {
<a name="l00306"></a>00306                 <a class="code" href="group__cl__page.html#ga912e7c9c7d73f184c724593eb42f857a" title="Helper macro, dumping detailed information about page into a log.">CL_PAGE_DEBUG</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, env, slice-&gt;<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>,
<a name="l00307"></a>00307                               <span class="stringliteral">&quot;Trying to teardown failed: %d\n&quot;</span>, rc);
<a name="l00308"></a>00308                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(0);
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <a class="code" href="group__osc.html#ga3bfb464116e04404400ef71fa34298de" title="Page is being destroyed.">osc_lru_del</a>(<a class="code" href="group__osc.html#gae06087775e3f624877cb35cd9a0c80fe">osc_cli</a>(obj), opg);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         <span class="keywordflow">if</span> (slice-&gt;<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>-&gt;<a class="code" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467" title="Page type.">cp_type</a> == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a>) {
<a name="l00314"></a>00314                 <span class="keywordtype">void</span> *value;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316                 spin_lock(&amp;obj-&gt;<a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e" title="Radix tree for caching pages.">oo_tree_lock</a>);
<a name="l00317"></a>00317                 value = radix_tree_delete(&amp;obj-&gt;<a class="code" href="structosc__object.html#ac81d5ea1f8e29b67fb18123bae453988">oo_tree</a>, <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(opg));
<a name="l00318"></a>00318                 <span class="keywordflow">if</span> (value != NULL)
<a name="l00319"></a>00319                         --obj-&gt;<a class="code" href="structosc__object.html#abc26471bd853917f2ef75eefed13b84f">oo_npages</a>;
<a name="l00320"></a>00320                 spin_unlock(&amp;obj-&gt;<a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e" title="Radix tree for caching pages.">oo_tree_lock</a>);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(value != NULL, value == opg));
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a><a class="code" href="group__osc.html#ga7ae4ea444477a2b8d430ca6b2581a20d">00328</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga7ae4ea444477a2b8d430ca6b2581a20d">osc_page_clip</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00329"></a>00329                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00330"></a>00330                           <span class="keywordtype">int</span> from, <span class="keywordtype">int</span> to)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>       *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00333"></a>00333         <span class="keyword">struct </span><a class="code" href="structosc__async__page.html">osc_async_page</a> *oap = &amp;opg-&gt;<a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg, <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 0));
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         opg-&gt;<a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6" title="An offset within page from which next transfer starts.">ops_from</a> = from;
<a name="l00338"></a>00338         opg-&gt;<a class="code" href="structosc__page.html#a77cefd1ebc7f1f0e4230b98979b71159" title="An offset within page at which next transfer ends.">ops_to</a>   = to;
<a name="l00339"></a>00339         spin_lock(&amp;oap-&gt;<a class="code" href="structosc__async__page.html#a5e8aefd6a65eec366726a17ed4a40d9a">oap_lock</a>);
<a name="l00340"></a>00340         oap-&gt;<a class="code" href="structosc__async__page.html#ac3fda41438a7390f71a21154dbf86fd6">oap_async_flags</a> |= <a class="code" href="osc__internal_8h.html#a36cf53ab9257aa954efdd53080c6c74dad52ed9228404b8af90de9f6d70451d1b">ASYNC_COUNT_STABLE</a>;
<a name="l00341"></a>00341         spin_unlock(&amp;oap-&gt;<a class="code" href="structosc__async__page.html#a5e8aefd6a65eec366726a17ed4a40d9a">oap_lock</a>);
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="group__osc.html#ga5bcdf3c9bd3b0482012b4554a08c901d">00344</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga5bcdf3c9bd3b0482012b4554a08c901d">osc_page_cancel</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00345"></a>00345                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00348"></a>00348         <span class="keywordtype">int</span> rc = 0;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg, <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 0));
<a name="l00351"></a>00351 
<a name="l00352"></a>00352         <span class="comment">/* Check if the transferring against this page</span>
<a name="l00353"></a>00353 <span class="comment">         * is completed, or not even queued. */</span>
<a name="l00354"></a>00354         <span class="keywordflow">if</span> (opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a>)
<a name="l00355"></a>00355                 <span class="comment">/* FIXME: may not be interrupted.. */</span>
<a name="l00356"></a>00356                 rc = <a class="code" href="group__osc.html#gad22b15d739092f8a8d27214eff304e66" title="this is called when a sync waiter receives an interruption.">osc_cancel_async_page</a>(env, opg);
<a name="l00357"></a>00357         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(rc == 0, opg-&gt;<a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a> == 0));
<a name="l00358"></a>00358         <span class="keywordflow">return</span> rc;
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a><a class="code" href="group__osc.html#ga6beb7ac39754304f2c126c8f1efdbf8c">00361</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga6beb7ac39754304f2c126c8f1efdbf8c">osc_page_flush</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00362"></a>00362                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00363"></a>00363                           <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg = <a class="code" href="group__osc.html#ga0b812b6becf5106791d5bd7c9126e7cf">cl2osc_page</a>(slice);
<a name="l00366"></a>00366         <span class="keywordtype">int</span> rc = 0;
<a name="l00367"></a>00367         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00368"></a>00368         rc = <a class="code" href="group__osc.html#gacbca1d2858196fd14f5de2a27cb7c857" title="This is called when a page is picked up by kernel to write out.">osc_flush_async_page</a>(env, io, opg);
<a name="l00369"></a>00369         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a><a class="code" href="group__osc.html#gaa294766b9587b701f2a57f07f8236c94">00372</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__page__operations.html" title="Per-layer page operations.">cl_page_operations</a> <a class="code" href="group__osc.html#gaa294766b9587b701f2a57f07f8236c94">osc_page_ops</a> = {
<a name="l00373"></a>00373         .<a class="code" href="structcl__page__operations.html#a2ad2c255ac9556a954937b2dde91d8fe" title="Optional debugging helper.">cpo_print</a>         = <a class="code" href="group__osc.html#ga588f41464fa8615c958a1691612f7579">osc_page_print</a>,
<a name="l00374"></a>00374         .cpo_delete        = <a class="code" href="group__osc.html#ga44b16168cf595ce24f67e0ff359f7a2d">osc_page_delete</a>,
<a name="l00375"></a>00375         .cpo_clip           = <a class="code" href="group__osc.html#ga7ae4ea444477a2b8d430ca6b2581a20d">osc_page_clip</a>,
<a name="l00376"></a>00376         .cpo_cancel         = <a class="code" href="group__osc.html#ga5bcdf3c9bd3b0482012b4554a08c901d">osc_page_cancel</a>,
<a name="l00377"></a>00377         .cpo_flush          = <a class="code" href="group__osc.html#ga6beb7ac39754304f2c126c8f1efdbf8c">osc_page_flush</a>
<a name="l00378"></a>00378 };
<a name="l00379"></a>00379 
<a name="l00380"></a><a class="code" href="group__osc.html#ga633c62b020126f225e1b0df1dc284251">00380</a> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga633c62b020126f225e1b0df1dc284251">osc_page_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00381"></a>00381                   <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *osc = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(obj);
<a name="l00384"></a>00384         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>   *opg = <a class="code" href="group__cl__object.html#ga22b6cf3a62d106fcfb7bee291d22ff70">cl_object_page_slice</a>(obj, page);
<a name="l00385"></a>00385         <span class="keywordtype">int</span> result;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         opg-&gt;<a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6" title="An offset within page from which next transfer starts.">ops_from</a> = 0;
<a name="l00388"></a>00388         opg-&gt;<a class="code" href="structosc__page.html#a77cefd1ebc7f1f0e4230b98979b71159" title="An offset within page at which next transfer ends.">ops_to</a>   = PAGE_CACHE_SIZE;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         result = <a class="code" href="group__osc.html#gad7357c1e41d1c62baf4fb61d51c2de71">osc_prep_async_page</a>(osc, opg, page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>,
<a name="l00391"></a>00391                                      <a class="code" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515" title="Converts a byte offset within object obj into a page index.">cl_offset</a>(obj, index));
<a name="l00392"></a>00392         <span class="keywordflow">if</span> (result == 0) {
<a name="l00393"></a>00393                 <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *oio = <a class="code" href="group__osc.html#ga80a9df989eeced2c8854e2e74214ce40">osc_env_io</a>(env);
<a name="l00394"></a>00394                 opg-&gt;<a class="code" href="structosc__page.html#a4ced8cb240b8ddf47fe922ecaae83de9" title="Set if the page must be transferred with OBD_BRW_SRVLOCK.">ops_srvlock</a> = <a class="code" href="group__osc.html#ga574c61fd176062ff468664693d241a06">osc_io_srvlock</a>(oio);
<a name="l00395"></a>00395                 <a class="code" href="group__clio.html#gaf9c2b2723494e52efc66d52fe2d0b93f" title="Adds page slice to the compound page.">cl_page_slice_add</a>(page, &amp;opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>, obj, index,
<a name="l00396"></a>00396                                   &amp;osc_page_ops);
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398         <span class="comment">/*</span>
<a name="l00399"></a>00399 <span class="comment">         * Cannot assert osc_page_protected() here as read-ahead</span>
<a name="l00400"></a>00400 <span class="comment">         * creates temporary pages outside of a lock.</span>
<a name="l00401"></a>00401 <span class="comment">         */</span>
<a name="l00402"></a>00402 <span class="preprocessor">#ifdef CONFIG_LUSTRE_DEBUG_EXPENSIVE_CHECK</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span>        opg-&gt;<a class="code" href="structosc__page.html#a3169ca9d568a6d318b2e9e15ecfd27fa" title="True for a `temporary page&amp;#39; created by read-ahead code, probably outside of any...">ops_temp</a> = !<a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg, <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 1);
<a name="l00404"></a>00404 <span class="preprocessor">#endif</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>        <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="comment">/* reserve an LRU space for this page */</span>
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (page-&gt;<a class="code" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467" title="Page type.">cp_type</a> == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a> &amp;&amp; result == 0) {
<a name="l00409"></a>00409                 result = <a class="code" href="group__osc.html#gad3d816668d6cfc8e6ff86c4bae42db4e" title="osc_lru_alloc() is called to allocate an LRU slot for a cl_page.">osc_lru_alloc</a>(env, <a class="code" href="group__osc.html#gae06087775e3f624877cb35cd9a0c80fe">osc_cli</a>(osc), opg);
<a name="l00410"></a>00410                 <span class="keywordflow">if</span> (result == 0) {
<a name="l00411"></a>00411                         spin_lock(&amp;osc-&gt;<a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e" title="Radix tree for caching pages.">oo_tree_lock</a>);
<a name="l00412"></a>00412                         result = radix_tree_insert(&amp;osc-&gt;<a class="code" href="structosc__object.html#ac81d5ea1f8e29b67fb18123bae453988">oo_tree</a>, index, opg);
<a name="l00413"></a>00413                         <span class="keywordflow">if</span> (result == 0)
<a name="l00414"></a>00414                                 ++osc-&gt;<a class="code" href="structosc__object.html#abc26471bd853917f2ef75eefed13b84f">oo_npages</a>;
<a name="l00415"></a>00415                         spin_unlock(&amp;osc-&gt;<a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e" title="Radix tree for caching pages.">oo_tree_lock</a>);
<a name="l00416"></a>00416                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(result == 0);
<a name="l00417"></a>00417                 }
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="keywordflow">return</span> result;
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00427"></a><a class="code" href="group__osc.html#gae4802860d91daed5d098a08f4ed45dea">00427</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gae4802860d91daed5d098a08f4ed45dea" title="Helper function called by osc_io_submit() for every page in an immediate transfer...">osc_page_submit</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00428"></a>00428                      <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> crt, <span class="keywordtype">int</span> brw_flags)
<a name="l00429"></a>00429 {
<a name="l00430"></a>00430         <span class="keyword">struct </span><a class="code" href="structosc__async__page.html">osc_async_page</a> *oap = &amp;opg-&gt;<a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>;
<a name="l00431"></a>00431         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>     *obj = oap-&gt;<a class="code" href="structosc__async__page.html#aeeebfecb02bbe7b36970d28f31895841">oap_obj</a>;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga347735e2bf147266c81506d8e32ab8f8">osc_page_protected</a>(env, opg,
<a name="l00434"></a>00434                                    crt == <a class="code" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e">CRT_WRITE</a> ? <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a> : <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>, 1));
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(oap-&gt;<a class="code" href="structosc__async__page.html#a1ffd70fa26e32a37cdaa1de458fc56a8">oap_magic</a> == <a class="code" href="osc__internal_8h.html#a22a2aa4f349895a0bbb4b1c6792c3ccf">OAP_MAGIC</a>, <span class="stringliteral">&quot;Bad oap magic: oap %p, &quot;</span>
<a name="l00437"></a>00437                  <span class="stringliteral">&quot;magic 0x%x\n&quot;</span>, oap, oap-&gt;<a class="code" href="structosc__async__page.html#a1ffd70fa26e32a37cdaa1de458fc56a8">oap_magic</a>);
<a name="l00438"></a>00438         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oap-&gt;<a class="code" href="structosc__async__page.html#ac3fda41438a7390f71a21154dbf86fd6">oap_async_flags</a> &amp; <a class="code" href="osc__internal_8h.html#a36cf53ab9257aa954efdd53080c6c74da0f63b531554194e976a0e8d8770e095a">ASYNC_READY</a>);
<a name="l00439"></a>00439         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oap-&gt;<a class="code" href="structosc__async__page.html#ac3fda41438a7390f71a21154dbf86fd6">oap_async_flags</a> &amp; <a class="code" href="osc__internal_8h.html#a36cf53ab9257aa954efdd53080c6c74dad52ed9228404b8af90de9f6d70451d1b">ASYNC_COUNT_STABLE</a>);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         oap-&gt;<a class="code" href="structosc__async__page.html#a76447e742bffe1bd81580d3bf39f4dae">oap_cmd</a>       = crt == <a class="code" href="group__cl__page.html#gga419215a2ca4eeab85983de8ca5a16a02a584acec1467164dff97b38ac9fd5829e">CRT_WRITE</a> ? <a class="code" href="group__lustreidl.html#ga305b994a950a9c0085eaa60eab16ea95">OBD_BRW_WRITE</a> : <a class="code" href="group__lustreidl.html#ga8ce56382e7157587c1fb9480de8e4fad">OBD_BRW_READ</a>;
<a name="l00442"></a>00442         oap-&gt;<a class="code" href="structosc__async__page.html#af981fcaae58646f2063b882e811e105f">oap_page_off</a>  = opg-&gt;<a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6" title="An offset within page from which next transfer starts.">ops_from</a>;
<a name="l00443"></a>00443         oap-&gt;oap_count     = opg-&gt;<a class="code" href="structosc__page.html#a77cefd1ebc7f1f0e4230b98979b71159" title="An offset within page at which next transfer ends.">ops_to</a> - opg-&gt;<a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6" title="An offset within page from which next transfer starts.">ops_from</a>;
<a name="l00444"></a>00444         oap-&gt;oap_brw_flags = <a class="code" href="group__lustreidl.html#gaff5f1d95436a3a173e262c11fe628ac2">OBD_BRW_SYNC</a> | brw_flags;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         <span class="keywordflow">if</span> (!<a class="code" href="group__export.html#gafe3b31bf9f37b2ab4b5291cefe3fdde2">client_is_remote</a>(<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(obj)) &amp;&amp;
<a name="l00447"></a>00447                         <a class="code" href="curproc_8h.html#a906901098598929233d1bee5881720b8">cfs_capable</a>(<a class="code" href="curproc_8h.html#abaea3ce855f9b683f45789a4b2c56125">CFS_CAP_SYS_RESOURCE</a>)) {
<a name="l00448"></a>00448                 oap-&gt;oap_brw_flags |= <a class="code" href="group__lustreidl.html#gac1e0b58baa2b71b695ddd819b4a73430">OBD_BRW_NOQUOTA</a>;
<a name="l00449"></a>00449                 oap-&gt;<a class="code" href="structosc__async__page.html#a76447e742bffe1bd81580d3bf39f4dae">oap_cmd</a> |= <a class="code" href="group__lustreidl.html#gac1e0b58baa2b71b695ddd819b4a73430">OBD_BRW_NOQUOTA</a>;
<a name="l00450"></a>00450         }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         opg-&gt;<a class="code" href="structosc__page.html#ae2717ab94b4940fbd543f76a06d3e289" title="Submit time - the time when the page is starting RPC.">ops_submit_time</a> = <a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>();
<a name="l00453"></a>00453         <a class="code" href="group__osc.html#gaef0e98d65a1cb06f7206f01a0096392b">osc_page_transfer_get</a>(opg, <span class="stringliteral">&quot;transfer\0imm&quot;</span>);
<a name="l00454"></a>00454         <a class="code" href="group__osc.html#ga925522309d1e870b6317c13595114a4b" title="This is called once for every page when it is submitted for a transfer either opportunistic...">osc_page_transfer_add</a>(env, opg, crt);
<a name="l00455"></a>00455 }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="comment">/* --------------- LRU page management ------------------ */</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="comment">/* OSC is a natural place to manage LRU pages as applications are specialized</span>
<a name="l00460"></a>00460 <span class="comment"> * to write OSC by OSC. Ideally, if one OSC is used more frequently it should</span>
<a name="l00461"></a>00461 <span class="comment"> * occupy more LRU slots. On the other hand, we should avoid using up all LRU</span>
<a name="l00462"></a>00462 <span class="comment"> * slots (client_obd::cl_lru_left) otherwise process has to be put into sleep</span>
<a name="l00463"></a>00463 <span class="comment"> * for free LRU slots - this will be very bad so the algorithm requires each</span>
<a name="l00464"></a>00464 <span class="comment"> * OSC to free slots voluntarily to maintain a reasonable number of free slots</span>
<a name="l00465"></a>00465 <span class="comment"> * at any time.</span>
<a name="l00466"></a>00466 <span class="comment"> */</span>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">static</span> <a class="code" href="group__osc.html#ga9c26ac1203cf98f4fd521d29ea813450">DECLARE_WAIT_QUEUE_HEAD</a>(osc_lru_waitq);
<a name="l00469"></a>00469 
<a name="l00474"></a><a class="code" href="group__osc.html#gabd0a23e469f86bf67e66f0f03ef1516b">00474</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gabd0a23e469f86bf67e66f0f03ef1516b" title="LRU pages are freed in batch mode.">lru_shrink_min</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli)
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476         <span class="keywordflow">return</span> cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> * 2;
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00482"></a><a class="code" href="group__osc.html#ga1da4982cfdd0efe755fda53dfb16e77d">00482</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga1da4982cfdd0efe755fda53dfb16e77d" title="free this number at most otherwise it will take too long time to finsih.">lru_shrink_max</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli)
<a name="l00483"></a>00483 {
<a name="l00484"></a>00484         <span class="keywordflow">return</span> cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> * cli-&gt;<a class="code" href="structclient__obd.html#a8e77a281528593754771125a793b0cec">cl_max_rpcs_in_flight</a>;
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00494"></a><a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935">00494</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935" title="Check if we can free LRU slots from this OSC.">osc_cache_too_much</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli)
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496         <span class="keyword">struct </span><a class="code" href="structcl__client__cache.html" title="Data structure managing a client&amp;#39;s cached pages.">cl_client_cache</a> *cache = cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>;
<a name="l00497"></a>00497         <span class="keywordtype">long</span> pages = atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>);
<a name="l00498"></a>00498         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> budget;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(cache != NULL);
<a name="l00501"></a>00501         budget = cache-&gt;<a class="code" href="structcl__client__cache.html#a6533ffde6bee6a5e60c0db19b5966a71" title="Max # of LRU entries.">ccc_lru_max</a> / (atomic_read(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a57c96eb85dc16678ffc511f4d8ace7f2" title="# of client cache refcount # of users (OSCs) + 2 (held by llite and lov)">ccc_users</a>) - 2);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="comment">/* if it&apos;s going to run out LRU slots, we should free some, but not</span>
<a name="l00504"></a>00504 <span class="comment">         * too much to maintain faireness among OSCs. */</span>
<a name="l00505"></a>00505         <span class="keywordflow">if</span> (atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>) &lt; cache-&gt;<a class="code" href="structcl__client__cache.html#a6533ffde6bee6a5e60c0db19b5966a71" title="Max # of LRU entries.">ccc_lru_max</a> &gt;&gt; 2) {
<a name="l00506"></a>00506                 <span class="keywordflow">if</span> (pages &gt;= budget)
<a name="l00507"></a>00507                         <span class="keywordflow">return</span> <a class="code" href="group__osc.html#ga1da4982cfdd0efe755fda53dfb16e77d" title="free this number at most otherwise it will take too long time to finsih.">lru_shrink_max</a>(cli);
<a name="l00508"></a>00508                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pages &gt;= budget / 2)
<a name="l00509"></a>00509                         <span class="keywordflow">return</span> <a class="code" href="group__osc.html#gabd0a23e469f86bf67e66f0f03ef1516b" title="LRU pages are freed in batch mode.">lru_shrink_min</a>(cli);
<a name="l00510"></a>00510         } <span class="keywordflow">else</span> {
<a name="l00511"></a>00511                 <span class="keywordtype">int</span> duration = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() - cli-&gt;<a class="code" href="structclient__obd.html#aacbf98227a4aa8410f6a1af1b849e9ec" title="The time when this LRU cache was last used.">cl_lru_last_used</a>;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513                 <span class="comment">/* knock out pages by duration of no IO activity */</span>
<a name="l00514"></a>00514                 duration &gt;&gt;= 6; <span class="comment">/* approximately 1 minute */</span>
<a name="l00515"></a>00515                 <span class="keywordflow">if</span> (duration &gt; 0 &amp;&amp; pages &gt;= budget / duration)
<a name="l00516"></a>00516                         <span class="keywordflow">return</span> <a class="code" href="group__osc.html#gabd0a23e469f86bf67e66f0f03ef1516b" title="LRU pages are freed in batch mode.">lru_shrink_min</a>(cli);
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         <span class="keywordflow">return</span> 0;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a><a class="code" href="group__osc.html#gab2c0eac927bf007a05676854f0f440fe">00521</a> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gab2c0eac927bf007a05676854f0f440fe">lru_queue_work</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *data)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cli = data;
<a name="l00524"></a>00524         <span class="keywordtype">int</span> count;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: run LRU work for client obd\n&quot;</span>, <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli));
<a name="l00527"></a>00527         count = <a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935" title="Check if we can free LRU slots from this OSC.">osc_cache_too_much</a>(cli);
<a name="l00528"></a>00528         <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l00529"></a>00529                 <span class="keywordtype">int</span> rc = <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(env, cli, count, <span class="keyword">false</span>);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: shrank %d/%d pages from client obd\n&quot;</span>,
<a name="l00532"></a>00532                        <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), rc, count);
<a name="l00533"></a>00533                 <span class="keywordflow">if</span> (rc &gt;= count) {
<a name="l00534"></a>00534                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: queue again\n&quot;</span>, <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli));
<a name="l00535"></a>00535                         <a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l00536"></a>00536                 }
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00542"></a><a class="code" href="group__osc.html#ga0665f963a72ace52377c0d51df2b2319">00542</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga0665f963a72ace52377c0d51df2b2319">osc_lru_add_batch</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *plist)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> lru = <a class="code" href="list_8h.html#a4642d4b7df28478bb762fe43c85b5c63">LIST_HEAD_INIT</a>(lru);
<a name="l00545"></a>00545         <span class="keyword">struct </span><a class="code" href="structosc__async__page.html">osc_async_page</a> *oap;
<a name="l00546"></a>00546         <span class="keywordtype">long</span> npages = 0;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(oap, plist, <a class="code" href="structosc__async__page.html#ade93ff9642d3b45ff804080a94d13d4a">oap_pending_item</a>) {
<a name="l00549"></a>00549                 <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg = <a class="code" href="group__osc.html#ga0d68fe46fc2f5ef1ed6def2b812c2c42">oap2osc_page</a>(oap);
<a name="l00550"></a>00550 
<a name="l00551"></a>00551                 <span class="keywordflow">if</span> (!opg-&gt;<a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a>)
<a name="l00552"></a>00552                         <span class="keywordflow">continue</span>;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554                 ++npages;
<a name="l00555"></a>00555                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>));
<a name="l00556"></a>00556                 <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>, &amp;lru);
<a name="l00557"></a>00557         }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="keywordflow">if</span> (npages &gt; 0) {
<a name="l00560"></a>00560                 spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00561"></a>00561                 <a class="code" href="list_8h.html#ae2d608dbe1110cad29802a302a1efc05">list_splice_tail</a>(&amp;lru, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a769643954836cddbb0d37e997b6cd5c9" title="List of LRU pages for this client_obd.">cl_lru_list</a>);
<a name="l00562"></a>00562                 atomic_long_sub(npages, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>);
<a name="l00563"></a>00563                 atomic_long_add(npages, &amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>);
<a name="l00564"></a>00564                 cli-&gt;<a class="code" href="structclient__obd.html#aacbf98227a4aa8410f6a1af1b849e9ec" title="The time when this LRU cache was last used.">cl_lru_last_used</a> = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>();
<a name="l00565"></a>00565                 spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567                 <span class="keywordflow">if</span> (waitqueue_active(&amp;osc_lru_waitq))
<a name="l00568"></a>00568                         (void)<a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570 }
<a name="l00571"></a>00571 
<a name="l00572"></a><a class="code" href="group__osc.html#gac72424c0edebefddd0674b7edf752181">00572</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gac72424c0edebefddd0674b7edf752181">__osc_lru_del</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00573"></a>00573 {
<a name="l00574"></a>00574         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>) &gt; 0);
<a name="l00575"></a>00575         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>);
<a name="l00576"></a>00576         atomic_long_dec(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>);
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00583"></a><a class="code" href="group__osc.html#ga3bfb464116e04404400ef71fa34298de">00583</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga3bfb464116e04404400ef71fa34298de" title="Page is being destroyed.">osc_lru_del</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585         <span class="keywordflow">if</span> (opg-&gt;<a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a>) {
<a name="l00586"></a>00586                 spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00587"></a>00587                 <span class="keywordflow">if</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>)) {
<a name="l00588"></a>00588                         <a class="code" href="group__osc.html#gac72424c0edebefddd0674b7edf752181">__osc_lru_del</a>(cli, opg);
<a name="l00589"></a>00589                 } <span class="keywordflow">else</span> {
<a name="l00590"></a>00590                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>) &gt; 0);
<a name="l00591"></a>00591                         atomic_long_dec(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>);
<a name="l00592"></a>00592                 }
<a name="l00593"></a>00593                 spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595                 atomic_long_inc(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00596"></a>00596                 <span class="comment">/* this is a great place to release more LRU pages if</span>
<a name="l00597"></a>00597 <span class="comment">                 * this osc occupies too many LRU pages and kernel is</span>
<a name="l00598"></a>00598 <span class="comment">                 * stealing one of them. */</span>
<a name="l00599"></a>00599                 <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935" title="Check if we can free LRU slots from this OSC.">osc_cache_too_much</a>(cli)) {
<a name="l00600"></a>00600                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: queue LRU work\n&quot;</span>, <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli));
<a name="l00601"></a>00601                         (void)<a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l00602"></a>00602                 }
<a name="l00603"></a>00603                 wake_up(&amp;osc_lru_waitq);
<a name="l00604"></a>00604         } <span class="keywordflow">else</span> {
<a name="l00605"></a>00605                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>));
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00612"></a><a class="code" href="group__osc.html#gaf9beb39b2726984894d0264480dba48f">00612</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaf9beb39b2726984894d0264480dba48f" title="Delete page from LRUlist for redirty.">osc_lru_use</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00613"></a>00613 {
<a name="l00614"></a>00614         <span class="comment">/* If page is being transferred for the first time,</span>
<a name="l00615"></a>00615 <span class="comment">         * ops_lru should be empty */</span>
<a name="l00616"></a>00616         <span class="keywordflow">if</span> (opg-&gt;<a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a> &amp;&amp; !<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>)) {
<a name="l00617"></a>00617                 spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00618"></a>00618                 <a class="code" href="group__osc.html#gac72424c0edebefddd0674b7edf752181">__osc_lru_del</a>(cli, opg);
<a name="l00619"></a>00619                 spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00620"></a>00620                 atomic_long_inc(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>);
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a><a class="code" href="group__osc.html#gacdf15af72e5aa25503754ea2a064eead">00624</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gacdf15af72e5aa25503754ea2a064eead">discard_pagevec</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00625"></a>00625                                 <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> **pvec, <span class="keywordtype">int</span> max_index)
<a name="l00626"></a>00626 {
<a name="l00627"></a>00627         <span class="keywordtype">int</span> i;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629         <span class="keywordflow">for</span> (i = 0; i &lt; max_index; i++) {
<a name="l00630"></a>00630                 <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page = pvec[i];
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(page, io));
<a name="l00633"></a>00633                 <a class="code" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432" title="Called when a decision is made to throw page out of memory.">cl_page_delete</a>(env, page);
<a name="l00634"></a>00634                 <a class="code" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03" title="Called when page is to be removed from the object, e.g., as a result of truncate...">cl_page_discard</a>(env, io, page);
<a name="l00635"></a>00635                 <a class="code" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb" title="Releases page ownership.">cl_page_disown</a>(env, io, page);
<a name="l00636"></a>00636                 <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, page);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638                 pvec[i] = NULL;
<a name="l00639"></a>00639         }
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00649"></a><a class="code" href="group__osc.html#ga6615eaa8ae63cc2317c51617f0dc7740">00649</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__osc.html#ga6615eaa8ae63cc2317c51617f0dc7740" title="Check if a cl_page can be released, i.e, it&amp;#39;s not being used.">lru_page_busy</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651         <span class="keywordflow">if</span> (<a class="code" href="group__cl__page.html#gad3d3c2d56b9ba8a228c82c097258b596" title="Caller doesn&amp;#39;t hold a refcount.">cl_page_in_use_noref</a>(page))
<a name="l00652"></a>00652                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#af3635fd3633a4dbcbb2a37b5de0a2a3f" title="Set if unstable check is enabled.">ccc_unstable_check</a>) {
<a name="l00655"></a>00655                 <span class="keyword">struct </span>page *vmpage = <a class="code" href="group__cl__page.html#ga643f9383053507790b9c5a43cdfdb5bf">cl_page_vmpage</a>(page);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657                 <span class="comment">/* vmpage have two known users: cl_page and VM page cache */</span>
<a name="l00658"></a>00658                 <span class="keywordflow">if</span> (page_count(vmpage) - page_mapcount(vmpage) &gt; 2)
<a name="l00659"></a>00659                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00667"></a><a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a">00667</a> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli,
<a name="l00668"></a>00668                    <span class="keywordtype">long</span> target, <span class="keywordtype">bool</span> force)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io;
<a name="l00671"></a>00671         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *clobj = NULL;
<a name="l00672"></a>00672         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> **pvec;
<a name="l00673"></a>00673         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg;
<a name="l00674"></a>00674         <span class="keywordtype">long</span> count = 0;
<a name="l00675"></a>00675         <span class="keywordtype">int</span> maxscan = 0;
<a name="l00676"></a>00676         <span class="keywordtype">int</span> index = 0;
<a name="l00677"></a>00677         <span class="keywordtype">int</span> rc = 0;
<a name="l00678"></a>00678         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>) &gt;= 0);
<a name="l00681"></a>00681         <span class="keywordflow">if</span> (atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>) == 0 || target &lt;= 0)
<a name="l00682"></a>00682                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: shrinkers: %d, force: %d\n&quot;</span>,
<a name="l00685"></a>00685                <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), atomic_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>), force);
<a name="l00686"></a>00686         <span class="keywordflow">if</span> (!force) {
<a name="l00687"></a>00687                 <span class="keywordflow">if</span> (atomic_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>) &gt; 0)
<a name="l00688"></a>00688                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EBUSY);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690                 <span class="keywordflow">if</span> (atomic_inc_return(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>) &gt; 1) {
<a name="l00691"></a>00691                         atomic_dec(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>);
<a name="l00692"></a>00692                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EBUSY);
<a name="l00693"></a>00693                 }
<a name="l00694"></a>00694         } <span class="keywordflow">else</span> {
<a name="l00695"></a>00695                 atomic_inc(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>);
<a name="l00696"></a>00696         }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         pvec = (<span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> **)<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#a0440ee80d1b365b5b0038788ffc55db1">oti_pvec</a>;
<a name="l00699"></a>00699         io = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#ae53d5a14892a9fd224f99d4df2ca0aca">oti_io</a>;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00702"></a>00702         <span class="keywordflow">if</span> (force)
<a name="l00703"></a>00703                 cli-&gt;<a class="code" href="structclient__obd.html#ad67142e92d4145f59d7884e14f0facb4" title="stats: how many reclaims have happened for this client_obd.">cl_lru_reclaim</a>++;
<a name="l00704"></a>00704         maxscan = min(target &lt;&lt; 1, atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>));
<a name="l00705"></a>00705         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a769643954836cddbb0d37e997b6cd5c9" title="List of LRU pages for this client_obd.">cl_lru_list</a>)) {
<a name="l00706"></a>00706                 <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l00707"></a>00707                 <span class="keywordtype">bool</span> will_free = <span class="keyword">false</span>;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709                 <span class="keywordflow">if</span> (!force &amp;&amp; atomic_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>) &gt; 1)
<a name="l00710"></a>00710                         <span class="keywordflow">break</span>;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712                 <span class="keywordflow">if</span> (--maxscan &lt; 0)
<a name="l00713"></a>00713                         <span class="keywordflow">break</span>;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715                 opg = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(cli-&gt;<a class="code" href="structclient__obd.html#a769643954836cddbb0d37e997b6cd5c9" title="List of LRU pages for this client_obd.">cl_lru_list</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>,
<a name="l00716"></a>00716                                  ops_lru);
<a name="l00717"></a>00717                 page = opg-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00718"></a>00718                 <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#ga6615eaa8ae63cc2317c51617f0dc7740" title="Check if a cl_page can be released, i.e, it&amp;#39;s not being used.">lru_page_busy</a>(cli, page)) {
<a name="l00719"></a>00719                         <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a769643954836cddbb0d37e997b6cd5c9" title="List of LRU pages for this client_obd.">cl_lru_list</a>);
<a name="l00720"></a>00720                         <span class="keywordflow">continue</span>;
<a name="l00721"></a>00721                 }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(page-&gt;<a class="code" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cp_obj</a> != NULL);
<a name="l00724"></a>00724                 <span class="keywordflow">if</span> (clobj != page-&gt;<a class="code" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cp_obj</a>) {
<a name="l00725"></a>00725                         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *tmp = page-&gt;<a class="code" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cp_obj</a>;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727                         <a class="code" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get</a>(tmp);
<a name="l00728"></a>00728                         spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                         <span class="keywordflow">if</span> (clobj != NULL) {
<a name="l00731"></a>00731                                 <a class="code" href="group__osc.html#gacdf15af72e5aa25503754ea2a064eead">discard_pagevec</a>(env, io, pvec, index);
<a name="l00732"></a>00732                                 index = 0;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734                                 <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l00735"></a>00735                                 <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, clobj);
<a name="l00736"></a>00736                                 clobj = NULL;
<a name="l00737"></a>00737                         }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739                         clobj = tmp;
<a name="l00740"></a>00740                         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = clobj;
<a name="l00741"></a>00741                         io-&gt;<a class="code" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da" title="to not refresh layout - the IO issuer knows that the layout won&amp;#39;t change(page...">ci_ignore_layout</a> = 1;
<a name="l00742"></a>00742                         rc = <a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c" title="Miscellaneous io.">CIT_MISC</a>, clobj);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744                         spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00745"></a>00745 
<a name="l00746"></a>00746                         <span class="keywordflow">if</span> (rc != 0)
<a name="l00747"></a>00747                                 <span class="keywordflow">break</span>;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749                         ++maxscan;
<a name="l00750"></a>00750                         <span class="keywordflow">continue</span>;
<a name="l00751"></a>00751                 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753                 <span class="keywordflow">if</span> (<a class="code" href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7" title="Nonblock version of cl_page_own().">cl_page_own_try</a>(env, io, page) == 0) {
<a name="l00754"></a>00754                         <span class="keywordflow">if</span> (!<a class="code" href="group__osc.html#ga6615eaa8ae63cc2317c51617f0dc7740" title="Check if a cl_page can be released, i.e, it&amp;#39;s not being used.">lru_page_busy</a>(cli, page)) {
<a name="l00755"></a>00755                                 <span class="comment">/* remove it from lru list earlier to avoid</span>
<a name="l00756"></a>00756 <span class="comment">                                 * lock contention */</span>
<a name="l00757"></a>00757                                 <a class="code" href="group__osc.html#gac72424c0edebefddd0674b7edf752181">__osc_lru_del</a>(cli, opg);
<a name="l00758"></a>00758                                 opg-&gt;<a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a> = 0; <span class="comment">/* will be discarded */</span>
<a name="l00759"></a>00759 
<a name="l00760"></a>00760                                 <a class="code" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13" title="Acquires an additional reference to a page.">cl_page_get</a>(page);
<a name="l00761"></a>00761                                 will_free = <span class="keyword">true</span>;
<a name="l00762"></a>00762                         } <span class="keywordflow">else</span> {
<a name="l00763"></a>00763                                 <a class="code" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb" title="Releases page ownership.">cl_page_disown</a>(env, io, page);
<a name="l00764"></a>00764                         }
<a name="l00765"></a>00765                 }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767                 <span class="keywordflow">if</span> (!will_free) {
<a name="l00768"></a>00768                         <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;opg-&gt;<a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a769643954836cddbb0d37e997b6cd5c9" title="List of LRU pages for this client_obd.">cl_lru_list</a>);
<a name="l00769"></a>00769                         <span class="keywordflow">continue</span>;
<a name="l00770"></a>00770                 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772                 <span class="comment">/* Don&apos;t discard and free the page with cl_lru_list held */</span>
<a name="l00773"></a>00773                 pvec[index++] = page;
<a name="l00774"></a>00774                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(index == <a class="code" href="group__osc.html#ga1060effa512bff483d71c38a0db5dda2">OTI_PVEC_SIZE</a>)) {
<a name="l00775"></a>00775                         spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00776"></a>00776                         <a class="code" href="group__osc.html#gacdf15af72e5aa25503754ea2a064eead">discard_pagevec</a>(env, io, pvec, index);
<a name="l00777"></a>00777                         index = 0;
<a name="l00778"></a>00778 
<a name="l00779"></a>00779                         spin_lock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                 <span class="keywordflow">if</span> (++count &gt;= target)
<a name="l00783"></a>00783                         <span class="keywordflow">break</span>;
<a name="l00784"></a>00784         }
<a name="l00785"></a>00785         spin_unlock(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0aa997fa07d6049932d1955fc938e9db" title="Lock for LRU page list.">cl_lru_list_lock</a>);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (clobj != NULL) {
<a name="l00788"></a>00788                 <a class="code" href="group__osc.html#gacdf15af72e5aa25503754ea2a064eead">discard_pagevec</a>(env, io, pvec, index);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790                 <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l00791"></a>00791                 <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, clobj);
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         atomic_dec(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>);
<a name="l00795"></a>00795         <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l00796"></a>00796                 atomic_long_add(count, cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00797"></a>00797                 wake_up_all(&amp;osc_lru_waitq);
<a name="l00798"></a>00798         }
<a name="l00799"></a>00799         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(count &gt; 0 ? count : rc);
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 
<a name="l00808"></a><a class="code" href="group__osc.html#ga31f63c117fc0131096df1cb21b556956">00808</a> <span class="keyword">static</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#ga31f63c117fc0131096df1cb21b556956" title="Reclaim LRU pages by an IO thread.">osc_lru_reclaim</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> npages)
<a name="l00809"></a>00809 {
<a name="l00810"></a>00810         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l00811"></a>00811         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l00812"></a>00812         <span class="keyword">struct </span><a class="code" href="structcl__client__cache.html" title="Data structure managing a client&amp;#39;s cached pages.">cl_client_cache</a> *cache = cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>;
<a name="l00813"></a>00813         <span class="keywordtype">int</span> max_scans;
<a name="l00814"></a>00814         <span class="keywordtype">long</span> rc = 0;
<a name="l00815"></a>00815         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(cache != NULL);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00820"></a>00820         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l00821"></a>00821                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00822"></a>00822 
<a name="l00823"></a>00823         npages = max_t(<span class="keywordtype">int</span>, npages, cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a>);
<a name="l00824"></a>00824         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: start to reclaim %ld pages from LRU\n&quot;</span>,
<a name="l00825"></a>00825                <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), npages);
<a name="l00826"></a>00826         rc = <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(env, cli, npages, <span class="keyword">true</span>);
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (rc &gt;= npages) {
<a name="l00828"></a>00828                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: reclaimed %ld/%ld pages from LRU\n&quot;</span>,
<a name="l00829"></a>00829                        <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), rc, npages);
<a name="l00830"></a>00830                 <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935" title="Check if we can free LRU slots from this OSC.">osc_cache_too_much</a>(cli) &gt; 0)
<a name="l00831"></a>00831                         <a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l00832"></a>00832                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00833"></a>00833         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l00834"></a>00834                 npages -= rc;
<a name="l00835"></a>00835         }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: cli %p no free slots, pages: %ld/%ld, want: %ld\n&quot;</span>,
<a name="l00838"></a>00838                 <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), cli, atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>),
<a name="l00839"></a>00839                 atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>), npages);
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         <span class="comment">/* Reclaim LRU slots from other client_obd as it can&apos;t free enough</span>
<a name="l00842"></a>00842 <span class="comment">         * from its own. This should rarely happen. */</span>
<a name="l00843"></a>00843         spin_lock(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a593bc6dca5cf6310fd71b840156d2099" title="Lock to protect ccc_lru list.">ccc_lru_lock</a>);
<a name="l00844"></a>00844         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#af8be7dabe3327ff90cb54e4d97ca0742" title="List of entities(OSCs) for this LRU cache.">ccc_lru</a>));
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         cache-&gt;<a class="code" href="structcl__client__cache.html#afed9a92205cc1f05850efa47db8df4ba" title="# of threads are doing shrinking">ccc_lru_shrinkers</a>++;
<a name="l00847"></a>00847         <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a6dbc88017907bde436c4a1a33ceb4060" title="member of cl_cache-&amp;gt;ccc_lru">cl_lru_osc</a>, &amp;cache-&gt;<a class="code" href="structcl__client__cache.html#af8be7dabe3327ff90cb54e4d97ca0742" title="List of entities(OSCs) for this LRU cache.">ccc_lru</a>);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         max_scans = atomic_read(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a57c96eb85dc16678ffc511f4d8ace7f2" title="# of client cache refcount # of users (OSCs) + 2 (held by llite and lov)">ccc_users</a>) - 2;
<a name="l00850"></a>00850         <span class="keywordflow">while</span> (--max_scans &gt; 0 &amp;&amp; !<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#af8be7dabe3327ff90cb54e4d97ca0742" title="List of entities(OSCs) for this LRU cache.">ccc_lru</a>)) {
<a name="l00851"></a>00851                 cli = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(cache-&gt;<a class="code" href="structcl__client__cache.html#af8be7dabe3327ff90cb54e4d97ca0742" title="List of entities(OSCs) for this LRU cache.">ccc_lru</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a>,
<a name="l00852"></a>00852                                  cl_lru_osc);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: cli %p LRU pages: %ld, busy: %ld.\n&quot;</span>,
<a name="l00855"></a>00855                         <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), cli,
<a name="l00856"></a>00856                         atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>),
<a name="l00857"></a>00857                         atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>));
<a name="l00858"></a>00858 
<a name="l00859"></a>00859                 <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a6dbc88017907bde436c4a1a33ceb4060" title="member of cl_cache-&amp;gt;ccc_lru">cl_lru_osc</a>, &amp;cache-&gt;<a class="code" href="structcl__client__cache.html#af8be7dabe3327ff90cb54e4d97ca0742" title="List of entities(OSCs) for this LRU cache.">ccc_lru</a>);
<a name="l00860"></a>00860                 <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#ga6d9a58c123f014c6f0cecc7a0d956935" title="Check if we can free LRU slots from this OSC.">osc_cache_too_much</a>(cli) &gt; 0) {
<a name="l00861"></a>00861                         spin_unlock(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a593bc6dca5cf6310fd71b840156d2099" title="Lock to protect ccc_lru list.">ccc_lru_lock</a>);
<a name="l00862"></a>00862 
<a name="l00863"></a>00863                         rc = <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(env, cli, npages, <span class="keyword">true</span>);
<a name="l00864"></a>00864                         spin_lock(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a593bc6dca5cf6310fd71b840156d2099" title="Lock to protect ccc_lru list.">ccc_lru_lock</a>);
<a name="l00865"></a>00865                         <span class="keywordflow">if</span> (rc &gt;= npages)
<a name="l00866"></a>00866                                 <span class="keywordflow">break</span>;
<a name="l00867"></a>00867                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00868"></a>00868                                 npages -= rc;
<a name="l00869"></a>00869                 }
<a name="l00870"></a>00870         }
<a name="l00871"></a>00871         spin_unlock(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a593bc6dca5cf6310fd71b840156d2099" title="Lock to protect ccc_lru list.">ccc_lru_lock</a>);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 out:
<a name="l00874"></a>00874         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00875"></a>00875         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: cli %p freed %ld pages.\n&quot;</span>,
<a name="l00876"></a>00876                 <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), cli, rc);
<a name="l00877"></a>00877         <span class="keywordflow">return</span> rc;
<a name="l00878"></a>00878 }
<a name="l00879"></a>00879 
<a name="l00887"></a><a class="code" href="group__osc.html#gad3d816668d6cfc8e6ff86c4bae42db4e">00887</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gad3d816668d6cfc8e6ff86c4bae42db4e" title="osc_lru_alloc() is called to allocate an LRU slot for a cl_page.">osc_lru_alloc</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli,
<a name="l00888"></a>00888                          <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00889"></a>00889 {
<a name="l00890"></a>00890         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = <a class="code" href="group__lib.html#gab125226712d6a6cb7eaf8833b5c8565e">LWI_INTR</a>(<a class="code" href="group__lib.html#ga69a4bdb69d1ddb62665b4b936e4b37ea">LWI_ON_SIGNAL_NOOP</a>, NULL);
<a name="l00891"></a>00891         <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *oio = <a class="code" href="group__osc.html#ga80a9df989eeced2c8854e2e74214ce40">osc_env_io</a>(env);
<a name="l00892"></a>00892         <span class="keywordtype">int</span> rc = 0;
<a name="l00893"></a>00893         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a> == NULL) <span class="comment">/* shall not be in LRU */</span>
<a name="l00896"></a>00896                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (oio-&gt;<a class="code" href="structosc__io.html#ac05667bcd9ece4df269f92cb403a95b1" title="how many LRU pages are reserved for this IO">oi_lru_reserved</a> &gt; 0) {
<a name="l00899"></a>00899                 --oio-&gt;<a class="code" href="structosc__io.html#ac05667bcd9ece4df269f92cb403a95b1" title="how many LRU pages are reserved for this IO">oi_lru_reserved</a>;
<a name="l00900"></a>00900                 <span class="keywordflow">goto</span> out;
<a name="l00901"></a>00901         }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>) &gt;= 0);
<a name="l00904"></a>00904         <span class="keywordflow">while</span> (!atomic_long_add_unless(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>, -1, 0)) {
<a name="l00905"></a>00905                 <span class="comment">/* run out of LRU spaces, try to drop some by itself */</span>
<a name="l00906"></a>00906                 rc = <a class="code" href="group__osc.html#ga31f63c117fc0131096df1cb21b556956" title="Reclaim LRU pages by an IO thread.">osc_lru_reclaim</a>(cli, 1);
<a name="l00907"></a>00907                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00908"></a>00908                         <span class="keywordflow">break</span>;
<a name="l00909"></a>00909                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00910"></a>00910                         <span class="keywordflow">continue</span>;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912                 cond_resched();
<a name="l00913"></a>00913                 rc = <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(osc_lru_waitq,
<a name="l00914"></a>00914                                 atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>) &gt; 0,
<a name="l00915"></a>00915                                 &amp;lwi);
<a name="l00916"></a>00916                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00917"></a>00917                         <span class="keywordflow">break</span>;
<a name="l00918"></a>00918         }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 out:
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l00922"></a>00922                 atomic_long_inc(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>);
<a name="l00923"></a>00923                 opg-&gt;<a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a> = 1;
<a name="l00924"></a>00924                 rc = 0;
<a name="l00925"></a>00925         }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00928"></a>00928 }
<a name="l00929"></a>00929 
<a name="l00936"></a><a class="code" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade">00936</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade" title="osc_lru_reserve() is called to reserve enough LRU slots for I/O.">osc_lru_reserve</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> npages)
<a name="l00937"></a>00937 {
<a name="l00938"></a>00938         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reserved = 0;
<a name="l00939"></a>00939         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> max_pages;
<a name="l00940"></a>00940         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> c;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942         <span class="comment">/* reserve a full RPC window at most to avoid that a thread accidentally</span>
<a name="l00943"></a>00943 <span class="comment">         * consumes too many LRU slots */</span>
<a name="l00944"></a>00944         max_pages = cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> * cli-&gt;<a class="code" href="structclient__obd.html#a8e77a281528593754771125a793b0cec">cl_max_rpcs_in_flight</a>;
<a name="l00945"></a>00945         <span class="keywordflow">if</span> (npages &gt; max_pages)
<a name="l00946"></a>00946                 npages = max_pages;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (c &lt; npages &amp;&amp; <a class="code" href="group__osc.html#ga31f63c117fc0131096df1cb21b556956" title="Reclaim LRU pages by an IO thread.">osc_lru_reclaim</a>(cli, npages) &gt; 0)
<a name="l00950"></a>00950                 c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00951"></a>00951         <span class="keywordflow">while</span> (c &gt;= npages) {
<a name="l00952"></a>00952                 <span class="keywordflow">if</span> (c == atomic_long_cmpxchg(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>, c, c - npages)) {
<a name="l00953"></a>00953                         reserved = npages;
<a name="l00954"></a>00954                         <span class="keywordflow">break</span>;
<a name="l00955"></a>00955                 }
<a name="l00956"></a>00956                 c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958         <span class="keywordflow">if</span> (atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>) &lt; max_pages) {
<a name="l00959"></a>00959                 <span class="comment">/* If there aren&apos;t enough pages in the per-OSC LRU then</span>
<a name="l00960"></a>00960 <span class="comment">                 * wake up the LRU thread to try and clear out space, so</span>
<a name="l00961"></a>00961 <span class="comment">                 * we don&apos;t block if pages are being dirtied quickly. */</span>
<a name="l00962"></a>00962                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;%s: queue LRU, left: %lu/%ld.\n&quot;</span>,
<a name="l00963"></a>00963                        <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>),
<a name="l00964"></a>00964                        max_pages);
<a name="l00965"></a>00965                 (void)<a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="keywordflow">return</span> reserved;
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00978"></a><a class="code" href="group__osc.html#gaacf75a0c2b6ddc3e431b00b684de8eed">00978</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaacf75a0c2b6ddc3e431b00b684de8eed" title="osc_lru_unreserve() is called to unreserve LRU slots.">osc_lru_unreserve</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> npages)
<a name="l00979"></a>00979 {
<a name="l00980"></a>00980         atomic_long_add(npages, cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00981"></a>00981         wake_up_all(&amp;osc_lru_waitq);
<a name="l00982"></a>00982 }
<a name="l00983"></a>00983 
<a name="l00990"></a><a class="code" href="group__osc.html#gac60d62f7347eaa5a22e9de266175e6f0">00990</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gac60d62f7347eaa5a22e9de266175e6f0" title="Atomic operations are expensive.">unstable_page_accounting</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l00991"></a>00991                                             <span class="keywordtype">int</span> factor)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         <span class="keywordtype">int</span> page_count = desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a308c723709ab8e47ed0f6cada04856c3">bd_iov_count</a>;
<a name="l00994"></a>00994         <span class="keywordtype">void</span> *zone = NULL;
<a name="l00995"></a>00995         <span class="keywordtype">int</span> count = 0;
<a name="l00996"></a>00996         <span class="keywordtype">int</span> i;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__net.html#gac67f44a3e69d1a64ba820b67100f2163">ptlrpc_is_bulk_desc_kiov</a>(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>));
<a name="l00999"></a>00999 
<a name="l01000"></a>01000         <span class="keywordflow">for</span> (i = 0; i &lt; page_count; i++) {
<a name="l01001"></a>01001                 <span class="keywordtype">void</span> *pz = page_zone(<a class="code" href="group__net.html#gab52fff79731198f0294f477ef3ccddcc">BD_GET_KIOV</a>(desc, i).kiov_page);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(pz == zone)) {
<a name="l01004"></a>01004                         ++count;
<a name="l01005"></a>01005                         <span class="keywordflow">continue</span>;
<a name="l01006"></a>01006                 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008                 <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l01009"></a>01009                         mod_zone_page_state(zone, NR_UNSTABLE_NFS,
<a name="l01010"></a>01010                                             factor * count);
<a name="l01011"></a>01011                         count = 0;
<a name="l01012"></a>01012                 }
<a name="l01013"></a>01013                 zone = pz;
<a name="l01014"></a>01014                 ++count;
<a name="l01015"></a>01015         }
<a name="l01016"></a>01016         <span class="keywordflow">if</span> (count &gt; 0)
<a name="l01017"></a>01017                 mod_zone_page_state(zone, NR_UNSTABLE_NFS, factor * count);
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 
<a name="l01020"></a><a class="code" href="group__osc.html#ga1ab701c739935fb717b4c582ef194439">01020</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga1ab701c739935fb717b4c582ef194439">add_unstable_page_accounting</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l01021"></a>01021 {
<a name="l01022"></a>01022         <a class="code" href="group__osc.html#gac60d62f7347eaa5a22e9de266175e6f0" title="Atomic operations are expensive.">unstable_page_accounting</a>(desc, 1);
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 
<a name="l01025"></a><a class="code" href="group__osc.html#gaa52b271c3f6649fd384dfc59792115d7">01025</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaa52b271c3f6649fd384dfc59792115d7">dec_unstable_page_accounting</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027         <a class="code" href="group__osc.html#gac60d62f7347eaa5a22e9de266175e6f0" title="Atomic operations are expensive.">unstable_page_accounting</a>(desc, -1);
<a name="l01028"></a>01028 }
<a name="l01029"></a>01029 
<a name="l01041"></a><a class="code" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a">01041</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a" title="Performs &amp;quot;unstable&amp;quot; page accounting.">osc_dec_unstable_pages</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01042"></a>01042 {
<a name="l01043"></a>01043         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc       = req-&gt;rq_bulk;
<a name="l01044"></a>01044         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a>       *cli        = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#aebe227afed9945c803b5bda6794bb729">u</a>.<a class="code" href="structobd__device.html#aab14b15f2359afc1da23bbc47decdd0c">cli</a>;
<a name="l01045"></a>01045         <span class="keywordtype">int</span>                      page_count = desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a308c723709ab8e47ed0f6cada04856c3">bd_iov_count</a>;
<a name="l01046"></a>01046         <span class="keywordtype">long</span>                     unstable_count;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(page_count &gt;= 0);
<a name="l01049"></a>01049         <a class="code" href="group__osc.html#gaa52b271c3f6649fd384dfc59792115d7">dec_unstable_page_accounting</a>(desc);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         unstable_count = atomic_long_sub_return(page_count,
<a name="l01052"></a>01052                                                 &amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01053"></a>01053         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(unstable_count &gt;= 0);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         unstable_count = atomic_long_sub_return(page_count,
<a name="l01056"></a>01056                                            &amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01057"></a>01057         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(unstable_count &gt;= 0);
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (unstable_count == 0)
<a name="l01059"></a>01059                 wake_up_all(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2522ffba520c532065c98791724fc521" title="Waitq for awaiting unstable pages to reach zero.">ccc_unstable_waitq</a>);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (waitqueue_active(&amp;osc_lru_waitq))
<a name="l01062"></a>01062                 (void)<a class="code" href="group__net.html#ga796a1313cf9a7e633831e831a6f217da">ptlrpcd_queue_work</a>(cli-&gt;<a class="code" href="structclient__obd.html#a0a9635af1297ecb0d95df838d414a77b">cl_lru_work</a>);
<a name="l01063"></a>01063 }
<a name="l01064"></a>01064 
<a name="l01068"></a><a class="code" href="group__osc.html#gaba135e313f6a93ebb5d5cc3a823116c4">01068</a> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaba135e313f6a93ebb5d5cc3a823116c4" title="&amp;quot;unstable&amp;quot; page accounting.">osc_inc_unstable_pages</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01069"></a>01069 {
<a name="l01070"></a>01070         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc = req-&gt;rq_bulk;
<a name="l01071"></a>01071         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a>       *cli  = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#aebe227afed9945c803b5bda6794bb729">u</a>.<a class="code" href="structobd__device.html#aab14b15f2359afc1da23bbc47decdd0c">cli</a>;
<a name="l01072"></a>01072         <span class="keywordtype">long</span>                     page_count = desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a308c723709ab8e47ed0f6cada04856c3">bd_iov_count</a>;
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <span class="comment">/* No unstable page tracking */</span>
<a name="l01075"></a>01075         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a> == NULL || !cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#af3635fd3633a4dbcbb2a37b5de0a2a3f" title="Set if unstable check is enabled.">ccc_unstable_check</a>)
<a name="l01076"></a>01076                 <span class="keywordflow">return</span>;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <a class="code" href="group__osc.html#ga1ab701c739935fb717b4c582ef194439">add_unstable_page_accounting</a>(desc);
<a name="l01079"></a>01079         atomic_long_add(page_count, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01080"></a>01080         atomic_long_add(page_count, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         <span class="comment">/* If the request has already been committed (i.e. brw_commit</span>
<a name="l01083"></a>01083 <span class="comment">         * called via rq_commit_cb), we need to undo the unstable page</span>
<a name="l01084"></a>01084 <span class="comment">         * increments we just performed because rq_commit_cb wont be</span>
<a name="l01085"></a>01085 <span class="comment">         * called again. */</span>
<a name="l01086"></a>01086         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01087"></a>01087         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ae57f8f40cd963d5cb1ef5a466b370f5d">rq_committed</a>)) {
<a name="l01088"></a>01088                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01089"></a>01089 
<a name="l01090"></a>01090                 <a class="code" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a" title="Performs &amp;quot;unstable&amp;quot; page accounting.">osc_dec_unstable_pages</a>(req);
<a name="l01091"></a>01091         } <span class="keywordflow">else</span> {
<a name="l01092"></a>01092                 req-&gt;<a class="code" href="structptlrpc__request.html#a30ea77777c6df959a21a193590cbcacd">rq_unstable</a> = 1;
<a name="l01093"></a>01093                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01094"></a>01094         }
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01102"></a><a class="code" href="group__osc.html#gaa2bc86b38907996c03e4debb5953688b">01102</a> <span class="keywordtype">bool</span> <a class="code" href="group__osc.html#gaa2bc86b38907996c03e4debb5953688b" title="Check if it piggybacks SOFT_SYNC flag to OST from this OSC.">osc_over_unstable_soft_limit</a>(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli)
<a name="l01103"></a>01103 {
<a name="l01104"></a>01104         <span class="keywordtype">long</span> unstable_nr, osc_unstable_count;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         <span class="comment">/* Can&apos;t check cli-&gt;cl_unstable_count, therefore, no soft limit */</span>
<a name="l01107"></a>01107         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a> == NULL || !cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#af3635fd3633a4dbcbb2a37b5de0a2a3f" title="Set if unstable check is enabled.">ccc_unstable_check</a>)
<a name="l01108"></a>01108                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         osc_unstable_count = atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01111"></a>01111         unstable_nr = atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>,
<a name="l01114"></a>01114                <span class="stringliteral">&quot;%s: cli: %p unstable pages: %lu, osc unstable pages: %lu\n&quot;</span>,
<a name="l01115"></a>01115                <a class="code" href="osc__internal_8h.html#ab7e9270f77b23c30fb3e224636599297">cli_name</a>(cli), cli, unstable_nr, osc_unstable_count);
<a name="l01116"></a>01116 
<a name="l01117"></a>01117         <span class="comment">/* If the LRU slots are in shortage - 25% remaining AND this OSC</span>
<a name="l01118"></a>01118 <span class="comment">         * has one full RPC window of unstable pages, it&apos;s a good chance</span>
<a name="l01119"></a>01119 <span class="comment">         * to piggyback a SOFT_SYNC flag.</span>
<a name="l01120"></a>01120 <span class="comment">         * Please notice that the OST won&apos;t take immediate response for the</span>
<a name="l01121"></a>01121 <span class="comment">         * SOFT_SYNC request so active OSCs will have more chance to carry</span>
<a name="l01122"></a>01122 <span class="comment">         * the flag, this is reasonable. */</span>
<a name="l01123"></a>01123         <span class="keywordflow">return</span> unstable_nr &gt; cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a6533ffde6bee6a5e60c0db19b5966a71" title="Max # of LRU entries.">ccc_lru_max</a> &gt;&gt; 2 &amp;&amp;
<a name="l01124"></a>01124                osc_unstable_count &gt; cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> *
<a name="l01125"></a>01125                                     cli-&gt;<a class="code" href="structclient__obd.html#a8e77a281528593754771125a793b0cec">cl_max_rpcs_in_flight</a>;
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01134"></a><a class="code" href="group__osc.html#gaec0dd919ecdfdb232dca4819b15617c5">01134</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#gaec0dd919ecdfdb232dca4819b15617c5" title="Return how many LRU pages in the cache of all OSC devices.">osc_cache_shrink_count</a>(<span class="keyword">struct</span> shrinker *sk,
<a name="l01135"></a>01135                                      <span class="keyword">struct</span> <a class="code" href="structshrink__control.html">shrink_control</a> *sc)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cli;
<a name="l01138"></a>01138         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cached = 0;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         spin_lock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01141"></a>01141         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(cli, &amp;<a class="code" href="osc__internal_8h.html#a4520307af53ff804c0158fa8a7fa392c" title="osc shrink list to link all osc client obd">osc_shrink_list</a>, <a class="code" href="structclient__obd.html#a14ec05e4781d916049029a0976da1eb9" title="Link to osc_shrinker_list.">cl_shrink_list</a>)
<a name="l01142"></a>01142                 cached += atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>);
<a name="l01143"></a>01143         spin_unlock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         <span class="keywordflow">return</span> (cached  * sysctl_vfs_cache_pressure) / 100;
<a name="l01146"></a>01146 }
<a name="l01147"></a>01147 
<a name="l01161"></a><a class="code" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23">01161</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23" title="Scan and try to reclaim sc-&amp;gt;nr_to_scan cached LRU pages.">osc_cache_shrink_scan</a>(<span class="keyword">struct</span> shrinker *sk,
<a name="l01162"></a>01162                                     <span class="keyword">struct</span> <a class="code" href="structshrink__control.html">shrink_control</a> *sc)
<a name="l01163"></a>01163 {
<a name="l01164"></a>01164         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cli;
<a name="l01165"></a>01165         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *stop_anchor = NULL;
<a name="l01166"></a>01166         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l01167"></a>01167         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01168"></a>01168         <span class="keywordtype">long</span> shrank = 0;
<a name="l01169"></a>01169         <span class="keywordtype">int</span> rc;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         <span class="keywordflow">if</span> (sc-&gt;<a class="code" href="structshrink__control.html#ae07033132733c3bf817cdcfc989069ba">nr_to_scan</a> == 0)
<a name="l01172"></a>01172                 <span class="keywordflow">return</span> 0;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="keywordflow">if</span> (!(sc-&gt;<a class="code" href="structshrink__control.html#aa42683c387e3e46d7541afefccc6114a">gfp_mask</a> &amp; __GFP_FS))
<a name="l01175"></a>01175                 <span class="keywordflow">return</span> <a class="code" href="linux-mem_8h.html#a467b4d3819a240006b8238ca28511d7f">SHRINK_STOP</a>;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01179"></a>01179                 <span class="keywordflow">return</span> <a class="code" href="linux-mem_8h.html#a467b4d3819a240006b8238ca28511d7f">SHRINK_STOP</a>;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181         spin_lock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01182"></a>01182         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;<a class="code" href="osc__internal_8h.html#a4520307af53ff804c0158fa8a7fa392c" title="osc shrink list to link all osc client obd">osc_shrink_list</a>)) {
<a name="l01183"></a>01183                 cli = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(<a class="code" href="osc__internal_8h.html#a4520307af53ff804c0158fa8a7fa392c" title="osc shrink list to link all osc client obd">osc_shrink_list</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a>,
<a name="l01184"></a>01184                                  cl_shrink_list);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 <span class="keywordflow">if</span> (stop_anchor == NULL)
<a name="l01187"></a>01187                         stop_anchor = cli;
<a name="l01188"></a>01188                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cli == stop_anchor)
<a name="l01189"></a>01189                         <span class="keywordflow">break</span>;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191                 <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a14ec05e4781d916049029a0976da1eb9" title="Link to osc_shrinker_list.">cl_shrink_list</a>, &amp;<a class="code" href="osc__internal_8h.html#a4520307af53ff804c0158fa8a7fa392c" title="osc shrink list to link all osc client obd">osc_shrink_list</a>);
<a name="l01192"></a>01192                 spin_unlock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194                 <span class="comment">/* shrink no more than max_pages_per_rpc for an OSC */</span>
<a name="l01195"></a>01195                 rc = <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(env, cli, (sc-&gt;<a class="code" href="structshrink__control.html#ae07033132733c3bf817cdcfc989069ba">nr_to_scan</a> - shrank) &gt;
<a name="l01196"></a>01196                                     cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> ?
<a name="l01197"></a>01197                                     cli-&gt;<a class="code" href="structclient__obd.html#abff4a86d64e35b98676a458209cb9258">cl_max_pages_per_rpc</a> :
<a name="l01198"></a>01198                                     sc-&gt;<a class="code" href="structshrink__control.html#ae07033132733c3bf817cdcfc989069ba">nr_to_scan</a> - shrank, <span class="keyword">true</span>);
<a name="l01199"></a>01199                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l01200"></a>01200                         shrank += rc;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202                 <span class="keywordflow">if</span> (shrank &gt;= sc-&gt;<a class="code" href="structshrink__control.html#ae07033132733c3bf817cdcfc989069ba">nr_to_scan</a>)
<a name="l01203"></a>01203                         <span class="keywordflow">goto</span> out;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205                 spin_lock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207         spin_unlock(&amp;<a class="code" href="osc__internal_8h.html#a6b7e64f1fbdfc9ae9ec34c5d6d2a5a8a" title="spin lock to protect osc_shrink_list">osc_shrink_lock</a>);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 out:
<a name="l01210"></a>01210         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="keywordflow">return</span> shrank;
<a name="l01213"></a>01213 }
<a name="l01214"></a>01214 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:40 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
