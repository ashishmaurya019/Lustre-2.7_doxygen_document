<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/ptlrpcd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/ptlrpcd.c</h1><a href="ptlrpcd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/ptlrpc/ptlrpcd.c</span>
<a name="l00037"></a>00037 <span class="comment"> */</span>
<a name="l00038"></a>00038 
<a name="l00056"></a><a class="code" href="group__ptlrpcd.html#gabda60744d497fcfe370cfd6b2d65c7ed">00056</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_RPC</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;linux/kthread.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;<a class="code" href="libcfs_8h.html">libcfs/libcfs.h</a>&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;<a class="code" href="lustre__net_8h.html">lustre_net.h</a>&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;<a class="code" href="lustre__lib_8h.html">lustre_lib.h</a>&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;<a class="code" href="lustre__ha_8h.html">lustre_ha.h</a>&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;<a class="code" href="obd__class_8h.html">obd_class.h</a>&gt;</span>   <span class="comment">/* for obd_zombie */</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;<a class="code" href="obd__support_8h.html">obd_support.h</a>&gt;</span> <span class="comment">/* for OBD_FAIL_CHECK */</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;<a class="code" href="cl__object_8h.html">cl_object.h</a>&gt;</span> <span class="comment">/* cl_env_{get,put}() */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;<a class="code" href="lprocfs__status_8h.html">lprocfs_status.h</a>&gt;</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;<a class="code" href="ptlrpc__internal_8h.html">ptlrpc_internal.h</a>&quot;</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="comment">/* One of these per CPT. */</span>
<a name="l00071"></a><a class="code" href="structptlrpcd.html">00071</a> <span class="keyword">struct </span><a class="code" href="structptlrpcd.html">ptlrpcd</a> {
<a name="l00072"></a><a class="code" href="structptlrpcd.html#afb62def8a43d07db7d23ed0bee27d65c">00072</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#afb62def8a43d07db7d23ed0bee27d65c">pd_size</a>;
<a name="l00073"></a><a class="code" href="structptlrpcd.html#a850faefbcfa515eff5274459c9ca76ff">00073</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#a850faefbcfa515eff5274459c9ca76ff">pd_index</a>;
<a name="l00074"></a><a class="code" href="structptlrpcd.html#a6fd484fb1c4348b321127426b94f0c05">00074</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#a6fd484fb1c4348b321127426b94f0c05">pd_cpt</a>;
<a name="l00075"></a><a class="code" href="structptlrpcd.html#ab973c62099c279e7cde4f49a41a9ee3c">00075</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#ab973c62099c279e7cde4f49a41a9ee3c">pd_cursor</a>;
<a name="l00076"></a><a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">00076</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">pd_nthreads</a>;
<a name="l00077"></a><a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">00077</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">pd_groupsize</a>;
<a name="l00078"></a><a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">00078</a>         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a>      <a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[0];
<a name="l00079"></a>00079 };
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/*</span>
<a name="l00082"></a>00082 <span class="comment"> * max_ptlrpcds is obsolete, but retained to ensure that the kernel</span>
<a name="l00083"></a>00083 <span class="comment"> * module will load on a system where it has been tuned.</span>
<a name="l00084"></a>00084 <span class="comment"> * A value other than 0 implies it was tuned, in which case the value</span>
<a name="l00085"></a>00085 <span class="comment"> * is used to derive a setting for ptlrpcd_per_cpt_max.</span>
<a name="l00086"></a>00086 <span class="comment"> */</span>
<a name="l00087"></a><a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">00087</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a>;
<a name="l00088"></a>00088 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00089"></a>00089 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a>, <span class="stringliteral">&quot;Max ptlrpcd thread count to be started.&quot;</span>);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">/*</span>
<a name="l00092"></a>00092 <span class="comment"> * ptlrpcd_bind_policy is obsolete, but retained to ensure that</span>
<a name="l00093"></a>00093 <span class="comment"> * the kernel module will load on a system where it has been tuned.</span>
<a name="l00094"></a>00094 <span class="comment"> * A value other than 0 implies it was tuned, in which case the value</span>
<a name="l00095"></a>00095 <span class="comment"> * is used to derive a setting for ptlrpcd_partner_group_size.</span>
<a name="l00096"></a>00096 <span class="comment"> */</span>
<a name="l00097"></a><a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">00097</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">ptlrpcd_bind_policy</a>;
<a name="l00098"></a>00098 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">ptlrpcd_bind_policy</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00099"></a>00099 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">ptlrpcd_bind_policy</a>,
<a name="l00100"></a>00100                  <span class="stringliteral">&quot;Ptlrpcd threads binding mode (obsolete).&quot;</span>);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/*</span>
<a name="l00103"></a>00103 <span class="comment"> * ptlrpcd_per_cpt_max: The maximum number of ptlrpcd threads to run</span>
<a name="l00104"></a>00104 <span class="comment"> * in a CPT.</span>
<a name="l00105"></a>00105 <span class="comment"> */</span>
<a name="l00106"></a><a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">00106</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>;
<a name="l00107"></a>00107 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>,
<a name="l00108"></a>00108                  <span class="stringliteral">&quot;Max ptlrpcd thread count to be started per cpt.&quot;</span>);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">/*</span>
<a name="l00111"></a>00111 <span class="comment"> * ptlrpcd_partner_group_size: The desired number of threads in each</span>
<a name="l00112"></a>00112 <span class="comment"> * ptlrpcd partner thread group. Default is 2, corresponding to the</span>
<a name="l00113"></a>00113 <span class="comment"> * old PDB_POLICY_PAIR. A negative value makes all ptlrpcd threads in</span>
<a name="l00114"></a>00114 <span class="comment"> * a CPT partners of each other.</span>
<a name="l00115"></a>00115 <span class="comment"> */</span>
<a name="l00116"></a><a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">00116</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>;
<a name="l00117"></a>00117 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00118"></a>00118 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>,
<a name="l00119"></a>00119                  <span class="stringliteral">&quot;Number of ptlrpcd threads in a partner group.&quot;</span>);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">/*</span>
<a name="l00122"></a>00122 <span class="comment"> * ptlrpcd_cpts: A CPT string describing the CPU partitions that</span>
<a name="l00123"></a>00123 <span class="comment"> * ptlrpcd threads should run on. Used to make ptlrpcd threads run on</span>
<a name="l00124"></a>00124 <span class="comment"> * a subset of all CPTs.</span>
<a name="l00125"></a>00125 <span class="comment"> *</span>
<a name="l00126"></a>00126 <span class="comment"> * ptlrpcd_cpts=2</span>
<a name="l00127"></a>00127 <span class="comment"> * ptlrpcd_cpts=[2]</span>
<a name="l00128"></a>00128 <span class="comment"> *   run ptlrpcd threads only on CPT 2.</span>
<a name="l00129"></a>00129 <span class="comment"> *</span>
<a name="l00130"></a>00130 <span class="comment"> * ptlrpcd_cpts=0-3</span>
<a name="l00131"></a>00131 <span class="comment"> * ptlrpcd_cpts=[0-3]</span>
<a name="l00132"></a>00132 <span class="comment"> *   run ptlrpcd threads on CPTs 0, 1, 2, and 3.</span>
<a name="l00133"></a>00133 <span class="comment"> *</span>
<a name="l00134"></a>00134 <span class="comment"> * ptlrpcd_cpts=[0-3,5,7]</span>
<a name="l00135"></a>00135 <span class="comment"> *   run ptlrpcd threads on CPTS 0, 1, 2, 3, 5, and 7.</span>
<a name="l00136"></a>00136 <span class="comment"> */</span>
<a name="l00137"></a><a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">00137</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>;
<a name="l00138"></a>00138 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>, charp, 0644);
<a name="l00139"></a>00139 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>,
<a name="l00140"></a>00140                  <span class="stringliteral">&quot;CPU partitions ptlrpcd threads should run in&quot;</span>);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">/* ptlrpcds_cpt_idx maps cpt numbers to an index in the ptlrpcds array. */</span>
<a name="l00143"></a><a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">00143</a> <span class="keyword">static</span> <span class="keywordtype">int</span>              *<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">/* ptlrpcds_num is the number of entries in the ptlrpcds array. */</span>
<a name="l00146"></a><a class="code" href="group__ptlrpcd.html#ga017ff18bbbf12192cf2b330e12a7bf49">00146</a> <span class="keyword">static</span> <span class="keywordtype">int</span>              <a class="code" href="group__ptlrpcd.html#ga017ff18bbbf12192cf2b330e12a7bf49">ptlrpcds_num</a>;
<a name="l00147"></a><a class="code" href="group__ptlrpcd.html#gacf5cc1f3f7e39c237392469db7f89d2f">00147</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpcd.html">ptlrpcd</a>   **<a class="code" href="group__ptlrpcd.html#gacf5cc1f3f7e39c237392469db7f89d2f">ptlrpcds</a>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">/*</span>
<a name="l00150"></a>00150 <span class="comment"> * In addition to the regular thread pool above, there is a single</span>
<a name="l00151"></a>00151 <span class="comment"> * global recovery thread. Recovery isn&apos;t critical for performance,</span>
<a name="l00152"></a>00152 <span class="comment"> * and doesn&apos;t block, but must always be able to proceed, and it is</span>
<a name="l00153"></a>00153 <span class="comment"> * possible that all normal ptlrpcd threads are blocked. Hence the</span>
<a name="l00154"></a>00154 <span class="comment"> * need for a dedicated thread.</span>
<a name="l00155"></a>00155 <span class="comment"> */</span>
<a name="l00156"></a><a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">00156</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> <a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>;
<a name="l00157"></a>00157 
<a name="l00158"></a><a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">00158</a> <span class="keyword">struct </span>mutex <a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">ptlrpcd_mutex</a>;
<a name="l00159"></a><a class="code" href="group__ptlrpcd.html#gab1e1324450eb18f953c4131b03edcc80">00159</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#gab1e1324450eb18f953c4131b03edcc80">ptlrpcd_users</a> = 0;
<a name="l00160"></a>00160 
<a name="l00161"></a><a class="code" href="group__ptlrpcd.html#ga2acfae9e6349420190608a611125bb78">00161</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga2acfae9e6349420190608a611125bb78">ptlrpcd_wake</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00162"></a>00162 {
<a name="l00163"></a>00163         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = req-&gt;rq_set;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<span class="keyword">set</span> != NULL);
<a name="l00166"></a>00166         wake_up(&amp;set-&gt;set_waitq);
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga2acfae9e6349420190608a611125bb78">ptlrpcd_wake</a>);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *
<a name="l00171"></a><a class="code" href="group__ptlrpcd.html#gabcd085253aea52532fca8a4f6ae05d7c">00171</a> <a class="code" href="group__ptlrpcd.html#gabcd085253aea52532fca8a4f6ae05d7c">ptlrpcd_select_pc</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173         <span class="keyword">struct </span><a class="code" href="structptlrpcd.html">ptlrpcd</a>  *pd;
<a name="l00174"></a>00174         <span class="keywordtype">int</span>             cpt;
<a name="l00175"></a>00175         <span class="keywordtype">int</span>             idx;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="keywordflow">if</span> (req != NULL &amp;&amp; req-&gt;rq_send_state != <a class="code" href="group__export.html#gga342f8de0ae2ad4b6cb54d4072d7a97a0ae37d5c664f0f0359b8307616076bb071">LUSTRE_IMP_FULL</a>)
<a name="l00178"></a>00178                 <span class="keywordflow">return</span> &amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         cpt = <a class="code" href="libcfs__cpu_8h.html#aeca702e29c4c46f6801403fe5cba3c8b" title="shadow current HW processor ID to CPU-partition ID of cptab ">cfs_cpt_current</a>(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, 1);
<a name="l00181"></a>00181         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a> == NULL)
<a name="l00182"></a>00182                 idx = cpt;
<a name="l00183"></a>00183         <span class="keywordflow">else</span>
<a name="l00184"></a>00184                 idx = <a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>[cpt];
<a name="l00185"></a>00185         pd = ptlrpcds[idx];
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="comment">/* We do not care whether it is strict load balance. */</span>
<a name="l00188"></a>00188         idx = pd-&gt;<a class="code" href="structptlrpcd.html#ab973c62099c279e7cde4f49a41a9ee3c">pd_cursor</a>;
<a name="l00189"></a>00189         <span class="keywordflow">if</span> (++idx == pd-&gt;<a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">pd_nthreads</a>)
<a name="l00190"></a>00190                 idx = 0;
<a name="l00191"></a>00191         pd-&gt;<a class="code" href="structptlrpcd.html#ab973c62099c279e7cde4f49a41a9ee3c">pd_cursor</a> = idx;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         <span class="keywordflow">return</span> &amp;pd-&gt;<a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[idx];
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00200"></a><a class="code" href="group__ptlrpcd.html#ga8786798db7200aeedbfe4cd0a855232f">00200</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga8786798db7200aeedbfe4cd0a855232f" title="Move all request from an existing request set to the ptlrpcd queue.">ptlrpcd_add_rqset</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l00203"></a>00203         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc;
<a name="l00204"></a>00204         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">new</span>;
<a name="l00205"></a>00205         <span class="keywordtype">int</span> count, i;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         pc = <a class="code" href="group__ptlrpcd.html#gabcd085253aea52532fca8a4f6ae05d7c">ptlrpcd_select_pc</a>(NULL);
<a name="l00208"></a>00208         <span class="keyword">new</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <a class="code" href="list_8h.html#a9e4b9328744994b9d3878f5dad75c09f" title="Iterate over a list safely.">list_for_each_safe</a>(pos, tmp, &amp;set-&gt;set_requests) {
<a name="l00211"></a>00211                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00212"></a>00212                         <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00213"></a>00213                                    <a class="code" href="group__net.html#gabfd771a992570154c4e73515249dcd07">rq_set_chain</a>);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == <a class="code" href="group__net.html#gga0e456f0c28b52cad4b543eec9efa656aa860f74a93b851affbf69064ad3063614">RQ_PHASE_NEW</a>);
<a name="l00216"></a>00216                 req-&gt;rq_set = <span class="keyword">new</span>;
<a name="l00217"></a>00217                 req-&gt;rq_queued_time = <a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>();
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         spin_lock(&amp;new-&gt;set_new_req_lock);
<a name="l00221"></a>00221         <a class="code" href="list_8h.html#a948b15519bb72e3d42f3e56975580d30" title="Join two lists and reinitialise the emptied list.">list_splice_init</a>(&amp;set-&gt;set_requests, &amp;new-&gt;set_new_requests);
<a name="l00222"></a>00222         i = atomic_read(&amp;set-&gt;set_remaining);
<a name="l00223"></a>00223         count = atomic_add_return(i, &amp;new-&gt;set_new_count);
<a name="l00224"></a>00224         atomic_set(&amp;set-&gt;set_remaining, 0);
<a name="l00225"></a>00225         spin_unlock(&amp;new-&gt;set_new_req_lock);
<a name="l00226"></a>00226         <span class="keywordflow">if</span> (count == i) {
<a name="l00227"></a>00227                 wake_up(&amp;new-&gt;set_waitq);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229                 <span class="comment">/* XXX: It maybe unnecessary to wakeup all the partners. But to</span>
<a name="l00230"></a>00230 <span class="comment">                 *      guarantee the async RPC can be processed ASAP, we have</span>
<a name="l00231"></a>00231 <span class="comment">                 *      no other better choice. It maybe fixed in future. */</span>
<a name="l00232"></a>00232                 <span class="keywordflow">for</span> (i = 0; i &lt; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>; i++)
<a name="l00233"></a>00233                         wake_up(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>[i]-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>);
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00240"></a><a class="code" href="group__ptlrpcd.html#ga1cddf9869def1f66fd29dae1f5d877f6">00240</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga1cddf9869def1f66fd29dae1f5d877f6" title="Return transferred RPCs count.">ptlrpcd_steal_rqset</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *des,
<a name="l00241"></a>00241                                <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *src)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l00244"></a>00244         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00245"></a>00245         <span class="keywordtype">int</span> rc = 0;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         spin_lock(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#ae9098450b33bfdac5eb59f297f3b0c70" title="Lock for set_new_requests manipulations locked so that any old caller can communicate...">set_new_req_lock</a>);
<a name="l00248"></a>00248         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#aede9d95a4944a6b4d28063de1aa3565b" title="List of new yet unsent requests.">set_new_requests</a>))) {
<a name="l00249"></a>00249                 <a class="code" href="list_8h.html#a9e4b9328744994b9d3878f5dad75c09f" title="Iterate over a list safely.">list_for_each_safe</a>(pos, tmp, &amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#aede9d95a4944a6b4d28063de1aa3565b" title="List of new yet unsent requests.">set_new_requests</a>) {
<a name="l00250"></a>00250                         req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00251"></a>00251                                          <a class="code" href="group__net.html#gabfd771a992570154c4e73515249dcd07">rq_set_chain</a>);
<a name="l00252"></a>00252                         req-&gt;rq_set = des;
<a name="l00253"></a>00253                 }
<a name="l00254"></a>00254                 <a class="code" href="list_8h.html#a948b15519bb72e3d42f3e56975580d30" title="Join two lists and reinitialise the emptied list.">list_splice_init</a>(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#aede9d95a4944a6b4d28063de1aa3565b" title="List of new yet unsent requests.">set_new_requests</a>,
<a name="l00255"></a>00255                                  &amp;des-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>);
<a name="l00256"></a>00256                 rc = atomic_read(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#a501b0460a038a221bce0b239f3a4b687" title="number of in queue requests">set_new_count</a>);
<a name="l00257"></a>00257                 atomic_add(rc, &amp;des-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l00258"></a>00258                 atomic_set(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#a501b0460a038a221bce0b239f3a4b687" title="number of in queue requests">set_new_count</a>, 0);
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260         spin_unlock(&amp;src-&gt;<a class="code" href="structptlrpc__request__set.html#ae9098450b33bfdac5eb59f297f3b0c70" title="Lock for set_new_requests manipulations locked so that any old caller can communicate...">set_new_req_lock</a>);
<a name="l00261"></a>00261         <span class="keywordflow">return</span> rc;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00268"></a><a class="code" href="group__ptlrpcd.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1">00268</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>)
<a name="l00273"></a>00273                 <a class="code" href="group__net.html#ga1c7457d1600c44342f8be69cb25a2646">lustre_msg_set_jobid</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, NULL);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00276"></a>00276         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a>) {
<a name="l00277"></a>00277                 <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = <a class="code" href="group__lib.html#ga2c8a9c91f1f21e7ff21abedc365140f9">LWI_TIMEOUT</a>(<a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(5),
<a name="l00278"></a>00278                                                      <a class="code" href="group__lib.html#gab24c6fe5b65e802c446d53e3ad5c35ac">back_to_sleep</a>, NULL);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 0;
<a name="l00281"></a>00281                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00282"></a>00282                 <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(req-&gt;rq_set_waitq, (req-&gt;rq_set == NULL), &amp;lwi);
<a name="l00283"></a>00283         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_set) {
<a name="l00284"></a>00284                 <span class="comment">/* If we have a vaid &quot;rq_set&quot;, just reuse it to avoid double</span>
<a name="l00285"></a>00285 <span class="comment">                 * linked. */</span>
<a name="l00286"></a>00286                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == <a class="code" href="group__net.html#gga0e456f0c28b52cad4b543eec9efa656aa860f74a93b851affbf69064ad3063614">RQ_PHASE_NEW</a>);
<a name="l00287"></a>00287                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(req-&gt;rq_send_state == <a class="code" href="group__export.html#gga342f8de0ae2ad4b6cb54d4072d7a97a0a6cd9ae05e470457512a6d714dc0474eb">LUSTRE_IMP_REPLAY</a>);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289                 <span class="comment">/* ptlrpc_check_set will decrease the count */</span>
<a name="l00290"></a>00290                 atomic_inc(&amp;req-&gt;rq_set-&gt;set_remaining);
<a name="l00291"></a>00291                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00292"></a>00292                 wake_up(&amp;req-&gt;rq_set-&gt;set_waitq);
<a name="l00293"></a>00293                 <span class="keywordflow">return</span>;
<a name="l00294"></a>00294         } <span class="keywordflow">else</span> {
<a name="l00295"></a>00295                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         pc = <a class="code" href="group__ptlrpcd.html#gabcd085253aea52532fca8a4f6ae05d7c">ptlrpcd_select_pc</a>(req);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, req, <span class="stringliteral">&quot;add req [%p] to pc [%s:%d]&quot;</span>,
<a name="l00301"></a>00301                   req, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16" title="Index of ptlrpcd thread in the array.">pc_index</a>);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303         <a class="code" href="client_8c.html#a6978d733f46bb41c9ac9b5195aff2837" title="Add a request to a request with dedicated server thread and wake the thread to make...">ptlrpc_set_add_new_req</a>(pc, req);
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 EXPORT_SYMBOL(<a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>);
<a name="l00306"></a>00306 
<a name="l00307"></a><a class="code" href="group__ptlrpcd.html#gad58ba78046465270e42ffa47d11f4d7e">00307</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__ptlrpcd.html#gad58ba78046465270e42ffa47d11f4d7e">ptlrpc_reqset_get</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309         atomic_inc(&amp;set-&gt;set_refcount);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00316"></a><a class="code" href="group__ptlrpcd.html#ga1a5f6f050d58107722206e6d2e651cbd">00316</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga1a5f6f050d58107722206e6d2e651cbd" title="Check if there is more work to do on ptlrpcd set.">ptlrpcd_check</a>(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l00319"></a>00319         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00320"></a>00320         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00321"></a>00321         <span class="keywordtype">int</span> rc = 0;
<a name="l00322"></a>00322         <span class="keywordtype">int</span> rc2;
<a name="l00323"></a>00323         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <span class="keywordflow">if</span> (atomic_read(&amp;set-&gt;set_new_count)) {
<a name="l00326"></a>00326                 spin_lock(&amp;set-&gt;set_new_req_lock);
<a name="l00327"></a>00327                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;set-&gt;set_new_requests))) {
<a name="l00328"></a>00328                         <a class="code" href="list_8h.html#a948b15519bb72e3d42f3e56975580d30" title="Join two lists and reinitialise the emptied list.">list_splice_init</a>(&amp;set-&gt;set_new_requests,
<a name="l00329"></a>00329                                              &amp;set-&gt;set_requests);
<a name="l00330"></a>00330                         atomic_add(atomic_read(&amp;set-&gt;set_new_count),
<a name="l00331"></a>00331                                    &amp;set-&gt;set_remaining);
<a name="l00332"></a>00332                         atomic_set(&amp;set-&gt;set_new_count, 0);
<a name="l00333"></a>00333                         <span class="comment">/*</span>
<a name="l00334"></a>00334 <span class="comment">                         * Need to calculate its timeout.</span>
<a name="l00335"></a>00335 <span class="comment">                         */</span>
<a name="l00336"></a>00336                         rc = 1;
<a name="l00337"></a>00337                 }
<a name="l00338"></a>00338                 spin_unlock(&amp;set-&gt;set_new_req_lock);
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <span class="comment">/* We should call lu_env_refill() before handling new requests to make</span>
<a name="l00342"></a>00342 <span class="comment">         * sure that env key the requests depending on really exists.</span>
<a name="l00343"></a>00343 <span class="comment">         */</span>
<a name="l00344"></a>00344         rc2 = <a class="code" href="group__lu.html#ga3149440dd27a5c2618f6f940fae4c806">lu_env_refill</a>(env);
<a name="l00345"></a>00345         <span class="keywordflow">if</span> (rc2 != 0) {
<a name="l00346"></a>00346                 <span class="comment">/*</span>
<a name="l00347"></a>00347 <span class="comment">                 * XXX This is very awkward situation, because</span>
<a name="l00348"></a>00348 <span class="comment">                 * execution can neither continue (request</span>
<a name="l00349"></a>00349 <span class="comment">                 * interpreters assume that env is set up), nor repeat</span>
<a name="l00350"></a>00350 <span class="comment">                 * the loop (as this potentially results in a tight</span>
<a name="l00351"></a>00351 <span class="comment">                 * loop of -ENOMEM&apos;s).</span>
<a name="l00352"></a>00352 <span class="comment">                 *</span>
<a name="l00353"></a>00353 <span class="comment">                 * Fortunately, refill only ever does something when</span>
<a name="l00354"></a>00354 <span class="comment">                 * new modules are loaded, i.e., early during boot up.</span>
<a name="l00355"></a>00355 <span class="comment">                 */</span>
<a name="l00356"></a>00356                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Failure to refill session: %d\n&quot;</span>, rc2);
<a name="l00357"></a>00357                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (atomic_read(&amp;set-&gt;set_remaining))
<a name="l00361"></a>00361                 rc |= <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(env, <span class="keyword">set</span>);
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         <span class="comment">/* NB: ptlrpc_check_set has already moved complted request at the</span>
<a name="l00364"></a>00364 <span class="comment">         * head of seq::set_requests */</span>
<a name="l00365"></a>00365         <a class="code" href="list_8h.html#a9e4b9328744994b9d3878f5dad75c09f" title="Iterate over a list safely.">list_for_each_safe</a>(pos, tmp, &amp;set-&gt;set_requests) {
<a name="l00366"></a>00366                 req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, <a class="code" href="group__net.html#gabfd771a992570154c4e73515249dcd07">rq_set_chain</a>);
<a name="l00367"></a>00367                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> != <a class="code" href="group__net.html#gga0e456f0c28b52cad4b543eec9efa656aade4cc4a5d9abae94a06fca77e02ac001">RQ_PHASE_COMPLETE</a>)
<a name="l00368"></a>00368                         <span class="keywordflow">break</span>;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;rq_set_chain);
<a name="l00371"></a>00371                 req-&gt;rq_set = NULL;
<a name="l00372"></a>00372                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00376"></a>00376                 <span class="comment">/*</span>
<a name="l00377"></a>00377 <span class="comment">                 * If new requests have been added, make sure to wake up.</span>
<a name="l00378"></a>00378 <span class="comment">                 */</span>
<a name="l00379"></a>00379                 rc = atomic_read(&amp;set-&gt;set_new_count);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381                 <span class="comment">/* If we have nothing to do, check whether we can take some</span>
<a name="l00382"></a>00382 <span class="comment">                 * work from our partner threads. */</span>
<a name="l00383"></a>00383                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> &gt; 0) {
<a name="l00384"></a>00384                         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *partner;
<a name="l00385"></a>00385                         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *ps;
<a name="l00386"></a>00386                         <span class="keywordtype">int</span> first = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a>;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388                         <span class="keywordflow">do</span> {
<a name="l00389"></a>00389                                 partner = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>[pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a>++];
<a name="l00390"></a>00390                                 <span class="keywordflow">if</span> (pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a> &gt;= pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>)
<a name="l00391"></a>00391                                         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a> = 0;
<a name="l00392"></a>00392                                 <span class="keywordflow">if</span> (partner == NULL)
<a name="l00393"></a>00393                                         <span class="keywordflow">continue</span>;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395                                 spin_lock(&amp;partner-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00396"></a>00396                                 ps = partner-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00397"></a>00397                                 <span class="keywordflow">if</span> (ps == NULL) {
<a name="l00398"></a>00398                                         spin_unlock(&amp;partner-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00399"></a>00399                                         <span class="keywordflow">continue</span>;
<a name="l00400"></a>00400                                 }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402                                 <a class="code" href="group__ptlrpcd.html#gad58ba78046465270e42ffa47d11f4d7e">ptlrpc_reqset_get</a>(ps);
<a name="l00403"></a>00403                                 spin_unlock(&amp;partner-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405                                 <span class="keywordflow">if</span> (atomic_read(&amp;ps-&gt;<a class="code" href="structptlrpc__request__set.html#a501b0460a038a221bce0b239f3a4b687" title="number of in queue requests">set_new_count</a>)) {
<a name="l00406"></a>00406                                         rc = <a class="code" href="group__ptlrpcd.html#ga1cddf9869def1f66fd29dae1f5d877f6" title="Return transferred RPCs count.">ptlrpcd_steal_rqset</a>(<span class="keyword">set</span>, ps);
<a name="l00407"></a>00407                                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00408"></a>00408                                                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;transfer %d&quot;</span>
<a name="l00409"></a>00409                                                        <span class="stringliteral">&quot; async RPCs [%d-&gt;%d]\n&quot;</span>,
<a name="l00410"></a>00410                                                        rc, partner-&gt;<a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16" title="Index of ptlrpcd thread in the array.">pc_index</a>,
<a name="l00411"></a>00411                                                        pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16" title="Index of ptlrpcd thread in the array.">pc_index</a>);
<a name="l00412"></a>00412                                 }
<a name="l00413"></a>00413                                 <a class="code" href="ptlrpc__internal_8h.html#a8125370d60343843a20c56bb811ffd4b">ptlrpc_reqset_put</a>(ps);
<a name="l00414"></a>00414                         } <span class="keywordflow">while</span> (rc == 0 &amp;&amp; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a> != first);
<a name="l00415"></a>00415                 }
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00427"></a><a class="code" href="group__ptlrpcd.html#ga9f9a9070ef2ee141f96e15a2512be310">00427</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga9f9a9070ef2ee141f96e15a2512be310" title="Main ptlrpcd thread.">ptlrpcd</a>(<span class="keywordtype">void</span> *arg)
<a name="l00428"></a>00428 {
<a name="l00429"></a>00429         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a>              *pc = arg;
<a name="l00430"></a>00430         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<span class="keyword">set</span>;
<a name="l00431"></a>00431         <span class="keyword">struct </span><a class="code" href="structlu__context.html" title="lu_context.">lu_context</a>               ses = { 0 };
<a name="l00432"></a>00432         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>                   env = { .<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> = &amp;ses };
<a name="l00433"></a>00433         <span class="keywordtype">int</span>                             rc = 0;
<a name="l00434"></a>00434         <span class="keywordtype">int</span>                             exit = 0;
<a name="l00435"></a>00435         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         unshare_fs_struct();
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         <span class="keywordflow">if</span> (<a class="code" href="libcfs__cpu_8h.html#a5640d52431f8a9f49f0ca6c93c6e4d10" title="bind current thread on a CPU-partition cpt of cptab ">cfs_cpt_bind</a>(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b" title="CPT the thread is bound on.">pc_cpt</a>) != 0)
<a name="l00440"></a>00440                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Failed to bind %s on CPT %d\n&quot;</span>, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b" title="CPT the thread is bound on.">pc_cpt</a>);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">         * Allocate the request set after the thread has been bound</span>
<a name="l00444"></a>00444 <span class="comment">         * above. This is safe because no requests will be queued</span>
<a name="l00445"></a>00445 <span class="comment">         * until all ptlrpcd threads have confirmed that they have</span>
<a name="l00446"></a>00446 <span class="comment">         * successfully started.</span>
<a name="l00447"></a>00447 <span class="comment">         */</span>
<a name="l00448"></a>00448         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (<span class="keyword">set</span> == NULL)
<a name="l00450"></a>00450                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc = -ENOMEM);
<a name="l00451"></a>00451         spin_lock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00452"></a>00452         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a> = <span class="keyword">set</span>;
<a name="l00453"></a>00453         spin_unlock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="comment">/* Both client and server (MDT/OST) may use the environment. */</span>
<a name="l00456"></a>00456         rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(&amp;env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" title="Thread on md server.">LCT_MD_THREAD</a> |
<a name="l00457"></a>00457                                           <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a> |
<a name="l00458"></a>00458                                           <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a> |
<a name="l00459"></a>00459                                           <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>  |
<a name="l00460"></a>00460                                           <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>);
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (rc != 0)
<a name="l00462"></a>00462                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l00463"></a>00463         rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(env.<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" title="A per-request session on a server, and a per-system-call session on a client.">LCT_SESSION</a>  |
<a name="l00464"></a>00464                                          <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a> |
<a name="l00465"></a>00465                                          <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>);
<a name="l00466"></a>00466         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00467"></a>00467                 <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00468"></a>00468                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         complete(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c" title="Start completion.">pc_starting</a>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="comment">/*</span>
<a name="l00474"></a>00474 <span class="comment">         * This mainloop strongly resembles ptlrpc_set_wait() except that our</span>
<a name="l00475"></a>00475 <span class="comment">         * set never completes.  ptlrpcd_check() calls ptlrpc_check_set() when</span>
<a name="l00476"></a>00476 <span class="comment">         * there are requests in the set. New requests come in on the set&apos;s</span>
<a name="l00477"></a>00477 <span class="comment">         * new_req_list and ptlrpcd_check() moves them into the set.</span>
<a name="l00478"></a>00478 <span class="comment">         */</span>
<a name="l00479"></a>00479         <span class="keywordflow">do</span> {
<a name="l00480"></a>00480                 <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi;
<a name="l00481"></a>00481                 <span class="keywordtype">int</span> <a class="code" href="gnilnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483                 timeout = <a class="code" href="client_8c.html#a1a571f24a883004b3deb6c6706e22972" title="Get the smallest timeout in the set; this does NOT set a timeout.">ptlrpc_set_next_timeout</a>(<span class="keyword">set</span>);
<a name="l00484"></a>00484                 lwi = <a class="code" href="group__lib.html#ga2c8a9c91f1f21e7ff21abedc365140f9">LWI_TIMEOUT</a>(<a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(timeout ? timeout : 1),
<a name="l00485"></a>00485                                   <a class="code" href="client_8c.html#ac5d7cfee5628090111ef04b2e7054a3e" title="Time out all uncompleted requests in request set pointed by data Callback used when...">ptlrpc_expired_set</a>, <span class="keyword">set</span>);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487                 <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(&amp;env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00488"></a>00488                 <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(env.<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l00489"></a>00489                 <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(set-&gt;set_waitq, <a class="code" href="group__ptlrpcd.html#ga1a5f6f050d58107722206e6d2e651cbd" title="Check if there is more work to do on ptlrpcd set.">ptlrpcd_check</a>(&amp;env, pc), &amp;lwi);
<a name="l00490"></a>00490                 <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(&amp;env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00491"></a>00491                 <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(env.<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493                 <span class="comment">/*</span>
<a name="l00494"></a>00494 <span class="comment">                 * Abort inflight rpcs for forced stop case.</span>
<a name="l00495"></a>00495 <span class="comment">                 */</span>
<a name="l00496"></a>00496                 <span class="keywordflow">if</span> (test_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>)) {
<a name="l00497"></a>00497                         <span class="keywordflow">if</span> (test_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" title="Ptlrpc thread force flag (only stop force so far).">LIOD_FORCE</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>))
<a name="l00498"></a>00498                                 <a class="code" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77" title="Abort all uncompleted requests in request set set.">ptlrpc_abort_set</a>(<span class="keyword">set</span>);
<a name="l00499"></a>00499                         exit++;
<a name="l00500"></a>00500                 }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502                 <span class="comment">/*</span>
<a name="l00503"></a>00503 <span class="comment">                 * Let&apos;s make one more loop to make sure that ptlrpcd_check()</span>
<a name="l00504"></a>00504 <span class="comment">                 * copied all raced new rpcs into the set so we can kill them.</span>
<a name="l00505"></a>00505 <span class="comment">                 */</span>
<a name="l00506"></a>00506         } <span class="keywordflow">while</span> (exit &lt; 2);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         <span class="comment">/*</span>
<a name="l00509"></a>00509 <span class="comment">         * Wait for inflight requests to drain.</span>
<a name="l00510"></a>00510 <span class="comment">         */</span>
<a name="l00511"></a>00511         <span class="keywordflow">if</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;set-&gt;set_requests))
<a name="l00512"></a>00512                 <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">set</span>);
<a name="l00513"></a>00513         <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00514"></a>00514         <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(env.<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         complete(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2db10d4650ee83958fb147906b6fce82" title="Stop completion.">pc_finishing</a>);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         <span class="keywordflow">return</span> 0;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 failed:
<a name="l00521"></a>00521         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a191cb4d4f68f14efd9c9661ff5caad0c" title="Error code if the thread failed to fully start.">pc_error</a> = rc;
<a name="l00522"></a>00522         complete(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c" title="Start completion.">pc_starting</a>);
<a name="l00523"></a>00523         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00524"></a>00524 }
<a name="l00525"></a>00525 
<a name="l00526"></a><a class="code" href="group__ptlrpcd.html#gac8b793ed162ef61c41412704f68f7f3f">00526</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__ptlrpcd.html#gac8b793ed162ef61c41412704f68f7f3f">ptlrpcd_ctl_init</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> cpt)
<a name="l00527"></a>00527 {
<a name="l00528"></a>00528         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16" title="Index of ptlrpcd thread in the array.">pc_index</a> = index;
<a name="l00531"></a>00531         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b" title="CPT the thread is bound on.">pc_cpt</a> = cpt;
<a name="l00532"></a>00532         init_completion(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c" title="Start completion.">pc_starting</a>);
<a name="l00533"></a>00533         init_completion(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2db10d4650ee83958fb147906b6fce82" title="Stop completion.">pc_finishing</a>);
<a name="l00534"></a>00534         spin_lock_init(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (index &lt; 0) {
<a name="l00537"></a>00537                 <span class="comment">/* Recovery thread. */</span>
<a name="l00538"></a>00538                 snprintf(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>, <span class="keyword">sizeof</span>(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>), <span class="stringliteral">&quot;ptlrpcd_rcv&quot;</span>);
<a name="l00539"></a>00539         } <span class="keywordflow">else</span> {
<a name="l00540"></a>00540                 <span class="comment">/* Regular thread. */</span>
<a name="l00541"></a>00541                 snprintf(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>, <span class="keyword">sizeof</span>(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>),
<a name="l00542"></a>00542                          <span class="stringliteral">&quot;ptlrpcd_%02d_%02d&quot;</span>, cpt, index);
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment">/* XXX: We want multiple CPU cores to share the async RPC load. So we</span>
<a name="l00549"></a>00549 <span class="comment"> *      start many ptlrpcd threads. We also want to reduce the ptlrpcd</span>
<a name="l00550"></a>00550 <span class="comment"> *      overhead caused by data transfer cross-CPU cores. So we bind</span>
<a name="l00551"></a>00551 <span class="comment"> *      all ptlrpcd threads to a CPT, in the expectation that CPTs</span>
<a name="l00552"></a>00552 <span class="comment"> *      will be defined in a way that matches these boundaries. Within</span>
<a name="l00553"></a>00553 <span class="comment"> *      a CPT a ptlrpcd thread can be scheduled on any available core.</span>
<a name="l00554"></a>00554 <span class="comment"> *</span>
<a name="l00555"></a>00555 <span class="comment"> *      Each ptlrpcd thread has its own request queue. This can cause</span>
<a name="l00556"></a>00556 <span class="comment"> *      response delay if the thread is already busy. To help with</span>
<a name="l00557"></a>00557 <span class="comment"> *      this we define partner threads: these are other threads bound</span>
<a name="l00558"></a>00558 <span class="comment"> *      to the same CPT which will check for work in each other&apos;s</span>
<a name="l00559"></a>00559 <span class="comment"> *      request queues if they have no work to do.</span>
<a name="l00560"></a>00560 <span class="comment"> *</span>
<a name="l00561"></a>00561 <span class="comment"> *      The desired number of partner threads can be tuned by setting</span>
<a name="l00562"></a>00562 <span class="comment"> *      ptlrpcd_partner_group_size. The default is to create pairs of</span>
<a name="l00563"></a>00563 <span class="comment"> *      partner threads.</span>
<a name="l00564"></a>00564 <span class="comment"> */</span>
<a name="l00565"></a><a class="code" href="group__ptlrpcd.html#ga764145e94d8f4420766ad10bfbc1adfe">00565</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga764145e94d8f4420766ad10bfbc1adfe">ptlrpcd_partners</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd.html">ptlrpcd</a> *pd, <span class="keywordtype">int</span> index)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a>      *pc;
<a name="l00568"></a>00568         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a>      **ppc;
<a name="l00569"></a>00569         <span class="keywordtype">int</span>                     first;
<a name="l00570"></a>00570         <span class="keywordtype">int</span>                     i;
<a name="l00571"></a>00571         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00572"></a>00572         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(index &gt;= 0 &amp;&amp; index &lt; pd-&gt;pd_nthreads);
<a name="l00575"></a>00575         pc = &amp;pd-&gt;<a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[index];
<a name="l00576"></a>00576         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> = pd-&gt;<a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">pd_groupsize</a> - 1;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         <span class="keywordflow">if</span> (pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> &lt;= 0)
<a name="l00579"></a>00579                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581         <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>, <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b" title="CPT the thread is bound on.">pc_cpt</a>,
<a name="l00582"></a>00582                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *) * pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>);
<a name="l00583"></a>00583         <span class="keywordflow">if</span> (pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a> == NULL) {
<a name="l00584"></a>00584                 pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> = 0;
<a name="l00585"></a>00585                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENOMEM);
<a name="l00586"></a>00586         }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         first = index - index % pd-&gt;<a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">pd_groupsize</a>;
<a name="l00589"></a>00589         ppc = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>;
<a name="l00590"></a>00590         <span class="keywordflow">for</span> (i = first; i &lt; first + pd-&gt;<a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">pd_groupsize</a>; i++) {
<a name="l00591"></a>00591                 <span class="keywordflow">if</span> (i != index)
<a name="l00592"></a>00592                         *ppc++ = &amp;pd-&gt;<a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[i];
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594 out:
<a name="l00595"></a>00595         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a><a class="code" href="group__ptlrpcd.html#ga92e1290b388e5bd6c5ae97f5c753589a">00598</a> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#ga92e1290b388e5bd6c5ae97f5c753589a">ptlrpcd_start</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc)
<a name="l00599"></a>00599 {
<a name="l00600"></a>00600         <span class="keyword">struct </span>task_struct      *task;
<a name="l00601"></a>00601         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00602"></a>00602         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         <span class="comment">/*</span>
<a name="l00605"></a>00605 <span class="comment">         * Do not allow starting a second thread for one pc.</span>
<a name="l00606"></a>00606 <span class="comment">         */</span>
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (test_and_set_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>)) {
<a name="l00608"></a>00608                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Starting second thread (%s) for same pc %p\n&quot;</span>,
<a name="l00609"></a>00609                       pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>, pc);
<a name="l00610"></a>00610                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         <span class="comment">/*</span>
<a name="l00614"></a>00614 <span class="comment">         * So far only &quot;client&quot; ptlrpcd uses an environment. In the future,</span>
<a name="l00615"></a>00615 <span class="comment">         * ptlrpcd thread (or a thread-set) has to be given an argument,</span>
<a name="l00616"></a>00616 <span class="comment">         * describing its &quot;scope&quot;.</span>
<a name="l00617"></a>00617 <span class="comment">         */</span>
<a name="l00618"></a>00618         rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aaa5b4e6a52cdd4a27ffd97bcd3c5e92c" title="Environment for request interpreters to run in.">pc_env</a>.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>);
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (rc != 0)
<a name="l00620"></a>00620                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         task = kthread_run(<a class="code" href="structptlrpcd.html">ptlrpcd</a>, pc, pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>);
<a name="l00623"></a>00623         <span class="keywordflow">if</span> (IS_ERR(task))
<a name="l00624"></a>00624                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out_set, rc = PTR_ERR(task));
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         wait_for_completion(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c" title="Start completion.">pc_starting</a>);
<a name="l00627"></a>00627         rc = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a191cb4d4f68f14efd9c9661ff5caad0c" title="Error code if the thread failed to fully start.">pc_error</a>;
<a name="l00628"></a>00628         <span class="keywordflow">if</span> (rc != 0)
<a name="l00629"></a>00629                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out_set, rc);
<a name="l00630"></a>00630 
<a name="l00631"></a>00631         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 out_set:
<a name="l00634"></a>00634         <span class="keywordflow">if</span> (pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a> != NULL) {
<a name="l00635"></a>00635                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637                 spin_lock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00638"></a>00638                 pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a> = NULL;
<a name="l00639"></a>00639                 spin_unlock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00640"></a>00640                 <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">set</span>);
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642         <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aaa5b4e6a52cdd4a27ffd97bcd3c5e92c" title="Environment for request interpreters to run in.">pc_env</a>.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00643"></a>00643 out:
<a name="l00644"></a>00644         clear_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00645"></a>00645         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00648"></a><a class="code" href="group__ptlrpcd.html#gadf6c0a253a44e1a561d3650cafa0aeab">00648</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gadf6c0a253a44e1a561d3650cafa0aeab">ptlrpcd_stop</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc, <span class="keywordtype">int</span> force)
<a name="l00649"></a>00649 {
<a name="l00650"></a>00650         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         <span class="keywordflow">if</span> (!test_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>)) {
<a name="l00653"></a>00653                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Thread for pc %p was not started\n&quot;</span>, pc);
<a name="l00654"></a>00654                 <span class="keywordflow">goto</span> out;
<a name="l00655"></a>00655         }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         set_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00658"></a>00658         <span class="keywordflow">if</span> (force)
<a name="l00659"></a>00659                 set_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" title="Ptlrpc thread force flag (only stop force so far).">LIOD_FORCE</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00660"></a>00660         wake_up(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 out:
<a name="l00663"></a>00663         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="group__ptlrpcd.html#gad8ef02e8c2a1c0621b003d24cd5975c4">00666</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gad8ef02e8c2a1c0621b003d24cd5975c4">ptlrpcd_free</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc)
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00669"></a>00669         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         <span class="keywordflow">if</span> (!test_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>)) {
<a name="l00672"></a>00672                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Thread for pc %p was not started\n&quot;</span>, pc);
<a name="l00673"></a>00673                 <span class="keywordflow">goto</span> out;
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         wait_for_completion(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a2db10d4650ee83958fb147906b6fce82" title="Stop completion.">pc_finishing</a>);
<a name="l00677"></a>00677         <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aaa5b4e6a52cdd4a27ffd97bcd3c5e92c" title="Environment for request interpreters to run in.">pc_env</a>.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l00678"></a>00678 
<a name="l00679"></a>00679         spin_lock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00680"></a>00680         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a> = NULL;
<a name="l00681"></a>00681         spin_unlock(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>);
<a name="l00682"></a>00682         <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">set</span>);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684         clear_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00685"></a>00685         clear_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00686"></a>00686         clear_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" title="Ptlrpc thread force flag (only stop force so far).">LIOD_FORCE</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 out:
<a name="l00689"></a>00689         <span class="keywordflow">if</span> (pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> &gt; 0) {
<a name="l00690"></a>00690                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a> != NULL);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692                 <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>,
<a name="l00693"></a>00693                          <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *) * pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>);
<a name="l00694"></a>00694                 pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a> = NULL;
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a> = 0;
<a name="l00697"></a>00697         pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a191cb4d4f68f14efd9c9661ff5caad0c" title="Error code if the thread failed to fully start.">pc_error</a> = 0;
<a name="l00698"></a>00698         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a><a class="code" href="group__ptlrpcd.html#ga173deb041e269c0a7947472f6531f896">00701</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__ptlrpcd.html#ga173deb041e269c0a7947472f6531f896">ptlrpcd_fini</a>(<span class="keywordtype">void</span>)
<a name="l00702"></a>00702 {
<a name="l00703"></a>00703         <span class="keywordtype">int</span>     i;
<a name="l00704"></a>00704         <span class="keywordtype">int</span>     j;
<a name="l00705"></a>00705         <span class="keywordtype">int</span>     ncpts;
<a name="l00706"></a>00706         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keywordflow">if</span> (ptlrpcds != NULL) {
<a name="l00709"></a>00709                 <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="group__ptlrpcd.html#ga017ff18bbbf12192cf2b330e12a7bf49">ptlrpcds_num</a>; i++) {
<a name="l00710"></a>00710                         <span class="keywordflow">if</span> (ptlrpcds[i] == NULL)
<a name="l00711"></a>00711                                 <span class="keywordflow">break</span>;
<a name="l00712"></a>00712                         <span class="keywordflow">for</span> (j = 0; j &lt; ptlrpcds[i]-&gt;<a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">pd_nthreads</a>; j++)
<a name="l00713"></a>00713                                 <a class="code" href="group__net.html#gadf6c0a253a44e1a561d3650cafa0aeab">ptlrpcd_stop</a>(&amp;ptlrpcds[i]-&gt;pd_threads[j], 0);
<a name="l00714"></a>00714                         <span class="keywordflow">for</span> (j = 0; j &lt; ptlrpcds[i]-&gt;<a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">pd_nthreads</a>; j++)
<a name="l00715"></a>00715                                 <a class="code" href="group__net.html#gad8ef02e8c2a1c0621b003d24cd5975c4">ptlrpcd_free</a>(&amp;ptlrpcds[i]-&gt;pd_threads[j]);
<a name="l00716"></a>00716                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(ptlrpcds[i], ptlrpcds[i]-&gt;pd_size);
<a name="l00717"></a>00717                         ptlrpcds[i] = NULL;
<a name="l00718"></a>00718                 }
<a name="l00719"></a>00719                 <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(ptlrpcds, <span class="keyword">sizeof</span>(ptlrpcds[0]) * ptlrpcds_num);
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721         <a class="code" href="group__ptlrpcd.html#ga017ff18bbbf12192cf2b330e12a7bf49">ptlrpcds_num</a> = 0;
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <a class="code" href="group__net.html#gadf6c0a253a44e1a561d3650cafa0aeab">ptlrpcd_stop</a>(&amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>, 0);
<a name="l00724"></a>00724         <a class="code" href="group__net.html#gad8ef02e8c2a1c0621b003d24cd5975c4">ptlrpcd_free</a>(&amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a> != NULL) {
<a name="l00727"></a>00727                 ncpts = <a class="code" href="libcfs__cpu_8h.html#a9f06db96214d81272568b87e30e26d3e" title="return total number of CPU partitions in cptab ">cfs_cpt_number</a>(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>);
<a name="l00728"></a>00728                 <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>, ncpts * <span class="keyword">sizeof</span>(<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>[0]));
<a name="l00729"></a>00729                 <a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a> = NULL;
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734 
<a name="l00735"></a><a class="code" href="group__ptlrpcd.html#gaebe808422bac6e9eb036cf569e852fe4">00735</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__ptlrpcd.html#gaebe808422bac6e9eb036cf569e852fe4">ptlrpcd_init</a>(<span class="keywordtype">void</span>)
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737         <span class="keywordtype">int</span>                     <a class="code" href="mdsrate_8c.html#a2b6a46c4274b223ea03fb4a7b80f4a5a">nthreads</a>;
<a name="l00738"></a>00738         <span class="keywordtype">int</span>                     groupsize;
<a name="l00739"></a>00739         <span class="keywordtype">int</span>                     <a class="code" href="lp__utils_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>;
<a name="l00740"></a>00740         <span class="keywordtype">int</span>                     i;
<a name="l00741"></a>00741         <span class="keywordtype">int</span>                     j;
<a name="l00742"></a>00742         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00743"></a>00743         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>    *cptable;
<a name="l00744"></a>00744         __u32                   *cpts = NULL;
<a name="l00745"></a>00745         <span class="keywordtype">int</span>                     ncpts;
<a name="l00746"></a>00746         <span class="keywordtype">int</span>                     cpt;
<a name="l00747"></a>00747         <span class="keyword">struct </span><a class="code" href="structptlrpcd.html">ptlrpcd</a>          *pd;
<a name="l00748"></a>00748         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="comment">/*</span>
<a name="l00751"></a>00751 <span class="comment">         * Determine the CPTs that ptlrpcd threads will run on.</span>
<a name="l00752"></a>00752 <span class="comment">         */</span>
<a name="l00753"></a>00753         cptable = <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>;
<a name="l00754"></a>00754         ncpts = <a class="code" href="libcfs__cpu_8h.html#a9f06db96214d81272568b87e30e26d3e" title="return total number of CPU partitions in cptab ">cfs_cpt_number</a>(cptable);
<a name="l00755"></a>00755         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a> != NULL) {
<a name="l00756"></a>00756                 <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a>    *el;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758                 size = ncpts * <span class="keyword">sizeof</span>(<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>[0]);
<a name="l00759"></a>00759                 <a class="code" href="obd__support_8h.html#a884069f9eb0bef22c424688b5f3fafba">OBD_ALLOC</a>(<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>, size);
<a name="l00760"></a>00760                 <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a> == NULL)
<a name="l00761"></a>00761                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENOMEM);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763                 rc = <a class="code" href="libcfs__string_8h.html#a9fceedd2da112e9e1d8c5515f7ed3404" title="Parses &amp;lt;cfs_expr_list&amp;gt; token of the syntax.">cfs_expr_list_parse</a>(<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>,
<a name="l00764"></a>00764                                          strlen(<a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>),
<a name="l00765"></a>00765                                          0, ncpts - 1, &amp;el);
<a name="l00766"></a>00766                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00767"></a>00767                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: invalid CPT pattern string: %s&quot;</span>,
<a name="l00768"></a>00768                                <span class="stringliteral">&quot;ptlrpcd_cpts&quot;</span>, <a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>);
<a name="l00769"></a>00769                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -EINVAL);
<a name="l00770"></a>00770                 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772                 rc = <a class="code" href="libcfs__string_8h.html#a0d15cbaaa8cff42763c7cc3ae4192d69" title="Convert express list (expr_list) to an array of all matched values.">cfs_expr_list_values</a>(el, ncpts, &amp;cpts);
<a name="l00773"></a>00773                 <a class="code" href="libcfs__string_8h.html#a6c6e093e43e446f2c506e10b31ae5f1f" title="Frees cfs_range_expr structures of expr_list.">cfs_expr_list_free</a>(el);
<a name="l00774"></a>00774                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00775"></a>00775                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: failed to parse CPT array %s: %d\n&quot;</span>,
<a name="l00776"></a>00776                                <span class="stringliteral">&quot;ptlrpcd_cpts&quot;</span>, <a class="code" href="group__ptlrpcd.html#ga39ee00fea2c30128a7f73313dd863a6e">ptlrpcd_cpts</a>, rc);
<a name="l00777"></a>00777                         <span class="keywordflow">if</span> (rc == 0)
<a name="l00778"></a>00778                                 rc = -EINVAL;
<a name="l00779"></a>00779                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                 <span class="comment">/*</span>
<a name="l00783"></a>00783 <span class="comment">                 * Create the cpt-to-index map. When there is no match</span>
<a name="l00784"></a>00784 <span class="comment">                 * in the cpt table, pick a cpt at random. This could</span>
<a name="l00785"></a>00785 <span class="comment">                 * be changed to take the topology of the system into</span>
<a name="l00786"></a>00786 <span class="comment">                 * account.</span>
<a name="l00787"></a>00787 <span class="comment">                 */</span>
<a name="l00788"></a>00788                 <span class="keywordflow">for</span> (cpt = 0; cpt &lt; ncpts; cpt++) {
<a name="l00789"></a>00789                         <span class="keywordflow">for</span> (i = 0; i &lt; rc; i++)
<a name="l00790"></a>00790                                 <span class="keywordflow">if</span> (cpts[i] == cpt)
<a name="l00791"></a>00791                                         <span class="keywordflow">break</span>;
<a name="l00792"></a>00792                         <span class="keywordflow">if</span> (i &gt;= rc)
<a name="l00793"></a>00793                                 i = cpt % rc;
<a name="l00794"></a>00794                         <a class="code" href="group__ptlrpcd.html#gaaa33d3a9af24cd317ab8fc6de2da819a">ptlrpcds_cpt_idx</a>[cpt] = i;
<a name="l00795"></a>00795                 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797                 <a class="code" href="libcfs__string_8h.html#ac2eeac94f43883683f3c21c629148f7c">cfs_expr_list_values_free</a>(cpts, rc);
<a name="l00798"></a>00798                 ncpts = rc;
<a name="l00799"></a>00799         }
<a name="l00800"></a>00800         <a class="code" href="group__ptlrpcd.html#ga017ff18bbbf12192cf2b330e12a7bf49">ptlrpcds_num</a> = ncpts;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         size = ncpts * <span class="keyword">sizeof</span>(ptlrpcds[0]);
<a name="l00803"></a>00803         <a class="code" href="obd__support_8h.html#a884069f9eb0bef22c424688b5f3fafba">OBD_ALLOC</a>(ptlrpcds, size);
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (ptlrpcds == NULL)
<a name="l00805"></a>00805                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENOMEM);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         <span class="comment">/*</span>
<a name="l00808"></a>00808 <span class="comment">         * The max_ptlrpcds parameter is obsolete, but do something</span>
<a name="l00809"></a>00809 <span class="comment">         * sane if it has been tuned, and complain if</span>
<a name="l00810"></a>00810 <span class="comment">         * ptlrpcd_per_cpt_max has also been tuned.</span>
<a name="l00811"></a>00811 <span class="comment">         */</span>
<a name="l00812"></a>00812         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a> != 0) {
<a name="l00813"></a>00813                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;max_ptlrpcds is obsolete.\n&quot;</span>);
<a name="l00814"></a>00814                 <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a> == 0) {
<a name="l00815"></a>00815                         <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a> = <a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a> / ncpts;
<a name="l00816"></a>00816                         <span class="comment">/* Round up if there is a remainder. */</span>
<a name="l00817"></a>00817                         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#gaa2d648d41351bca341d06dbbfc8cb8cd">max_ptlrpcds</a> % ncpts != 0)
<a name="l00818"></a>00818                                 <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>++;
<a name="l00819"></a>00819                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Setting ptlrpcd_per_cpt_max = %d\n&quot;</span>,
<a name="l00820"></a>00820                               <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>);
<a name="l00821"></a>00821                 } <span class="keywordflow">else</span> {
<a name="l00822"></a>00822                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ptlrpd_per_cpt_max is also set!\n&quot;</span>);
<a name="l00823"></a>00823                 }
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         <span class="comment">/*</span>
<a name="l00827"></a>00827 <span class="comment">         * The ptlrpcd_bind_policy parameter is obsolete, but do</span>
<a name="l00828"></a>00828 <span class="comment">         * something sane if it has been tuned, and complain if</span>
<a name="l00829"></a>00829 <span class="comment">         * ptlrpcd_partner_group_size is also tuned.</span>
<a name="l00830"></a>00830 <span class="comment">         */</span>
<a name="l00831"></a>00831         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">ptlrpcd_bind_policy</a> != 0) {
<a name="l00832"></a>00832                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ptlrpcd_bind_policy is obsolete.\n&quot;</span>);
<a name="l00833"></a>00833                 <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> == 0) {
<a name="l00834"></a>00834                         <span class="keywordflow">switch</span> (<a class="code" href="group__ptlrpcd.html#ga8996b8c047045d33194d9e06a0cbfa8d">ptlrpcd_bind_policy</a>) {
<a name="l00835"></a>00835                         <span class="keywordflow">case</span> 1: <span class="comment">/* PDB_POLICY_NONE */</span>
<a name="l00836"></a>00836                         <span class="keywordflow">case</span> 2: <span class="comment">/* PDB_POLICY_FULL */</span>
<a name="l00837"></a>00837                                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = 1;
<a name="l00838"></a>00838                                 <span class="keywordflow">break</span>;
<a name="l00839"></a>00839                         <span class="keywordflow">case</span> 3: <span class="comment">/* PDB_POLICY_PAIR */</span>
<a name="l00840"></a>00840                                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = 2;
<a name="l00841"></a>00841                                 <span class="keywordflow">break</span>;
<a name="l00842"></a>00842                         <span class="keywordflow">case</span> 4: <span class="comment">/* PDB_POLICY_NEIGHBOR */</span>
<a name="l00843"></a>00843 <span class="preprocessor">#ifdef CONFIG_NUMA</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>                                <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = -1; <span class="comment">/* CPT */</span>
<a name="l00845"></a>00845 <span class="preprocessor">#else</span>
<a name="l00846"></a>00846 <span class="preprocessor"></span>                                <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = 3; <span class="comment">/* Triplets */</span>
<a name="l00847"></a>00847 <span class="preprocessor">#endif</span>
<a name="l00848"></a>00848 <span class="preprocessor"></span>                                <span class="keywordflow">break</span>;
<a name="l00849"></a>00849                         <span class="keywordflow">default</span>: <span class="comment">/* Illegal value, use the default. */</span>
<a name="l00850"></a>00850                                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = 2;
<a name="l00851"></a>00851                                 <span class="keywordflow">break</span>;
<a name="l00852"></a>00852                         }
<a name="l00853"></a>00853                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Setting ptlrpcd_partner_group_size = %d\n&quot;</span>,
<a name="l00854"></a>00854                               <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>);
<a name="l00855"></a>00855                 } <span class="keywordflow">else</span> {
<a name="l00856"></a>00856                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ptlrpcd_partner_group_size is also set!\n&quot;</span>);
<a name="l00857"></a>00857                 }
<a name="l00858"></a>00858         }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860         <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> == 0)
<a name="l00861"></a>00861                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = 2;
<a name="l00862"></a>00862         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> &lt; 0)
<a name="l00863"></a>00863                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = -1;
<a name="l00864"></a>00864         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a> &gt; 0 &amp;&amp;
<a name="l00865"></a>00865                  <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> &gt; <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>)
<a name="l00866"></a>00866                 <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> = <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         <span class="comment">/*</span>
<a name="l00869"></a>00869 <span class="comment">         * Start the recovery thread first.</span>
<a name="l00870"></a>00870 <span class="comment">         */</span>
<a name="l00871"></a>00871         set_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b" title="This is a recovery ptlrpc thread.">LIOD_RECOVERY</a>, &amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>.<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>);
<a name="l00872"></a>00872         <a class="code" href="group__ptlrpcd.html#gac8b793ed162ef61c41412704f68f7f3f">ptlrpcd_ctl_init</a>(&amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>, -1, <a class="code" href="libcfs__cpu_8h.html#a0628df10a6276d56b4dd55643cf7ccbe">CFS_CPT_ANY</a>);
<a name="l00873"></a>00873         rc = <a class="code" href="group__ptlrpcd.html#ga92e1290b388e5bd6c5ae97f5c753589a">ptlrpcd_start</a>(&amp;<a class="code" href="group__ptlrpcd.html#ga550d33725a6034d2b73ee1ac87e7b087">ptlrpcd_rcv</a>);
<a name="l00874"></a>00874         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00875"></a>00875                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         <span class="keywordflow">for</span> (i = 0; i &lt; ncpts; i++) {
<a name="l00878"></a>00878                 <span class="keywordflow">if</span> (cpts == NULL)
<a name="l00879"></a>00879                         cpt = i;
<a name="l00880"></a>00880                 <span class="keywordflow">else</span>
<a name="l00881"></a>00881                         cpt = cpts[i];
<a name="l00882"></a>00882 
<a name="l00883"></a>00883                 nthreads = <a class="code" href="libcfs__cpu_8h.html#a490feb884ea09b464c88c79377cb22ee" title="return number of HW cores or hypter-threadings in a CPU partition cpt ">cfs_cpt_weight</a>(cptable, cpt);
<a name="l00884"></a>00884                 <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a> &gt; 0 &amp;&amp; <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a> &lt; nthreads)
<a name="l00885"></a>00885                         nthreads = <a class="code" href="group__ptlrpcd.html#ga8bf56da50f49fb9cc7c0bc52bc8e78eb">ptlrpcd_per_cpt_max</a>;
<a name="l00886"></a>00886                 <span class="keywordflow">if</span> (nthreads &lt; 2)
<a name="l00887"></a>00887                         nthreads = 2;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889                 <span class="keywordflow">if</span> (<a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a> &lt;= 0) {
<a name="l00890"></a>00890                         groupsize = nthreads;
<a name="l00891"></a>00891                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nthreads &lt;= <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>) {
<a name="l00892"></a>00892                         groupsize = nthreads;
<a name="l00893"></a>00893                 } <span class="keywordflow">else</span> {
<a name="l00894"></a>00894                         groupsize = <a class="code" href="group__ptlrpcd.html#ga93b98f6cd43f50f5c001464b4d516613">ptlrpcd_partner_group_size</a>;
<a name="l00895"></a>00895                         <span class="keywordflow">if</span> (nthreads % groupsize != 0)
<a name="l00896"></a>00896                                 nthreads += groupsize - (nthreads % groupsize);
<a name="l00897"></a>00897                 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899                 size = <a class="code" href="group__lustreuser.html#gad4a7496cd704df3829c87864e7dbd703">offsetof</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpcd.html">ptlrpcd</a>, pd_threads[nthreads]);
<a name="l00900"></a>00900                 <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(pd, cptable, cpt, size);
<a name="l00901"></a>00901                 <span class="keywordflow">if</span> (!pd)
<a name="l00902"></a>00902                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENOMEM);
<a name="l00903"></a>00903                 pd-&gt;<a class="code" href="structptlrpcd.html#afb62def8a43d07db7d23ed0bee27d65c">pd_size</a>      = size;
<a name="l00904"></a>00904                 pd-&gt;<a class="code" href="structptlrpcd.html#a850faefbcfa515eff5274459c9ca76ff">pd_index</a>     = i;
<a name="l00905"></a>00905                 pd-&gt;<a class="code" href="structptlrpcd.html#a6fd484fb1c4348b321127426b94f0c05">pd_cpt</a>       = cpt;
<a name="l00906"></a>00906                 pd-&gt;<a class="code" href="structptlrpcd.html#ab973c62099c279e7cde4f49a41a9ee3c">pd_cursor</a>    = 0;
<a name="l00907"></a>00907                 pd-&gt;<a class="code" href="structptlrpcd.html#a88469310745164d340582b14c2641625">pd_nthreads</a>  = nthreads;
<a name="l00908"></a>00908                 pd-&gt;<a class="code" href="structptlrpcd.html#a9b5b27387e1ac4645e8e9807f0d6f0f1">pd_groupsize</a> = groupsize;
<a name="l00909"></a>00909                 ptlrpcds[i] = pd;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911                 <span class="comment">/*</span>
<a name="l00912"></a>00912 <span class="comment">                 * The ptlrpcd threads in a partner group can access</span>
<a name="l00913"></a>00913 <span class="comment">                 * each other&apos;s struct ptlrpcd_ctl, so these must be</span>
<a name="l00914"></a>00914 <span class="comment">                 * initialized before any thead is started.</span>
<a name="l00915"></a>00915 <span class="comment">                 */</span>
<a name="l00916"></a>00916                 <span class="keywordflow">for</span> (j = 0; j &lt; nthreads; j++) {
<a name="l00917"></a>00917                         <a class="code" href="group__ptlrpcd.html#gac8b793ed162ef61c41412704f68f7f3f">ptlrpcd_ctl_init</a>(&amp;pd-&gt;<a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[j], j, cpt);
<a name="l00918"></a>00918                         rc = <a class="code" href="group__ptlrpcd.html#ga764145e94d8f4420766ad10bfbc1adfe">ptlrpcd_partners</a>(pd, j);
<a name="l00919"></a>00919                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00920"></a>00920                                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00921"></a>00921                 }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923                 <span class="comment">/* XXX: We start nthreads ptlrpc daemons on this cpt.</span>
<a name="l00924"></a>00924 <span class="comment">                 *      Each of them can process any non-recovery</span>
<a name="l00925"></a>00925 <span class="comment">                 *      async RPC to improve overall async RPC</span>
<a name="l00926"></a>00926 <span class="comment">                 *      efficiency.</span>
<a name="l00927"></a>00927 <span class="comment">                 *</span>
<a name="l00928"></a>00928 <span class="comment">                 *      But there are some issues with async I/O RPCs</span>
<a name="l00929"></a>00929 <span class="comment">                 *      and async non-I/O RPCs processed in the same</span>
<a name="l00930"></a>00930 <span class="comment">                 *      set under some cases. The ptlrpcd may be</span>
<a name="l00931"></a>00931 <span class="comment">                 *      blocked by some async I/O RPC(s), then will</span>
<a name="l00932"></a>00932 <span class="comment">                 *      cause other async non-I/O RPC(s) can not be</span>
<a name="l00933"></a>00933 <span class="comment">                 *      processed in time.</span>
<a name="l00934"></a>00934 <span class="comment">                 *</span>
<a name="l00935"></a>00935 <span class="comment">                 *      Maybe we should distinguish blocked async RPCs</span>
<a name="l00936"></a>00936 <span class="comment">                 *      from non-blocked async RPCs, and process them</span>
<a name="l00937"></a>00937 <span class="comment">                 *      in different ptlrpcd sets to avoid unnecessary</span>
<a name="l00938"></a>00938 <span class="comment">                 *      dependency. But how to distribute async RPCs</span>
<a name="l00939"></a>00939 <span class="comment">                 *      load among all the ptlrpc daemons becomes</span>
<a name="l00940"></a>00940 <span class="comment">                 *      another trouble.</span>
<a name="l00941"></a>00941 <span class="comment">                 */</span>
<a name="l00942"></a>00942                 <span class="keywordflow">for</span> (j = 0; j &lt; nthreads; j++) {
<a name="l00943"></a>00943                         rc = <a class="code" href="group__ptlrpcd.html#ga92e1290b388e5bd6c5ae97f5c753589a">ptlrpcd_start</a>(&amp;pd-&gt;<a class="code" href="structptlrpcd.html#ac921cd095621551b48ae6ede6915c8d0">pd_threads</a>[j]);
<a name="l00944"></a>00944                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00945"></a>00945                                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00946"></a>00946                 }
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 out:
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (rc != 0)
<a name="l00950"></a>00950                 <a class="code" href="group__ptlrpcd.html#ga173deb041e269c0a7947472f6531f896">ptlrpcd_fini</a>();
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00953"></a>00953 }
<a name="l00954"></a>00954 
<a name="l00955"></a><a class="code" href="group__ptlrpcd.html#ga2b4cdaf9bce76784e8efa1f9bda8c58b">00955</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga2b4cdaf9bce76784e8efa1f9bda8c58b">ptlrpcd_addref</a>(<span class="keywordtype">void</span>)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957         <span class="keywordtype">int</span> rc = 0;
<a name="l00958"></a>00958         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960         mutex_lock(&amp;<a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">ptlrpcd_mutex</a>);
<a name="l00961"></a>00961         <span class="keywordflow">if</span> (++<a class="code" href="group__ptlrpcd.html#gab1e1324450eb18f953c4131b03edcc80">ptlrpcd_users</a> == 1) {
<a name="l00962"></a>00962                 rc = <a class="code" href="group__ptlrpcd.html#gaebe808422bac6e9eb036cf569e852fe4">ptlrpcd_init</a>();
<a name="l00963"></a>00963                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00964"></a>00964                         <a class="code" href="group__ptlrpcd.html#gab1e1324450eb18f953c4131b03edcc80">ptlrpcd_users</a>--;
<a name="l00965"></a>00965         }
<a name="l00966"></a>00966         mutex_unlock(&amp;<a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">ptlrpcd_mutex</a>);
<a name="l00967"></a>00967         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00968"></a>00968 }
<a name="l00969"></a>00969 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga2b4cdaf9bce76784e8efa1f9bda8c58b">ptlrpcd_addref</a>);
<a name="l00970"></a>00970 
<a name="l00971"></a><a class="code" href="group__ptlrpcd.html#ga54a4bcf408e22400c741b530bbb8ec06">00971</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga54a4bcf408e22400c741b530bbb8ec06">ptlrpcd_decref</a>(<span class="keywordtype">void</span>)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973         mutex_lock(&amp;<a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">ptlrpcd_mutex</a>);
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (--<a class="code" href="group__ptlrpcd.html#gab1e1324450eb18f953c4131b03edcc80">ptlrpcd_users</a> == 0)
<a name="l00975"></a>00975                 <a class="code" href="group__ptlrpcd.html#ga173deb041e269c0a7947472f6531f896">ptlrpcd_fini</a>();
<a name="l00976"></a>00976         mutex_unlock(&amp;<a class="code" href="group__ptlrpcd.html#ga7723c3e0086e4476292c06bb0fa8db00">ptlrpcd_mutex</a>);
<a name="l00977"></a>00977 }
<a name="l00978"></a>00978 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga54a4bcf408e22400c741b530bbb8ec06">ptlrpcd_decref</a>);
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:43 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
