<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt_object_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dt_object_operations Struct Reference<br/>
<small>
[<a class="el" href="group__dt.html">dt</a>]</small>
</h1><!-- doxytag: class="dt_object_operations" -->
<p>A <a class="el" href="structdt__object.html">dt_object</a> provides common operations to create and destroy objects and to manage regular and extended attributes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dt__object_8h_source.html">dt_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a32a37f3abca0903ec9fa5c70b2b7a423">do_read_lock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, unsigned role)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get read lock on object.  <a href="#a32a37f3abca0903ec9fa5c70b2b7a423"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a5bf582901eb4dcb781f03f02621535a2">do_write_lock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, unsigned role)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a5d68d191697e7964615a090f9896f7f5">do_read_unlock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release read lock.  <a href="#a5d68d191697e7964615a090f9896f7f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ad5346269fb80455252849f4fd7403720">do_write_unlock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release write lock.  <a href="#ad5346269fb80455252849f4fd7403720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a9072566fd18a198a7323439603b6fbdf">do_write_locked</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether write lock is held.  <a href="#a9072566fd18a198a7323439603b6fbdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#adc1fb34feaf57d9448beaab7f04302bd">do_declare_attr_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to request reqular attributes.  <a href="#adc1fb34feaf57d9448beaab7f04302bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a1d2ff17287fa229d0325cccf0aac5beb">do_attr_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return regular attributes.  <a href="#a1d2ff17287fa229d0325cccf0aac5beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a44eb5df458974e0568eba9863c439362">do_declare_attr_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to change regular object's attributes.  <a href="#a44eb5df458974e0568eba9863c439362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#aa9a55847088d77aa8bbc16c693344ddb">do_attr_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change regular attributes.  <a href="#aa9a55847088d77aa8bbc16c693344ddb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a2032c927c95147729dd7a7247c5c12aa">do_declare_xattr_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to request extented attribute.  <a href="#a2032c927c95147729dd7a7247c5c12aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#af4c8c504e52a5571dbd0557980c3818a">do_xattr_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a value of an extended attribute.  <a href="#af4c8c504e52a5571dbd0557980c3818a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ad5d602fce101080720544cbdb0de96e8">do_declare_xattr_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, int fl, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to change an extended attribute.  <a href="#ad5d602fce101080720544cbdb0de96e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a231db7d512a5786b8ad887e9fc47190b">do_xattr_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, int fl, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an extended attribute.  <a href="#a231db7d512a5786b8ad887e9fc47190b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a7b2e57f4c0bdb5108e9d1920242e813e">do_declare_xattr_del</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to delete an extended attribute.  <a href="#a7b2e57f4c0bdb5108e9d1920242e813e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a19762fb1d9e75136521019d51759b6ec">do_xattr_del</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an extended attribute.  <a href="#a19762fb1d9e75136521019d51759b6ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a0ace7a9f2e3ae94bb5d5b7434917f0f1">do_xattr_list</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of the extended attributes.  <a href="#a0ace7a9f2e3ae94bb5d5b7434917f0f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a00fed99bee94890d3e36719af00d5595">do_ah_init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *ah, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, struct <a class="el" href="structdt__object.html">dt_object</a> *child, umode_t <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare allocation hint for a new object.  <a href="#a00fed99bee94890d3e36719af00d5595"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ab16b75516dfd3d619fbffbc96f2b9d24">do_declare_create</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *hint, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to create a new object.  <a href="#ab16b75516dfd3d619fbffbc96f2b9d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ac1ca5a81cd3d00bd821fbfead64022c3">do_create</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *hint, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new object.  <a href="#ac1ca5a81cd3d00bd821fbfead64022c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#af211c9cc7a0203979cd8cf0f0b81b293">do_declare_destroy</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to destroy an object.  <a href="#af211c9cc7a0203979cd8cf0f0b81b293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a19ddd277003c24371f8c5771a2ba77bb">do_destroy</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an object.  <a href="#a19ddd277003c24371f8c5771a2ba77bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2">do_index_try</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structdt__index__features.html">dt_index_features</a> *feat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try object as an index.  <a href="#ac317771bd9f0827b4d8fcec4d51a63c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a53431a1038b787ca15950b5a0495408b">do_declare_ref_add</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to increment nlink count.  <a href="#a53431a1038b787ca15950b5a0495408b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a3ea43d6a7abb742fb238acc711b3bd2b">do_ref_add</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment nlink.  <a href="#a3ea43d6a7abb742fb238acc711b3bd2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#ae33177c8da269d507a9b22b8066ae5f4">do_declare_ref_del</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to decrement nlink count.  <a href="#ae33177c8da269d507a9b22b8066ae5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a8d0abf79c5dace1f0839aefe251bfc1f">do_ref_del</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement nlink.  <a href="#a8d0abf79c5dace1f0839aefe251bfc1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a2e3f3539d6ce344b27712d4b2f39d7b2">do_object_sync</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *obj, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sync obect.  <a href="#a2e3f3539d6ce344b27712d4b2f39d7b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a1f63b46e6b64b5c8ba9e81492e0c2f19">do_object_lock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lh, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock object.  <a href="#a1f63b46e6b64b5c8ba9e81492e0c2f19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html#a0cc597f75bd319af28376e8a280a6ae3">do_object_unlock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock object.  <a href="#a0cc597f75bd319af28376e8a280a6ae3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A <a class="el" href="structdt__object.html">dt_object</a> provides common operations to create and destroy objects and to manage regular and extended attributes. </p>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l00425">425</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a00fed99bee94890d3e36719af00d5595"></a><!-- doxytag: member="dt_object_operations::do_ah_init" ref="a00fed99bee94890d3e36719af00d5595" args=")(const struct lu_env *env, struct dt_allocation_hint *ah, struct dt_object *parent, struct dt_object *child, umode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__object__operations.html#a00fed99bee94890d3e36719af00d5595">dt_object_operations::do_ah_init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *ah, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, struct <a class="el" href="structdt__object.html">dt_object</a> *child, umode_t <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare allocation hint for a new object. </p>
<p>This method is used by the caller to inform OSD of the parent-child relationship between two objects and enable efficient object allocation. Filled allocation hint will be passed to -&gt;<a class="el" href="structdt__object__operations.html#ac1ca5a81cd3d00bd821fbfead64022c3" title="Create new object.">do_create()</a> later.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ah</em>&nbsp;</td><td>allocation hint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>parent object (can be NULL) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>child</em>&nbsp;</td><td>child object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_mode</em>&nbsp;</td><td>type of the child object </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="lfsck__namespace_8c_source.html#l01226">lfsck_namespace_create_orphan_dir()</a>, <a class="el" href="lfsck__namespace_8c_source.html#l04790">lfsck_namespace_repair_dangling()</a>, <a class="el" href="lod__object_8c_source.html#l03075">lod_ah_init()</a>, and <a class="el" href="mdd__object_8c_source.html#l01571">mdd_object_make_hint()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d2ff17287fa229d0325cccf0aac5beb"></a><!-- doxytag: member="dt_object_operations::do_attr_get" ref="a1d2ff17287fa229d0325cccf0aac5beb" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_attr *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a1d2ff17287fa229d0325cccf0aac5beb">dt_object_operations::do_attr_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return regular attributes. </p>
<p>The object must exist. Currently all the attributes should be returned, but in the future this can be improved so that only a selected set is returned. This can improve performance as in some cases attributes are stored in different places and getting them all can be an iterative and expensive process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>attributes to fill</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02225">dt_attr_get()</a>, <a class="el" href="llog_8c_source.html#l01252">llog_size()</a>, and <a class="el" href="osp__object_8c_source.html#l02127">osp_object_init()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9a55847088d77aa8bbc16c693344ddb"></a><!-- doxytag: member="dt_object_operations::do_attr_set" ref="aa9a55847088d77aa8bbc16c693344ddb" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_attr *attr, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#aa9a55847088d77aa8bbc16c693344ddb">dt_object_operations::do_attr_set</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change regular attributes. </p>
<p>Change regular attributes in the given transaction. Note only attributes flagged by <a class="el" href="group__lu.html#ga88a0b6df60974746bbc3b1a79da159a8" title="Bit-mask of valid attributes.">attr.la_valid</a> change. The object must exist. If the layer implementing this method is responsible for quota, then the method should maintain object accounting for the given credentials when la_uid/la_gid changes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>new attributes to apply </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02253">dt_attr_set()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1ca5a81cd3d00bd821fbfead64022c3"></a><!-- doxytag: member="dt_object_operations::do_create" ref="ac1ca5a81cd3d00bd821fbfead64022c3" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_attr *attr, struct dt_allocation_hint *hint, struct dt_object_format *dof, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#ac1ca5a81cd3d00bd821fbfead64022c3">dt_object_operations::do_create</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *hint, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create new object. </p>
<p>The method creates the object passed with the specified attributes and object format. Object allocation procedure can use information stored in the allocation hint. Different object formats are supported (see enum dt_format_type and struct <a class="el" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a>) depending on the device. If creation succeeds, then LOHA_EXISTS flag must be set in the LU-object header attributes.</p>
<p>If the layer implementing this method is responsible for quota, then the method should maintain object accounting for the given credentials.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>attributes of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hint</em>&nbsp;</td><td>allocation hint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dof</em>&nbsp;</td><td>object format </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02120">dt_create()</a>.</p>

</div>
</div>
<a class="anchor" id="adc1fb34feaf57d9448beaab7f04302bd"></a><!-- doxytag: member="dt_object_operations::do_declare_attr_get" ref="adc1fb34feaf57d9448beaab7f04302bd" args=")(const struct lu_env *env, struct dt_object *dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#adc1fb34feaf57d9448beaab7f04302bd">dt_object_operations::do_declare_attr_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to request reqular attributes. </p>
<p>Notity the underlying filesystem that the caller may request regular attributes with -&gt;<a class="el" href="structdt__object__operations.html#a1d2ff17287fa229d0325cccf0aac5beb" title="Return regular attributes.">do_attr_get()</a> soon. This allows OSD to implement prefetching logic in an object-oriented manner. The implementation can be noop. This method should avoid expensive delays such as waiting on disk I/O, otherwise the goal of enabling a performance optimization would be defeated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02212">dt_declare_attr_get()</a>.</p>

</div>
</div>
<a class="anchor" id="a44eb5df458974e0568eba9863c439362"></a><!-- doxytag: member="dt_object_operations::do_declare_attr_set" ref="a44eb5df458974e0568eba9863c439362" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_attr *attr, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a44eb5df458974e0568eba9863c439362">dt_object_operations::do_declare_attr_set</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to change regular object's attributes. </p>
<p>Notify the underlying filesystem that the regular attributes may change in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. Note that the la_valid field of <em>attr</em> specifies which attributes will change. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>attributes to change specified in <a class="el" href="group__lu.html#ga88a0b6df60974746bbc3b1a79da159a8" title="Bit-mask of valid attributes.">attr.la_valid</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02238">dt_declare_attr_set()</a>.</p>

</div>
</div>
<a class="anchor" id="ab16b75516dfd3d619fbffbc96f2b9d24"></a><!-- doxytag: member="dt_object_operations::do_declare_create" ref="ab16b75516dfd3d619fbffbc96f2b9d24" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_attr *attr, struct dt_allocation_hint *hint, struct dt_object_format *dof, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#ab16b75516dfd3d619fbffbc96f2b9d24">dt_object_operations::do_declare_create</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a> *hint, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to create a new object. </p>
<p>Notify the underlying filesystem that the object may be created in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it.</p>
<p>If the layer implementing this method is responsible for quota, then the method should reserve an object for the given credentials and return an error if quota is over. If object creation later fails for some reason, then the reservation should be released properly (usually in -&gt;<a class="el" href="group__dt.html#gac5cb16311e5767ec9068c9aac417628a">dt_trans_stop()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>attributes of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hint</em>&nbsp;</td><td>allocation hint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dof</em>&nbsp;</td><td>object format </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02103">dt_declare_create()</a>.</p>

</div>
</div>
<a class="anchor" id="af211c9cc7a0203979cd8cf0f0b81b293"></a><!-- doxytag: member="dt_object_operations::do_declare_destroy" ref="af211c9cc7a0203979cd8cf0f0b81b293" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#af211c9cc7a0203979cd8cf0f0b81b293">dt_object_operations::do_declare_destroy</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to destroy an object. </p>
<p>Notify the underlying filesystem that the object may be destroyed in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02137">dt_declare_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a53431a1038b787ca15950b5a0495408b"></a><!-- doxytag: member="dt_object_operations::do_declare_ref_add" ref="a53431a1038b787ca15950b5a0495408b" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a53431a1038b787ca15950b5a0495408b">dt_object_operations::do_declare_ref_add</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to increment nlink count. </p>
<p>Notify the underlying filesystem that the nlink regular attribute be changed in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02266">dt_declare_ref_add()</a>.</p>

</div>
</div>
<a class="anchor" id="ae33177c8da269d507a9b22b8066ae5f4"></a><!-- doxytag: member="dt_object_operations::do_declare_ref_del" ref="ae33177c8da269d507a9b22b8066ae5f4" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#ae33177c8da269d507a9b22b8066ae5f4">dt_object_operations::do_declare_ref_del</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to decrement nlink count. </p>
<p>Notify the underlying filesystem that the nlink regular attribute be changed in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02292">dt_declare_ref_del()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b2e57f4c0bdb5108e9d1920242e813e"></a><!-- doxytag: member="dt_object_operations::do_declare_xattr_del" ref="a7b2e57f4c0bdb5108e9d1920242e813e" args=")(const struct lu_env *env, struct dt_object *dt, const char *name, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a7b2e57f4c0bdb5108e9d1920242e813e">dt_object_operations::do_declare_xattr_del</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to delete an extended attribute. </p>
<p>Notify the underlying filesystem that the extended attribute may be deleted in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02514">dt_declare_xattr_del()</a>.</p>

</div>
</div>
<a class="anchor" id="a2032c927c95147729dd7a7247c5c12aa"></a><!-- doxytag: member="dt_object_operations::do_declare_xattr_get" ref="a2032c927c95147729dd7a7247c5c12aa" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_buf *buf, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a2032c927c95147729dd7a7247c5c12aa">dt_object_operations::do_declare_xattr_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to request extented attribute. </p>
<p>Notify the underlying filesystem that the caller may request extended attribute with -&gt;<a class="el" href="structdt__object__operations.html#af4c8c504e52a5571dbd0557980c3818a" title="Return a value of an extended attribute.">do_xattr_get()</a> soon. This allows OSD to implement prefetching logic in an object-oriented manner. The implementation can be noop. This method should avoid expensive delays such as waiting on disk I/O, otherwise the goal of enabling a performance optimization would be defeated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>unused, may be removed in the future </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the extended attribute</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02573">dt_declare_xattr_get()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d602fce101080720544cbdb0de96e8"></a><!-- doxytag: member="dt_object_operations::do_declare_xattr_set" ref="ad5d602fce101080720544cbdb0de96e8" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf, const char *name, int fl, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#ad5d602fce101080720544cbdb0de96e8">dt_object_operations::do_declare_xattr_set</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, int fl, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to change an extended attribute. </p>
<p>Notify the underlying filesystem that the extended attribute may change in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer storing new value of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fl</em>&nbsp;</td><td>LU_XATTR_CREATE - fail if EA exists LU_XATTR_REPLACE - fail if EA doesn't exist </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02543">dt_declare_xattr_set()</a>.</p>

</div>
</div>
<a class="anchor" id="a19ddd277003c24371f8c5771a2ba77bb"></a><!-- doxytag: member="dt_object_operations::do_destroy" ref="a19ddd277003c24371f8c5771a2ba77bb" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a19ddd277003c24371f8c5771a2ba77bb">dt_object_operations::do_destroy</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy an object. </p>
<p>This method destroys the object and all the resources associated with the object (data, key/value pairs, extended attributes, etc). The object must exist. If destroy is successful, then flag LU_OBJECT_HEARD_BANSHEE should be set to forbid access to this instance of in-core object. Any subsequent access to the same FID should get another instance with no LOHA_EXIST flag set.</p>
<p>If the layer implementing this method is responsible for quota, then the method should maintain object accounting for the given credentials.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02151">dt_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ac317771bd9f0827b4d8fcec4d51a63c2"></a><!-- doxytag: member="dt_object_operations::do_index_try" ref="ac317771bd9f0827b4d8fcec4d51a63c2" args=")(const struct lu_env *env, struct dt_object *dt, const struct dt_index_features *feat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2">dt_object_operations::do_index_try</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structdt__index__features.html">dt_index_features</a> *feat)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try object as an index. </p>
<p>Announce that this object is going to be used as an index. This operation checks that object supports indexing operations and installs appropriate <a class="el" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> vector on success. Also probes for features. Operation is successful if all required features are supported. It's not possible to access the object with index methods before -&gt;<a class="el" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try()</a> returns success.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>feat</em>&nbsp;</td><td>index features</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="lquota__lib_8c_source.html#l00065">acct_obj_lookup()</a>, <a class="el" href="dt__object_8c_source.html#l00911">dt_index_read()</a>, <a class="el" href="dt__object_8c_source.html#l00184">dt_try_as_dir()</a>, <a class="el" href="fld__index_8c_source.html#l00326">fld_index_init()</a>, <a class="el" href="lfsck__layout_8c_source.html#l02511">lfsck_layout_scan_orphan()</a>, <a class="el" href="lfsck__namespace_8c_source.html#l00460">lfsck_namespace_load_sub_trace_files()</a>, <a class="el" href="lfsck__lib_8c_source.html#l03474">lfsck_register()</a>, <a class="el" href="lod__object_8c_source.html#l03600">lod_declare_object_destroy()</a>, <a class="el" href="lod__object_8c_source.html#l00954">lod_index_try()</a>, <a class="el" href="lod__object_8c_source.html#l03679">lod_object_destroy()</a>, <a class="el" href="lod__object_8c_source.html#l00517">lod_striped_it_next()</a>, <a class="el" href="lquota__disk_8c_source.html#l00234">lquota_disk_glb_find_create()</a>, <a class="el" href="lquota__disk_8c_source.html#l00307">lquota_disk_slv_find()</a>, <a class="el" href="lquota__disk_8c_source.html#l00375">lquota_disk_slv_find_create()</a>, <a class="el" href="mgs__fs_8c_source.html#l00116">mgs_fs_setup()</a>, and <a class="el" href="lquota__lib_8c_source.html#l00109">quota_obj_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f63b46e6b64b5c8ba9e81492e0c2f19"></a><!-- doxytag: member="dt_object_operations::do_object_lock" ref="a1f63b46e6b64b5c8ba9e81492e0c2f19" args=")(const struct lu_env *env, struct dt_object *dt, struct lustre_handle *lh, struct ldlm_enqueue_info *einfo, union ldlm_policy_data *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a1f63b46e6b64b5c8ba9e81492e0c2f19">dt_object_operations::do_object_lock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lh, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock object. </p>
<p>Lock object(s) using Distributed Lock Manager (LDLM).</p>
<p>Get LDLM locks for the object. Currently used to lock "remote" objects in DNE configuration - a service running on MDTx needs to lock an object on MDTy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lh</em>&nbsp;</td><td>lock handle, sometimes used, sometimes not </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>einfo</em>&nbsp;</td><td>ldlm callbacks, locking type and mode </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>einfo</em>&nbsp;</td><td>private data to be passed to unlock later </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>inodebits data</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l01990">dt_object_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3f3539d6ce344b27712d4b2f39d7b2"></a><!-- doxytag: member="dt_object_operations::do_object_sync" ref="a2e3f3539d6ce344b27712d4b2f39d7b2" args=")(const struct lu_env *env, struct dt_object *obj, __u64 start, __u64 end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a2e3f3539d6ce344b27712d4b2f39d7b2">dt_object_operations::do_object_sync</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *obj, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sync obect. </p>
<p>The method is called to sync specified range of the object to a persistent storage. The control is returned once the operation is complete. The difference from -&gt;do_sync() is that the object can be in-sync with the persistent storage (nothing to flush), then the method returns quickly with no I/O overhead. So, this method should be preferred over -&gt;do_sync() where possible. Also note that if the object isn't clean, then some disk filesystems will call -&gt;do_sync() to maintain overall consistency, in which case it's still very expensive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>start of the range to sync </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>end</em>&nbsp;</td><td>end of the range to sync</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02015">dt_object_sync()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cc597f75bd319af28376e8a280a6ae3"></a><!-- doxytag: member="dt_object_operations::do_object_unlock" ref="a0cc597f75bd319af28376e8a280a6ae3" args=")(const struct lu_env *env, struct dt_object *dt, struct ldlm_enqueue_info *einfo, union ldlm_policy_data *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a0cc597f75bd319af28376e8a280a6ae3">dt_object_operations::do_object_unlock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock object. </p>
<p>Release LDLM lock(s) granted with -&gt;<a class="el" href="structdt__object__operations.html#a1f63b46e6b64b5c8ba9e81492e0c2f19" title="Lock object.">do_object_lock()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>einfo</em>&nbsp;</td><td>lock handles, from -&gt;<a class="el" href="structdt__object__operations.html#a1f63b46e6b64b5c8ba9e81492e0c2f19" title="Lock object.">do_object_lock()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>inodebits data</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02001">dt_object_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a32a37f3abca0903ec9fa5c70b2b7a423"></a><!-- doxytag: member="dt_object_operations::do_read_lock" ref="a32a37f3abca0903ec9fa5c70b2b7a423" args=")(const struct lu_env *env, struct dt_object *dt, unsigned role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__object__operations.html#a32a37f3abca0903ec9fa5c70b2b7a423">dt_object_operations::do_read_lock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, unsigned role)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get read lock on object. </p>
<p>Read lock is compatible with other read locks, so it's shared. Read lock is not compatible with write lock which is exclusive. The lock is blocking and can't be used from an interrupt context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object to lock for reading </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>role</em>&nbsp;</td><td>a hint to debug locks (see kernel's mutexes) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02165">dt_read_lock()</a>, and <a class="el" href="ofd__internal_8h_source.html#l00255">ofd_read_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d68d191697e7964615a090f9896f7f5"></a><!-- doxytag: member="dt_object_operations::do_read_unlock" ref="a5d68d191697e7964615a090f9896f7f5" args=")(const struct lu_env *env, struct dt_object *dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__object__operations.html#a5d68d191697e7964615a090f9896f7f5">dt_object_operations::do_read_unlock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release read lock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02185">dt_read_unlock()</a>, and <a class="el" href="ofd__internal_8h_source.html#l00263">ofd_read_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ea43d6a7abb742fb238acc711b3bd2b"></a><!-- doxytag: member="dt_object_operations::do_ref_add" ref="a3ea43d6a7abb742fb238acc711b3bd2b" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a3ea43d6a7abb742fb238acc711b3bd2b">dt_object_operations::do_ref_add</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment nlink. </p>
<p>Increment nlink (from the regular attributes set) in the given transaction. Note the absolute limit for nlink should be learnt from struct <a class="el" href="structdt__device__param.html#afa03d8318289ddd8632da0d981295bb9">dt_device_param::ddp_max_nlink</a>. The object must exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02279">dt_ref_add()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d0abf79c5dace1f0839aefe251bfc1f"></a><!-- doxytag: member="dt_object_operations::do_ref_del" ref="a8d0abf79c5dace1f0839aefe251bfc1f" args=")(const struct lu_env *env, struct dt_object *dt, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a8d0abf79c5dace1f0839aefe251bfc1f">dt_object_operations::do_ref_del</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement nlink. </p>
<p>Decrement nlink (from the regular attributes set) in the given transaction. The object must exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02305">dt_ref_del()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf582901eb4dcb781f03f02621535a2"></a><!-- doxytag: member="dt_object_operations::do_write_lock" ref="a5bf582901eb4dcb781f03f02621535a2" args=")(const struct lu_env *env, struct dt_object *dt, unsigned role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__object__operations.html#a5bf582901eb4dcb781f03f02621535a2">dt_object_operations::do_write_lock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, unsigned role)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02175">dt_write_lock()</a>, and <a class="el" href="ofd__internal_8h_source.html#l00271">ofd_write_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a9072566fd18a198a7323439603b6fbdf"></a><!-- doxytag: member="dt_object_operations::do_write_locked" ref="a9072566fd18a198a7323439603b6fbdf" args=")(const struct lu_env *env, struct dt_object *dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a9072566fd18a198a7323439603b6fbdf">dt_object_operations::do_write_locked</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether write lock is held. </p>
<p>The caller can learn whether write lock is held on the object</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>no write lock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>write lock is held </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02203">dt_write_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5346269fb80455252849f4fd7403720"></a><!-- doxytag: member="dt_object_operations::do_write_unlock" ref="ad5346269fb80455252849f4fd7403720" args=")(const struct lu_env *env, struct dt_object *dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__object__operations.html#ad5346269fb80455252849f4fd7403720">dt_object_operations::do_write_unlock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release write lock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02194">dt_write_unlock()</a>, and <a class="el" href="ofd__internal_8h_source.html#l00279">ofd_write_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a19762fb1d9e75136521019d51759b6ec"></a><!-- doxytag: member="dt_object_operations::do_xattr_del" ref="a19762fb1d9e75136521019d51759b6ec" args=")(const struct lu_env *env, struct dt_object *dt, const char *name, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a19762fb1d9e75136521019d51759b6ec">dt_object_operations::do_xattr_del</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an extended attribute. </p>
<p>This method deletes the specified extended attribute. The object must exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02529">dt_xattr_del()</a>.</p>

</div>
</div>
<a class="anchor" id="af4c8c504e52a5571dbd0557980c3818a"></a><!-- doxytag: member="dt_object_operations::do_xattr_get" ref="af4c8c504e52a5571dbd0557980c3818a" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_buf *buf, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#af4c8c504e52a5571dbd0557980c3818a">dt_object_operations::do_xattr_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a value of an extended attribute. </p>
<p>The object must exist. If the buffer is NULL, then the method must return the size of the value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer in which to store the value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the extended attribute</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ERANGE</em>&nbsp;</td><td>if <em>buf</em> is too small </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>value's size if <em>buf</em> is NULL or has zero size </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02588">dt_xattr_get()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ace7a9f2e3ae94bb5d5b7434917f0f1"></a><!-- doxytag: member="dt_object_operations::do_xattr_list" ref="a0ace7a9f2e3ae94bb5d5b7434917f0f1" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a0ace7a9f2e3ae94bb5d5b7434917f0f1">dt_object_operations::do_xattr_list</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a list of the extended attributes. </p>
<p>Fills the passed buffer with a list of the extended attributes found in the object. The <a class="el" href="structnames.html">names</a> are separated with ''. The object must exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer to put the list in</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>bytes used/required in the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02602">dt_xattr_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a231db7d512a5786b8ad887e9fc47190b"></a><!-- doxytag: member="dt_object_operations::do_xattr_set" ref="a231db7d512a5786b8ad887e9fc47190b" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf, const char *name, int fl, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__object__operations.html#a231db7d512a5786b8ad887e9fc47190b">dt_object_operations::do_xattr_set</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, int fl, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an extended attribute. </p>
<p>Change or replace the specified extended attribute (EA). The flags passed in <em>fl</em> dictate whether the EA is to be created or replaced, as follows. LU_XATTR_CREATE - fail if EA exists LU_XATTR_REPLACE - fail if EA doesn't exist The object must exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer storing new value of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>name of the attribute </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fl</em>&nbsp;</td><td>flags indicating EA creation or replacement </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02559">dt_xattr_set()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="dt__object_8h_source.html">dt_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:53 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
